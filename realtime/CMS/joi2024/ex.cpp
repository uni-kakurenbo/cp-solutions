/*
 * @uni_kakurenbo
 * https://github.com/uni-kakurenbo/competitive-programming-workspace
 *
 * CC0 1.0  http://creativecommons.org/publicdomain/zero/1.0/deed.ja
 */
/* #language C++ 20 GCC */
/* [begin]: template/standard.hpp */
#pragma GCC target ""
/* [begin]: template/debug.hpp */
#ifdef LOCAL_JUDGE
#define DEBUGGER_ENABLED 1
#include <debugger/debug.hpp>
#define debug(...) debugger::debug(debugger::split(#__VA_ARGS__), 0, __LINE__, __VA_ARGS__)
#define DEBUG(...) do { debugger::DEBUG(nullptr, "\033[3;35m#" + std::to_string(__LINE__) + "\033[m "); debugger::DEBUG(__VA_ARGS__); debugger::DEBUG(nullptr, "\033[m\n"); } while(0);
#else
#define debug(...) ({ ; })
#define DEBUG(...) ({ ; })
#endif
/* [end]: template/debug.hpp*/
/* [begin]: template/using.hpp */
#include <bits/stdc++.h>
/* [begin]: include/template.hpp */
/* [begin]: include/snippets.hpp */
/* [begin]: snippet/aliases.hpp */
#include <cstdint>
#include <utility>
#include <vector>
#include <ranges>
/* [begin]: internal/dev_env.hpp */
#ifndef $DEV_ENV
#define $DEV_ENV
#ifdef LOCAL_JUDGE
constexpr bool DEV_ENV = true; constexpr bool NO_EXCEPT = false;
#else
constexpr bool DEV_ENV = false; constexpr bool NO_EXCEPT = true;
#endif
#if __cplusplus >= 202100L
#define CPP20 true
#define CPP23 true
#elif __cplusplus >= 202002L
#define CPP20 true
#define CPP23 false
#else
#define CPP20 false
#define CPP23 false
#endif
#endif
/* [end]: internal/dev_env.hpp*/
/* [begin]: snippet/internal/types.hpp */
namespace lib { using i16 = std::int16_t; using u16 = std::uint16_t; using i32 = std::int32_t; using u32 = std::uint32_t; using i64 = std::int64_t; using u64 = std::uint64_t;
#ifdef __GNUC__
using i128 = __int128_t; using u128 = __uint128_t;
#endif
using uint = unsigned; using ll = long long; using ull = unsigned long long; using ld = long double; }
/* [end]: snippet/internal/types.hpp*/
#define until(...) while(!(__VA_ARGS__))
#define CONTINUE(...) { __VA_ARGS__; continue; }
#define BREAK(...) { __VA_ARGS__; break; }
#define ALL(x) std::ranges::begin((x)),std::ranges::end((x))
#define RALL(x) std::ranges::rbegin((x)),std::ranges::rend((x))
#define $F first
#define $S second
namespace lib { constexpr char LN = '\n'; constexpr char SPC = ' '; constexpr std::pair<int,int> DIRS4[] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } }; constexpr std::pair<int,int> DIRS4P[] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 }, { 0, 0 } }; constexpr std::pair<int,int> DIRS8[] = { { -1, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 } }; constexpr std::pair<int,int> DIRS8P[] = { { -1, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 }, { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { 0, 0 } }; template<class T> using spair = std::pair<T,T>; } namespace std { using bit_reference = std::vector<bool>::reference; bit_reference operator |= (bit_reference a, const bool b) noexcept(NO_EXCEPT) { return a = a | b; } bit_reference operator &= (bit_reference a, const bool b) noexcept(NO_EXCEPT) { return a = a & b; } }
/* [end]: snippet/aliases.hpp*/
/* [begin]: snippet/fast_io.hpp */
#include <iostream>
#ifdef __GNUC__
__attribute__((constructor)) inline void fast_io() noexcept(NO_EXCEPT) { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); }
#else
inline void fast_io() noexcept(NO_EXCEPT) { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); }
#endif
/* [end]: snippet/fast_io.hpp*/
/* [begin]: snippet/iterations.hpp */
#include <type_traits>
/* [begin]: macro/overload.hpp */
#define $OVERLOAD2(arg0, arg1, cmd, ...) cmd
#define $OVERLOAD3(arg0, arg1, arg2, cmd, ...) cmd
#define $OVERLOAD4(arg0, arg1, arg2, arg3, cmd, ...) cmd
#define $OVERLOAD5(arg0, arg1, arg2, arg3, arg4, cmd, ...) cmd
#define $OVERLOAD6(arg0, arg1, arg2, arg3, arg4, arg5, cmd, ...) cmd
/* [end]: macro/overload.hpp*/
#define LOOP(n) REPI($_, (n))
#define REPI(i,n) for(std::decay_t<decltype(n)> i=0, i##_length=(n); i<i##_length; ++i)
#define REPF(i,l,r) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>> i=(l), i##_last=(r); i<i##_last; ++i)
#define REPIS(i,l,r,s) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>,std::decay_t<decltype(s)>> i=(l), i##_last=(r); i<i##_last; i+=(s))
#define REPR(i,n) for(auto i=(n); --i>=0;)
#define REPB(i,l,r) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>> i=(r), i##_last=(l); --i>=i##_last;)
#define REPRS(i,l,r,s) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>,std::decay_t<decltype(s)>> i=(l)+((r)-(l)-1)/(s)*(s), i##_last=(l); i>=i##_last; (i-=(s)))
#define REP(...) $OVERLOAD4(__VA_ARGS__, REPIS, REPF, REPI, LOOP)(__VA_ARGS__)
#define REPD(...) $OVERLOAD4(__VA_ARGS__, REPRS, REPB, REPR)(__VA_ARGS__)
#define FORO(i,n) for(int i=0, i##_last=static_cast<int>(n); i<=i##_last; ++i)
#define FORI(i,l,r) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>> i=(l), i##_last=(r); i<=i##_last; ++i)
#define FORIS(i,l,r,s) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>,std::decay_t<decltype(s)>> i=(l), i##_last=(r); i<=i##_last; i+=(s))
#define FORRO(i,n) for(auto i=(n); i>=0; --i)
#define FORR(i,l,r) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>> i=(r), i##_last=(l); i>=i##_last; --i)
#define FORRS(i,l,r,s) for(std::common_type_t<std::decay_t<decltype(l)>,std::decay_t<decltype(r)>,std::decay_t<decltype(s)>> i=(l)+((r)-(l))/(s)*(s), i##_last=(l); i>=i##_last; i-=(s))
#define FOR(...) $OVERLOAD4(__VA_ARGS__, FORIS, FORI, FORO)(__VA_ARGS__)
#define FORD(...) $OVERLOAD4(__VA_ARGS__, FORRS, FORR, FORRO)(__VA_ARGS__)
#define ITR1(e0,v) for(const auto &e0 : (v))
#define ITRP1(e0,v) for(auto e0 : (v))
#define ITRR1(e0,v) for(auto &e0 : (v))
#define ITR2(e0,e1,v) for(const auto [e0, e1] : (v))
#define ITRP2(e0,e1,v) for(auto [e0, e1] : (v))
#define ITRR2(e0,e1,v) for(auto &[e0, e1] : (v))
#define ITR3(e0,e1,e2,v) for(const auto [e0, e1, e2] : (v))
#define ITRP3(e0,e1,e2,v) for(auto [e0, e1, e2] : (v))
#define ITRR3(e0,e1,e2,v) for(auto &[e0, e1, e2] : (v))
#define ITR4(e0,e1,e2,e3,v) for(const auto [e0, e1, e2, e3] : (v))
#define ITRP4(e0,e1,e2,e3,v) for(auto [e0, e1, e2, e3] : (v))
#define ITRR4(e0,e1,e2,e3,v) for(auto &[e0, e1, e2, e3] : (v))
#define ITR5(e0,e1,e2,e3,e4,v) for(const auto [e0, e1, e2, e3, e4] : (v))
#define ITRP5(e0,e1,e2,e3,e4,v) for(auto [e0, e1, e2, e3, e4] : (v))
#define ITRR5(e0,e1,e2,e3,e4,v) for(auto &[e0, e1, e2, e3, e4] : (v))
#define ITR(...) $OVERLOAD6(__VA_ARGS__, ITR5, ITR4, ITR3, ITR2, ITR1)(__VA_ARGS__)
#define ITRP(...) $OVERLOAD6(__VA_ARGS__, ITRP5, ITRP4, ITRP3, ITRP2, ITRP1)(__VA_ARGS__)
#define ITRR(...) $OVERLOAD6(__VA_ARGS__, ITRR5, ITRR4, ITRR3, ITRR2, ITRR1)(__VA_ARGS__)
/* [end]: snippet/iterations.hpp*/
/* [end]: include/snippets.hpp*/
/* [begin]: include/views.hpp */
/* [begin]: view/cyclic.hpp */
#include <cassert>
#include <concepts>
#include <tuple>
#include <iterator>
/* [begin]: internal/ranges.hpp */
/* [begin]: internal/type_traits.hpp */
#ifndef INCLUDED_TYPE_TRAITS
#define INCLUDED_TYPE_TRAITS
#include <algorithm>
namespace lib { namespace internal { template<class... Ts> struct tuple_or_pair { using type = std::tuple<Ts...>; }; template<class T, class U> struct tuple_or_pair<T,U> { using type = std::pair<T, U>; }; template <class... Ts> using tuple_or_pair_t = typename tuple_or_pair<Ts...>::type; template<class T> constexpr std::underlying_type_t<T> to_underlying(const T& v) noexcept(NO_EXCEPT) { return static_cast<std::underlying_type_t<T>>(v); } template<class T, class... Us> using are_same = std::conjunction<std::is_same<T,Us>...>; template<class T, class... Us> inline constexpr bool are_same_v = std::conjunction_v<std::is_same<T,Us>...>; template<class Base, class... Derived> using is_base_of_all = std::conjunction<std::is_base_of<Base,Derived>...>; template<class Base, class... Derived> inline constexpr bool are_base_of_v = std::conjunction_v<std::is_same<Base,Derived>...>; template<class T> struct remove_cvref { using type = typename std::remove_cv_t<std::remove_reference_t<T>>; }; template<class T> using remove_cvref_t = typename remove_cvref<T>::type; template<class T> struct literal_operator { static constexpr const char* value = ""; }; template<> struct literal_operator<unsigned> { static constexpr const char* value = "U"; }; template<> struct literal_operator<long> { static constexpr const char* value = "L"; }; template<> struct literal_operator<long double> { static constexpr const char* value = "L"; }; template<> struct literal_operator<unsigned long> { static constexpr const char* value = "UL"; }; template<> struct literal_operator<long long> { static constexpr const char* value = "LL"; }; template<> struct literal_operator<unsigned long long> { static constexpr const char* value = "ULL"; };
#ifdef __SIZEOF_INT128__
template<> struct literal_operator<__int128_t> { static constexpr const char* value = "LLL"; }; template<> struct literal_operator<__uint128_t> { static constexpr const char* value = "ULLL"; };
#endif
template<class T> inline constexpr const char* literal_operator_v = literal_operator<T>::value; template<template <class...> class Template, class Arg> struct is_template : std::false_type {}; template<template <class...> class Template, class... Args> struct is_template<Template, Template<Args...>> : std::true_type {}; template<template <class...> class Template, class... Args> inline constexpr bool is_template_v = is_template<Template,Args...>::value; template<class T> struct is_loggable { template<class U> static constexpr auto External(U &&v) -> decltype(_debug(v), std::true_type()); static constexpr std::false_type External(...); template<class U> static constexpr auto Member(U &&v) -> decltype(v._debug(), std::true_type()); static constexpr std::false_type Member(...); static constexpr bool value = ( decltype(External(std::declval<T>()))::value || decltype(Member(std::declval<T>()))::value ); }; template<class T> inline constexpr auto is_loggable_v = is_loggable<T>::value; template<class T> struct _has_iterator { template<class U> static constexpr auto ADL(U &&v) -> decltype(begin(v), end(v), std::true_type()); static constexpr std::false_type ADL(...); template<class U> static constexpr auto STL(U &&v) -> decltype(std::begin(v), std::end(v), std::true_type()); static constexpr std::false_type STL(...); template<class U> static constexpr auto Member(U &&v) -> decltype(v.begin(), v.end(), std::true_type()); static constexpr std::false_type Member(...); }; template<class T> struct has_iterator { struct ADL : decltype(_has_iterator<T>::ADL(std::declval<T>())) {}; struct STL : decltype(_has_iterator<T>::STL(std::declval<T>())) {}; struct Member : decltype(_has_iterator<T>::Member(std::declval<T>())) {}; static constexpr auto adl_v = ADL::value; static constexpr auto stl_v = STL::value; static constexpr auto member_v = Member::value; }; template<class T> struct is_iterable { static constexpr bool value = has_iterator<T>::adl_v || has_iterator<T>::stl_v || has_iterator<T>::member_v; }; template<class T> inline constexpr auto is_iterable_v = is_iterable<T>::value; template<class T> concept iterable = is_iterable_v<T>; namespace iterator_resolver { template<class T> inline constexpr auto begin(T&& v) noexcept(NO_EXCEPT) { static_assert(is_iterable_v<T>); if constexpr(has_iterator<T>::member_v) { return v.begin(); } else { using std::begin; return begin(std::forward<T>(v)); } } template<class T> inline constexpr auto end(T&& v) noexcept(NO_EXCEPT) { static_assert(is_iterable_v<T>); if constexpr(has_iterator<T>::member_v) { return v.end(); } else { using std::end; return end(std::forward<T>(v)); } } }; template<class C> using iterator_t = decltype(iterator_resolver::begin(std::declval<C&>())); template<class C> using container_size_t = decltype(std::size(std::declval<C&>())); template<bool Const, class T> using maybe_const_t = std::conditional_t<Const, const T, T>; template<class T> using with_ref = T&; template<class T> concept can_reference = requires { typename with_ref<T>; }; } }
#endif
/* [end]: internal/type_traits.hpp*/
namespace lib { namespace internal { template<class Range> concept resizable_range = std::ranges::range<Range> && requires (Range& r) { r.resize(0); }; template<class range> concept simple_view = std::ranges::view<range> && std::ranges::range<const range> && std::same_as<std::ranges::iterator_t<range>, std::ranges::iterator_t<const range>> && std::same_as<std::ranges::sentinel_t<range>, std::ranges::sentinel_t<const range>>; template<class... Ranges> concept zip_is_common = (sizeof...(Ranges) == 1 && (std::ranges::common_range<Ranges> && ...)) || (!(std::ranges::bidirectional_range<Ranges> && ...) && (std::ranges::common_range<Ranges> && ...)) || ((std::ranges::random_access_range<Ranges> && ...) && (std::ranges::sized_range<Ranges> && ...)); template<bool Const, class... Views> concept all_contiguous = (std::ranges::contiguous_range<maybe_const_t<Const, Views>> && ...); template<bool Const, class... Views> concept all_random_access = (std::ranges::random_access_range<maybe_const_t<Const, Views>> && ...); template<bool Const, class... Views> concept all_bidirectional = (std::ranges::bidirectional_range<maybe_const_t<Const, Views>> && ...); template<bool Const, class... Views> concept all_forward = (std::ranges::forward_range<maybe_const_t<Const, Views>> && ...); template<bool Const, class... Views> struct zip_view_iterator_category {}; template<bool Const, class... Views> requires all_forward<Const, Views...> struct zip_view_iterator_category<Const, Views...> { using iterator_category = std::input_iterator_tag; }; template<bool Const, class... Views> static auto _most_primitive_iterator_concept() noexcept(NO_EXCEPT) { if constexpr(all_contiguous<Const, Views...>) return std::contiguous_iterator_tag{}; else if constexpr(all_random_access<Const, Views...>) return std::random_access_iterator_tag{}; else if constexpr(all_bidirectional<Const, Views...>) return std::bidirectional_iterator_tag{}; else if constexpr(all_forward<Const, Views...>) return std::forward_iterator_tag{}; else return std::input_iterator_tag{}; } template<bool Const, class... Views> using most_primitive_iterator_concept = decltype(_most_primitive_iterator_concept<Const, Views...>()); template<class Range, bool Const> using range_iterator_category = typename std::iterator_traits< std::ranges::iterator_t<maybe_const_t<Const, Range>> >::iterator_category; template<class Range> inline static constexpr auto _iterator_concept() noexcept(NO_EXCEPT) { if constexpr(std::ranges::random_access_range<Range>) return std::random_access_iterator_tag{}; else if constexpr(std::ranges::bidirectional_range<Range>) return std::bidirectional_iterator_tag{}; else if constexpr(std::ranges::forward_range<Range>) return std::forward_iterator_tag{}; else return std::input_iterator_tag{}; } template<class Range> using iterator_concept = decltype(_iterator_concept<Range>()); } namespace views::adapter { template<class Adapter, class... Args> concept adapter_invocable = requires { std::declval<Adapter>()(std::declval<Args>()...); }; template<class Adapter, class... Args> concept adapter_partial_app_viable = (Adapter::arity > 1) && (sizeof...(Args) == Adapter::arity - 1) && (std::constructible_from<std::decay_t<Args>, Args> && ...); template<class Adapter, class... Args> struct partial; template<class, class> struct pipe; struct range_adapter_closure { template<class Self, class Range> requires std::derived_from<std::remove_cvref_t<Self>, range_adapter_closure> && adapter_invocable<Self, Range> friend inline constexpr auto operator|(Range &&range, Self &&self) noexcept(NO_EXCEPT) { return std::forward<Self>(self)(std::forward<Range>(range)); } template<class Lhs, class Rhs> requires std::derived_from<Lhs, range_adapter_closure> && std::derived_from<Rhs, range_adapter_closure> friend inline constexpr auto operator|(Lhs lhs, Rhs rhs) noexcept(NO_EXCEPT) { return pipe<Lhs, Rhs>{ std::move(lhs), std::move(rhs) }; } }; template<class Derived> struct range_adapter { template<class... Args> requires adapter_partial_app_viable<Derived, Args...> inline constexpr auto operator()(Args &&..._args) const noexcept(NO_EXCEPT) { return partial<Derived, std::decay_t<Args>...>{ std::forward<Args>(_args)... }; } }; template<class Adapter> concept closure_has_simple_call_op = Adapter::has_simple_call_op; template<class Adapter, class... Args> concept adapter_has_simple_extra_args = Adapter::has_simple_extra_args || Adapter::template has_simple_extra_args<Args...>; template<class Adapter, class... Args> struct partial : range_adapter_closure { std::tuple<Args...> args; constexpr partial(Args... _args) noexcept(NO_EXCEPT) : args(std::move(_args)...) {} template<class Range> requires adapter_invocable<Adapter, Range, const Args &...> inline constexpr auto operator()(Range &&range) const & noexcept(NO_EXCEPT) { const auto forwarder = [&range](const auto &..._args) constexpr noexcept(NO_EXCEPT) { return Adapter{}(std::forward<Range>(range), _args...); }; return std::apply(forwarder, this->args); } template<class Range> requires adapter_invocable<Adapter, Range, Args...> inline constexpr auto operator()(Range &&range) && noexcept(NO_EXCEPT) { const auto forwarder = [&range](auto &..._args) constexpr noexcept(NO_EXCEPT) { return Adapter{}(std::forward<Range>(range), std::move(_args)...); }; return std::apply(forwarder, this->args); } template<class Range> inline constexpr auto operator()(Range &&range) const && = delete; }; template<class Adapter, typename Arg> struct partial<Adapter, Arg> : range_adapter_closure { Arg arg; constexpr partial(Arg _arg) noexcept(NO_EXCEPT) : arg(std::move(_arg)) {} template<class Range> requires adapter_invocable<Adapter, Range, const Arg &> inline constexpr auto operator()(Range &&range) const & noexcept(NO_EXCEPT) { return Adapter{}(std::forward<Range>(range), this->arg); } template<class Range> requires adapter_invocable<Adapter, Range, Arg> inline constexpr auto operator()(Range &&range) && noexcept(NO_EXCEPT) { return Adapter{}(std::forward<Range>(range), std::move(this->arg)); } template<class Range> inline constexpr auto operator()(Range &&range) const && = delete; }; template<class Adapter, class... Args> requires adapter_has_simple_extra_args<Adapter, Args...> && (std::is_trivially_copyable_v<Args> && ...) struct partial<Adapter, Args...> : range_adapter_closure { std::tuple<Args...> args; constexpr partial(Args... _args) noexcept(NO_EXCEPT) : args(std::move(_args)...) {} template<class Range> requires adapter_invocable<Adapter, Range, const Args &...> inline constexpr auto operator()(Range &&range) const noexcept(NO_EXCEPT) { const auto forwarder = [&range](const auto &..._args) constexpr noexcept(NO_EXCEPT) { return Adapter{}(std::forward<Range>(range), _args...); }; return std::apply(forwarder, this->args); } inline static constexpr bool has_simple_call_op = true; }; template<class Adapter, typename Arg> requires adapter_has_simple_extra_args<Adapter, Arg> && std::is_trivially_copyable_v<Arg> struct partial<Adapter, Arg> : range_adapter_closure { Arg arg; constexpr partial(Arg _arg) noexcept(NO_EXCEPT) : arg(std::move(_arg)) {} template<class Range> requires adapter_invocable<Adapter, Range, const Arg &> inline constexpr auto operator()(Range &&range) const noexcept(NO_EXCEPT) { return Adapter{}(std::forward<Range>(range), this->arg); } inline static constexpr bool has_simple_call_op = true; }; template<class Lhs, typename Rhs, typename Range> concept pipe_invocable = requires { std::declval<Rhs>()(std::declval<Lhs>()(std::declval<Range>())); }; template<class Lhs, typename Rhs> struct pipe : range_adapter_closure { [[no_unique_address]] Lhs lhs; [[no_unique_address]] Rhs rhs; constexpr pipe(Lhs lhs, Rhs rhs) noexcept(NO_EXCEPT) : lhs(std::move(lhs)), rhs(std::move(rhs)) {} template<class Range> requires pipe_invocable<const Lhs &, const Rhs &, Range> inline constexpr auto operator()(Range &&range) const & noexcept(NO_EXCEPT) { return rhs(lhs(std::forward<Range>(range))); } template<class Range> requires pipe_invocable<Lhs, Rhs, Range> inline constexpr auto operator()(Range &&range) && noexcept(NO_EXCEPT) { return std::move(rhs)(std::move(lhs)(std::forward<Range>(range))); } template<class Range> inline constexpr auto operator()(Range &&range) const && = delete; }; template<class Lhs, typename Rhs> requires closure_has_simple_call_op<Lhs> && closure_has_simple_call_op<Rhs> struct pipe<Lhs, Rhs> : range_adapter_closure { [[no_unique_address]] Lhs lhs; [[no_unique_address]] Rhs rhs; constexpr pipe(Lhs lhs, Rhs rhs) noexcept(NO_EXCEPT) : lhs(std::move(lhs)), rhs(std::move(rhs)) {} template<class Range> requires pipe_invocable<const Lhs &, const Rhs &, Range> inline constexpr auto operator()(Range &&range) const noexcept(NO_EXCEPT) { return rhs(lhs(std::forward<Range>(range))); } inline static constexpr bool has_simple_call_op = true; }; } }
/* [end]: internal/ranges.hpp*/
/* [begin]: utility/functional.hpp */
#include <functional>
#include <optional>
/* [begin]: numeric/arithmetic.hpp */
#include <cstring>
#include <string>
/* [begin]: ac-library/atcoder/math */
/* [begin]: ac-library/atcoder/math.hpp */
#ifndef ATCODER_MATH_HPP
#define ATCODER_MATH_HPP 1
/* [begin]: ac-library/atcoder/internal_math */
/* [begin]: ac-library/atcoder/internal_math.hpp */
#ifndef ATCODER_INTERNAL_MATH_HPP
#define ATCODER_INTERNAL_MATH_HPP 1
#ifdef _MSC_VER
#include <intrin.h>
#endif
namespace atcoder { namespace internal { constexpr long long safe_mod(long long x, long long m) { x %= m; if (x < 0) x += m; return x; } struct barrett { unsigned int _m; unsigned long long im; explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {} unsigned int umod() const { return _m; } unsigned int mul(unsigned int a, unsigned int b) const { unsigned long long z = a; z *= b;
#ifdef _MSC_VER
unsigned long long x; _umul128(z, im, &x);
#else
unsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);
#endif
unsigned long long y = x * _m; return (unsigned int)(z - y + (z < y ? _m : 0)); } }; constexpr long long pow_mod_constexpr(long long x, long long n, int m) { if (m == 1) return 0; unsigned int _m = (unsigned int)(m); unsigned long long r = 1; unsigned long long y = safe_mod(x, m); while (n) { if (n & 1) r = (r * y) % _m; y = (y * y) % _m; n >>= 1; } return r; } constexpr bool is_prime_constexpr(int n) { if (n <= 1) return false; if (n == 2 || n == 7 || n == 61) return true; if (n % 2 == 0) return false; long long d = n - 1; while (d % 2 == 0) d /= 2; constexpr long long bases[3] = {2, 7, 61}; for (long long a : bases) { long long t = d; long long y = pow_mod_constexpr(a, t, n); while (t != n - 1 && y != 1 && y != n - 1) { y = y * y % n; t <<= 1; } if (y != n - 1 && t % 2 == 0) { return false; } } return true; } template <int n> constexpr bool is_prime = is_prime_constexpr(n); constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) { a = safe_mod(a, b); if (a == 0) return {b, 0}; long long s = b, t = a; long long m0 = 0, m1 = 1; while (t) { long long u = s / t; s -= t * u; m0 -= m1 * u; auto tmp = s; s = t; t = tmp; tmp = m0; m0 = m1; m1 = tmp; } if (m0 < 0) m0 += b / s; return {s, m0}; } constexpr int primitive_root_constexpr(int m) { if (m == 2) return 1; if (m == 167772161) return 3; if (m == 469762049) return 3; if (m == 754974721) return 11; if (m == 998244353) return 3; int divs[20] = {}; divs[0] = 2; int cnt = 1; int x = (m - 1) / 2; while (x % 2 == 0) x /= 2; for (int i = 3; (long long)(i)*i <= x; i += 2) { if (x % i == 0) { divs[cnt++] = i; while (x % i == 0) { x /= i; } } } if (x > 1) { divs[cnt++] = x; } for (int g = 2;; g++) { bool ok = true; for (int i = 0; i < cnt; i++) { if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) { ok = false; break; } } if (ok) return g; } } template <int m> constexpr int primitive_root = primitive_root_constexpr(m); unsigned long long floor_sum_unsigned(unsigned long long n, unsigned long long m, unsigned long long a, unsigned long long b) { unsigned long long ans = 0; while (true) { if (a >= m) { ans += n * (n - 1) / 2 * (a / m); a %= m; } if (b >= m) { ans += n * (b / m); b %= m; } unsigned long long y_max = a * n + b; if (y_max < m) break; n = (unsigned long long)(y_max / m); b = (unsigned long long)(y_max % m); std::swap(m, a); } return ans; } } }
#endif
/* [end]: ac-library/atcoder/internal_math.hpp*/
/* [end]: ac-library/atcoder/internal_math*/
namespace atcoder { long long pow_mod(long long x, long long n, int m) { assert(0 <= n && 1 <= m); if (m == 1) return 0; internal::barrett bt((unsigned int)(m)); unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m)); while (n) { if (n & 1) r = bt.mul(r, y); y = bt.mul(y, y); n >>= 1; } return r; } long long inv_mod(long long x, long long m) { assert(1 <= m); auto z = internal::inv_gcd(x, m); assert(z.first == 1); return z.second; } std::pair<long long, long long> crt(const std::vector<long long>& r, const std::vector<long long>& m) { assert(r.size() == m.size()); int n = int(r.size()); long long r0 = 0, m0 = 1; for (int i = 0; i < n; i++) { assert(1 <= m[i]); long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i]; if (m0 < m1) { std::swap(r0, r1); std::swap(m0, m1); } if (m0 % m1 == 0) { if (r0 % m1 != r1) return {0, 0}; continue; } long long g, im; std::tie(g, im) = internal::inv_gcd(m0, m1); long long u1 = (m1 / g); if ((r1 - r0) % g) return {0, 0}; long long x = (r1 - r0) / g % u1 * im % u1; r0 += x * m0; m0 *= u1; if (r0 < 0) r0 += m0; } return {r0, m0}; } long long floor_sum(long long n, long long m, long long a, long long b) { assert(0 <= n && n < (1LL << 32)); assert(1 <= m && m < (1LL << 32)); unsigned long long ans = 0; if (a < 0) { unsigned long long a2 = internal::safe_mod(a, m); ans -= 1ULL * n * (n - 1) / 2 * ((a2 - a) / m); a = a2; } if (b < 0) { unsigned long long b2 = internal::safe_mod(b, m); ans -= 1ULL * n * ((b2 - b) / m); b = b2; } return ans + internal::floor_sum_unsigned(n, m, a, b); } }
#endif
/* [end]: ac-library/atcoder/math.hpp*/
/* [end]: ac-library/atcoder/math*/
/* [begin]: internal/types.hpp */
namespace lib { namespace internal { using size_t = std::int32_t; using int128_t = __int128_t; using uint128_t = __uint128_t; } }
/* [end]: internal/types.hpp*/
/* [begin]: internal/concepts.hpp */
#ifndef INCLUDED_CONCEPTS
#define INCLUDED_CONCEPTS
namespace lib { namespace internal { template<class T> concept arithmetic = std::is_arithmetic_v<T>; template<class T> concept pointer = std::is_pointer_v<T>; template<class T> concept structural = std::is_class_v<T>; template<class Large, class Small> concept has_double_digits_of = (std::numeric_limits<Large>::digits == 2 * std::numeric_limits<Small>::digits); template<class T> concept has_static_zero = requires { T::zero; }; template<class T> concept has_static_one = requires { T::one; }; template<class L, class R = L> concept weakly_addable = requires (L lhs, R rhs) { lhs + rhs; }; template<class L, class R = L> concept weakly_subtractable = requires (L lhs, R rhs) { lhs - rhs; }; template<class L, class R = L> concept weakly_multipliable = requires (L lhs, R rhs) { lhs * rhs; }; template<class L, class R = L> concept weakly_divisable = requires (L lhs, R rhs) { lhs / rhs; }; template<class L, class R = L> concept weakly_addition_assignable = requires (L lhs, R rhs) { lhs += rhs; }; template<class L, class R = L> concept weakly_subtraction_assignable = requires (L lhs, R rhs) { lhs -= rhs; }; template<class L, class R = L> concept weakly_multipliation_assignalbe = requires (L lhs, R rhs) { lhs *= rhs; }; template<class L, class R = L> concept weakly_division_assignable = requires (L lhs, R rhs) { lhs /= rhs; }; template<class L, class R = L> concept addable = weakly_addable<L, R> && weakly_addable<std::invoke_result_t<std::plus<>&, L, R>, R> && weakly_addable<L, std::invoke_result_t<std::plus<>&, L, R>> && weakly_addable<std::invoke_result_t<std::plus<>&, L, R>, std::invoke_result_t<std::plus<>&, L, R>>; template<class L, class R = L> concept subtractable = weakly_subtractable<L, R> && weakly_subtractable<std::invoke_result_t<std::minus<>&, L, R>, R> && weakly_subtractable<L, std::invoke_result_t<std::minus<>&, L, R>> && weakly_subtractable<std::invoke_result_t<std::minus<>&, L, R>, std::invoke_result_t<std::minus<>&, L, R>>; template<class L, class R = L> concept multipliable = weakly_multipliable<L, R> && weakly_multipliable<std::invoke_result_t<std::multiplies<>&, L, R>, R> && weakly_multipliable<L, std::invoke_result_t<std::multiplies<>&, L, R>> && weakly_multipliable<std::invoke_result_t<std::multiplies<>&, L, R>, std::invoke_result_t<std::multiplies<>&, L, R>>; template<class L, class R = L> concept divisable = weakly_divisable<L, R> && weakly_divisable<std::invoke_result_t<std::divides<>&, L, R>, R> && weakly_divisable<L, std::invoke_result_t<std::divides<>&, L, R>> && weakly_divisable<std::invoke_result_t<std::divides<>&, L, R>, std::invoke_result_t<std::divides<>&, L, R>>; template<class L, class R = L> concept addition_assignable = weakly_addition_assignable<L, R> && weakly_addition_assignable<std::decay_t<std::invoke_result_t<std::plus<>&, L, R>>, R> && weakly_addition_assignable<L, std::invoke_result_t<std::plus<>&, L, R>> && weakly_addition_assignable<std::decay_t<std::invoke_result_t<std::plus<>&, L, R>>, std::invoke_result_t<std::plus<>&, L, R>>; template<class L, class R = L> concept subtraction_assignable = weakly_subtraction_assignable<L, R> && weakly_subtraction_assignable<std::decay_t<std::invoke_result_t<std::minus<>&, L, R>>, R> && weakly_subtraction_assignable<L, std::invoke_result_t<std::minus<>&, L, R>> && weakly_subtraction_assignable<std::decay_t<std::invoke_result_t<std::minus<>&, L, R>>, std::invoke_result_t<std::minus<>&, L, R>>; template<class L, class R = L> concept multipliation_assignalbe = weakly_multipliation_assignalbe<L, R> && weakly_multipliation_assignalbe<std::decay_t<std::invoke_result_t<std::multiplies<>&, L, R>>, R> && weakly_multipliation_assignalbe<L, std::invoke_result_t<std::multiplies<>&, L, R>> && weakly_multipliation_assignalbe<std::decay_t<std::invoke_result_t<std::multiplies<>&, L, R>>, std::invoke_result_t<std::multiplies<>&, L, R>>; template<class L, class R = L> concept division_assignable = weakly_division_assignable<L, R> && weakly_division_assignable<std::decay_t<std::invoke_result_t<std::divides<>&, L, R>>, R> && weakly_division_assignable<L, std::invoke_result_t<std::divides<>&, L, R>> && weakly_division_assignable<std::decay_t<std::invoke_result_t<std::divides<>&, L, R>>, std::invoke_result_t<std::divides<>&, L, R>>; template<class T> concept weakly_incrementable = std::movable<T> && requires (T v) { { ++v } -> std::same_as<T&>; v++; }; template<class T> concept weakly_decrementable = std::movable<T> && requires (T v) { { --v } -> std::same_as<T&>; v--; }; template<class T> concept incrementable = std::regular<T> && weakly_incrementable<T> && requires (T v) { { v++ } -> std::same_as<T>; }; template<class T> concept decrementable = std::regular<T> && weakly_decrementable<T> && requires (T v) { { v-- } -> std::same_as<T>; }; template<class L, class R = L> concept weakly_arithmetic_operable = weakly_addable<L, R> && weakly_subtractable<L, R> && weakly_multipliable<L, R> && weakly_divisable<L, R>; template<class L, class R = L> concept weakly_arithmetic_operation_assignable = weakly_addition_assignable<L, R> && weakly_subtraction_assignable<L, R> && weakly_multipliation_assignalbe<L, R> && weakly_division_assignable<L, R>; template<class L, class R = L> concept arithmetic_operable = weakly_arithmetic_operable<L, R> && addable<L, R> && subtractable<L, R> && multipliable<L, R> && divisable<L, R>; template<class L, class R = L> concept arithmetic_operation_assignable = weakly_arithmetic_operation_assignable<L, R> && addition_assignable<L, R> && subtraction_assignable<L, R> && multipliation_assignalbe<L, R> && division_assignable<L, R>; template<class T> concept unary_addable = requires (T v) { { +v } -> std::same_as<T>; }; template<class T> concept unary_subtractable = requires (T v) { { -v } -> std::same_as<T>; }; template<class T> concept numeric = std::regular<T> && arithmetic_operable<T> && arithmetic_operation_assignable<T> && weakly_incrementable<T> && unary_addable<T> && unary_subtractable<T>; } }
#endif
/* [end]: internal/concepts.hpp*/
/* [begin]: numeric/internal/number_base.hpp */
#include <cstddef>
/* [begin]: adapter/string.hpp */
/* [begin]: adapter/internal/container_extender.hpp */
namespace lib { namespace internal { template<class Base> struct extended_container : Base { private: inline Base* _base() noexcept(NO_EXCEPT) { return static_cast<Base*>(this); } inline const Base* _base() const noexcept(NO_EXCEPT) { return static_cast<const Base*>(this); } public: using Base::Base; extended_container(const Base& base) : Base(base) {} using size_type = decltype(Base().size()); using value_type = typename Base::value_type; inline auto& fill(const value_type& v) noexcept(NO_EXCEPT) { std::ranges::fill(*this->_base(), v); return *this; } inline auto& swap(const size_type i, const size_type j) noexcept(NO_EXCEPT) { std::swap(this->_base()->operator[](i), this->_base()->operator[](j)); return *this; } inline auto& sort() noexcept(NO_EXCEPT) { std::ranges::sort(*this->_base()); return *this; } template<class F> inline auto& sort(const F& f) noexcept(NO_EXCEPT) { std::ranges::sort(*this->_base(), f); return *this; } inline auto& stable_sort() noexcept(NO_EXCEPT) { std::ranges::stable_sort(*this->_base()); return *this; } template<class F> inline auto& stable_sort(const F& f) noexcept(NO_EXCEPT) { std::ranges::stable_sort(*this->_base(), f); return *this; } inline auto& reverse() noexcept(NO_EXCEPT) { std::ranges::reverse(*this->_base()); return *this; } inline auto count(const value_type& v) const noexcept(NO_EXCEPT) { return std::ranges::count(*this->_base(), v); } template<class F> inline auto count_if(F& f) const noexcept(NO_EXCEPT) { return std::ranges::count_if(*this->_base(), f); } inline auto& resize(const size_type k) noexcept(NO_EXCEPT) { this->Base::resize(k); return *this; } inline auto& resize(const size_type k, const value_type v) noexcept(NO_EXCEPT) { this->Base::resize(k, v); return *this; } template<class F> inline auto& shuffle(const F& f) noexcept(NO_EXCEPT) { std::ranges::shuffle(*this->_base(), f); return *this; } inline auto& unique() noexcept(NO_EXCEPT) { std::ranges::sort(*this->_base()); const auto rest = std::ranges::unique(*this->_base()); this->erase(ALL(rest)); return *this; } template<class T> inline auto binary_search(const T& v) noexcept(NO_EXCEPT) { return std::ranges::binary_search(*this->_base(), v); } template<class T> inline auto lower_bound(const T& v) noexcept(NO_EXCEPT) { return std::ranges::lower_bound(*this->_base(), v); } template<class T> inline auto upper_bound(const T& v) noexcept(NO_EXCEPT) { return std::ranges::upper_bound(*this->_base(), v); } }; } }
/* [end]: adapter/internal/container_extender.hpp*/
namespace lib { using string = internal::extended_container<std::string>; }
/* [end]: adapter/string.hpp*/
/* [begin]: adapter/vector.hpp */
namespace lib { template<class... Args> using vector = internal::extended_container<std::vector<Args...>>; }
/* [end]: adapter/vector.hpp*/
namespace lib { template<std::size_t B, class T> lib::string to_base_n_string(T v) noexcept(NO_EXCEPT) { constexpr char CHARS[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; static_assert(0 < B and B <= std::char_traits<char>::length(CHARS)); assert(0 <= v); lib::string res; while(v > 0) { res += CHARS[v%B]; v /= B; } std::reverse(ALL(res)); return res; } template<class T> lib::string to_base_n_string(T v, const lib::internal::size_t b) noexcept(NO_EXCEPT) { constexpr char CHARS[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"; assert(1 < b && b <= std::char_traits<char>::length(CHARS)); assert(0 <= v); lib::string res; while(v > 0) { res += CHARS[v%b]; v /= b; } std::reverse(ALL(res)); return res; } template<class T> lib::vector<T> to_base_n_vector(T v, const lib::internal::size_t b) noexcept(NO_EXCEPT) { assert(1 < b); assert(0 <= v); lib::vector<T> res; while(v > 0) { res.push_back(v%b); v /= b; } return res; } template<class I, class T = typename std::iterator_traits<I>::value_type> T from_base_n_sequence(I begin, I end, const lib::internal::size_t b) noexcept(NO_EXCEPT) { assert(1 < b); if(begin == end) return 0; T res = 0; for(auto itr=end; itr-- != begin; ) { res *= b; res += *itr; } return res; } template<std::ranges::bidirectional_range R, class T = std::ranges::range_value_t<R>> requires std::ranges::common_range<R> T from_base_n_sequence(R range, const lib::internal::size_t b) noexcept(NO_EXCEPT) { return from_base_n_sequence(std::ranges::begin(range), std::ranges::end(range), b); } }
/* [end]: numeric/internal/number_base.hpp*/
/* [begin]: iterable/operation.hpp */
#include <initializer_list>
#include <sstream>
#include <valarray>
#include <numeric>
#include <limits>
/* [begin]: internal/exception.hpp */
namespace lib { namespace internal { template<class... T> constexpr bool EXCEPTION = false; template<const int T> constexpr bool EXCEPTION_INT = false; } }
/* [end]: internal/exception.hpp*/
/* [begin]: internal/iterator.hpp */
#include <variant>
namespace lib { namespace internal { template<class T> struct iterator_interface { using iterator_category = std::output_iterator_tag; using difference_type = size_t; using value_type = T; using pointer = T*; using reference = T&; }; template<class T> struct forward_iterator : iterator_interface<T> { using iterator_category = std::forward_iterator_tag; }; template<class T> struct bidirectional_iterator_interface : forward_iterator<T> { using iterator_category = std::bidirectional_iterator_tag; }; template<class T> struct random_access_iterator_base : bidirectional_iterator_interface<T> { using iterator_category = std::random_access_iterator_tag; using difference_type = typename bidirectional_iterator_interface<T>::difference_type; public: friend inline random_access_iterator_base operator+(random_access_iterator_base itr, const difference_type count) noexcept(NO_EXCEPT) { return itr += count, itr; } friend inline random_access_iterator_base operator-(random_access_iterator_base itr, const difference_type count) noexcept(NO_EXCEPT) { return itr -= count, itr; } }; template<class T, class Container, class Derived> struct container_iterator_interface : random_access_iterator_base<T> { using difference_type = typename bidirectional_iterator_interface<T>::difference_type; protected: const Container* _ref; difference_type _pos; inline Derived* _derived() noexcept(NO_EXCEPT) { return static_cast<Derived*>(this); } inline const Derived* _derived() const noexcept(NO_EXCEPT) { return static_cast<const Derived*>(this); } public: container_iterator_interface() noexcept = default; container_iterator_interface(const Container *const ref, const difference_type& pos) noexcept(NO_EXCEPT) : _ref(ref), _pos(pos) {} inline const Container* ref() const noexcept(NO_EXCEPT) { return this->_ref; } inline difference_type pos() const noexcept(NO_EXCEPT) { return this->_pos; } inline difference_type& pos() { return this->_pos; } inline Derived& operator++() noexcept(NO_EXCEPT) { return ++this->_derived()->pos(), *this->_derived(); } inline Derived& operator--() noexcept(NO_EXCEPT) { return --this->_derived()->pos(), *this->_derived(); } inline Derived operator++(int) noexcept(NO_EXCEPT) { const auto res = *this->_derived(); return ++this->_derived()->pos(), res; } inline Derived operator--(int) noexcept(NO_EXCEPT) { const auto res = *this->_derived(); return --this->_derived()->pos(), res; } inline Derived& operator+=(const difference_type count) noexcept(NO_EXCEPT) { return this->pos() += count, *this->_derived(); } inline Derived& operator-=(const difference_type count) noexcept(NO_EXCEPT) { return this->pos() -= count, *this->_derived(); } inline auto operator*() const noexcept(NO_EXCEPT) { return this->ref()->get(this->pos()); } inline T operator[](const difference_type count) const noexcept(NO_EXCEPT) { return *(*this->_derived() + count); } inline difference_type operator-(const container_iterator_interface& other) const noexcept(NO_EXCEPT) { return this->pos() - other.pos(); } inline bool operator<(const container_iterator_interface& other) const noexcept(NO_EXCEPT) { return *this->_derived() - other < 0; } inline bool operator>(const container_iterator_interface& other) const noexcept(NO_EXCEPT) { return *this->_derived() - other > 0; } inline bool operator<=(const container_iterator_interface& other) const noexcept(NO_EXCEPT) { return not (*this->_derived() > other); } inline bool operator>=(const container_iterator_interface& other) const noexcept(NO_EXCEPT) { return not (*this->_derived() < other); } inline bool operator==(const container_iterator_interface& other) const noexcept(NO_EXCEPT) { return this->_derived()->ref() == other.ref() and this->pos() == other.pos(); } inline bool operator!=(const container_iterator_interface& other) const noexcept(NO_EXCEPT) { return not (*this->_derived() == other); } }; template<class V, std::input_or_output_iterator I> inline auto to_non_const_iterator(V v, I itr) noexcept(NO_EXCEPT) { return std::ranges::next(std::ranges::begin(v), std::ranges::distance(std::ranges::cbegin(v), itr)); } namespace iterator_impl { template<class... Tags> using is_all_random_access_iterator = is_base_of_all<std::random_access_iterator_tag,Tags...>; template<class... Tags> using is_all_bidirectional_iterator = is_base_of_all<std::bidirectional_iterator_tag,Tags...>; template<class... Tags> using is_all_forward_iterator = is_base_of_all<std::forward_iterator_tag,Tags...>; template<class... Tags> using is_all_input_iterator = is_base_of_all<std::input_iterator_tag,Tags...>; template<class... Tags> constexpr auto _most_primitive_iterator_tag() { if constexpr(is_all_random_access_iterator<Tags...>::value) { return std::random_access_iterator_tag{}; } else if constexpr(is_all_bidirectional_iterator<Tags...>::value) { return std::bidirectional_iterator_tag{}; } else if constexpr(is_all_forward_iterator<Tags...>::value) { return std::forward_iterator_tag{}; } else { return std::input_iterator_tag{}; } } } template<class... Tags> using most_primitive_iterator_tag = decltype(iterator_impl::_most_primitive_iterator_tag<Tags...>()); template<class T, class = void> struct is_iterator { static constexpr bool value = false; }; template<class T> struct is_iterator<T, typename std::enable_if<!std::is_same<typename std::iterator_traits<T>::value_type, void>::value>::type> { static constexpr bool value = true; }; template<class T> constexpr bool is_iterator_v = is_iterator<T>::value; template<class T> using is_iterator_t = std::enable_if_t<is_iterator_v<T>>; template<class T> using iota_diff_t = std::make_signed_t<T>; } }
/* [end]: internal/iterator.hpp*/
/* [begin]: iterable/z_array.hpp */
/* [begin]: adapter/valarray.hpp */
namespace lib { template<class T> struct valarray : internal::extended_container<std::valarray<T>> { private: using base = internal::extended_container<std::valarray<T>>; public: using size_type = internal::size_t; using iterator = T*; using const_iterator = const T*; protected: inline bool _validate_index_in_right_open([[maybe_unused]] const size_type p) const noexcept(NO_EXCEPT) { return 0 <= p and p < this->size(); } inline bool _validate_index_in_closed([[maybe_unused]] const size_type p) const noexcept(NO_EXCEPT) { return 0 <= p and p <= this->size(); } inline bool _validate_rigth_open_interval([[maybe_unused]] const size_type l, [[maybe_unused]] const size_type r) const noexcept(NO_EXCEPT) { return 0 <= l and l <= r and r <= this->size(); } inline size_type _positivize_index(const size_type p) const noexcept(NO_EXCEPT) { return p < 0 ? this->size() + p : p; } public: valarray() noexcept(NO_EXCEPT) {} explicit valarray(const std::size_t length, const T& val = T{}) noexcept(NO_EXCEPT) : base(std::forward<const T>(val), length) {} template<std::input_iterator I, std::sentinel_for<I> S> valarray(I first, S last) noexcept(NO_EXCEPT) : base(std::ranges::distance(first, last)) { std::ranges::copy(first, last, std::ranges::begin(*this)); } template<class U> valarray(const U* pointer, const size_t n) noexcept(NO_EXCEPT) : base(pointer, n) {}; valarray(const std::slice_array<T>& arr) noexcept(NO_EXCEPT) : base(arr) {}; valarray(const std::gslice_array<T>& arr) noexcept(NO_EXCEPT) : base(arr) {}; valarray(const std::mask_array<T>& arr) noexcept(NO_EXCEPT) : base(arr) {}; valarray(const std::indirect_array<T>& arr) noexcept(NO_EXCEPT) : base(arr) {}; valarray(const std::initializer_list<T>& init) noexcept(NO_EXCEPT) : base(init) {}
#ifdef __GNUC__
template<class Dom> valarray(const std::_Expr<Dom,T>& expr) noexcept(NO_EXCEPT) : base(expr) {}
#endif
inline auto size() const noexcept(NO_EXCEPT) { return static_cast<size_type>(this->base::size()); } inline void reserve(const size_type) noexcept(NO_EXCEPT) { /* do nothing */ } template<std::input_iterator I, std::sentinel_for<I> S> inline void assign(I first, S last) noexcept(NO_EXCEPT) { this->resize(std::ranges::distance(first, last)); std::ranges::copy(first, last, std::ranges::begin(*this)); } inline void assign(const std::size_t length, const T& val = T{}) noexcept(NO_EXCEPT) { this->base::resize(length, val); } inline void resize(const std::size_t length, const T& val = T{}) noexcept(NO_EXCEPT) { base temp = *this; this->assign(length, val); std::move(std::begin(temp), std::min(std::end(temp), std::next(std::begin(temp), length)), std::begin(*this)); } inline const T& operator[](size_type pos) const noexcept(NO_EXCEPT) { pos = this->_positivize_index(pos), assert(this->_validate_index_in_right_open(pos)); return this->base::operator[](pos); } inline T& operator[](size_type pos) noexcept(NO_EXCEPT) { pos = this->_positivize_index(pos), assert(this->_validate_index_in_right_open(pos)); return this->base::operator[](pos); } inline const T& back() const noexcept(NO_EXCEPT) { return *std::prev(this->end()); } inline T& back() noexcept(NO_EXCEPT) { return *std::prev(this->end()); } inline const T& front() const noexcept(NO_EXCEPT) { return *this->begin(); } inline T& front() noexcept(NO_EXCEPT) { return *this->begin(); } inline const T* begin() const noexcept(NO_EXCEPT) { return this->size() ? std::addressof((*this)[0]) : nullptr; } inline T* begin() noexcept(NO_EXCEPT) { return this->size() ? std::addressof((*this)[0]) : nullptr; } inline const T* end() const noexcept(NO_EXCEPT) { if(auto n = this->size()) { return std::addressof((*this)[0]) + n; } else { return nullptr; } } inline T* end() noexcept(NO_EXCEPT) { if(auto n = this->size()) { return std::addressof((*this)[0]) + n; } else { return nullptr; } } inline auto rbegin() noexcept(NO_EXCEPT) { return std::make_reverse_iterator(std::end(*this)); } inline auto rend() noexcept(NO_EXCEPT) { return std::make_reverse_iterator(std::begin(*this)); } inline auto rbegin() const noexcept(NO_EXCEPT) { return std::make_reverse_iterator(std::end(*this)); } inline auto rend() const noexcept(NO_EXCEPT) { return std::make_reverse_iterator(std::begin(*this)); } }; }
/* [end]: adapter/valarray.hpp*/
namespace lib { template<class SizeType = internal::size_t, class Container = valarray<SizeType>> struct z_array : Container { using size_type = SizeType; template<std::input_iterator I, std::sentinel_for<I> S> explicit z_array(I first, S last) : Container(std::distance(first, last), {}) { const size_type n = static_cast<size_type>(std::distance(first, last)); if(n == 0) return; for(size_type i=1, j=0; i<n; ++i) { size_type& k = this->operator[](i); k = (j + this->operator[](j) <= i) ? 0 : std::min(j + this->operator[](j) - i, this->operator[](i - j)); while(i + k < n and first[k] == first[i + k]) ++k; if(j + this->operator[](j) < i + this->operator[](i)) j = i; } *this->begin() = n; } }; }
/* [end]: iterable/z_array.hpp*/
/* [begin]: view/concat.hpp */
/* [begin]: view/internal/base.hpp */
namespace lib { namespace internal { namespace view_impl { struct base {}; struct iterator_base {}; template<class T> using is_view = std::is_base_of<base,T>; template<class T> inline constexpr auto is_view_v = is_view<T>::value; template<class T> using is_view_t = std::enable_if_t<is_view_v<T>>; template<class T> using is_view_iterator = std::is_base_of<iterator_base,T>; template<class T> inline constexpr auto is_view_iterator_v = is_view_iterator<T>::value; template<class T> using is_view_iterator_t = std::enable_if_t<is_view_iterator_v<T>>; } } }
/* [end]: view/internal/base.hpp*/
namespace lib { namespace internal { namespace view_impl { template<std::ranges::input_range V0, std::ranges::input_range V1> requires std::ranges::view<V0> && std::ranges::view<V1> struct concat_view : std::ranges::view_interface<concat_view<V0, V1>> { private: V0 _b0; V1 _b1; template<bool Const> using B0 = internal::maybe_const_t<Const, V0>; template<bool Const> using B1 = internal::maybe_const_t<Const, V1>; template<bool Const> struct iterator_tag {}; template<bool Const> requires std::ranges::forward_range<B0<Const>> && std::ranges::forward_range<B1<Const>> struct iterator_tag<Const> { public: using iterator_category = lib::internal::most_primitive_iterator_tag< typename std::iterator_traits<std::ranges::iterator_t<B0<Const>>>::iterator_category, typename std::iterator_traits<std::ranges::iterator_t<B1<Const>>>::iterator_category >; }; public: template<bool> class iterator; constexpr explicit concat_view(V0 v0, V1 v1) noexcept(NO_EXCEPT) : _b0(std::move(v0)), _b1(std::move(v1)) {} inline constexpr std::pair<V0, V1> base() const & noexcept(NO_EXCEPT) requires std::copy_constructible<V0> && std::copy_constructible<V0> { return { this->_b0, this->_b1 }; } inline constexpr std::pair<V0,V1> base() && noexcept(NO_EXCEPT) { return { std::move(this->_b0), std::move(this->_b1) }; } inline constexpr auto begin() noexcept(NO_EXCEPT) requires (!internal::simple_view<V0> && !internal::simple_view<V1>) { return iterator<false>(this, std::ranges::begin(this->_b0), std::ranges::begin(this->_b1), 0); } inline constexpr auto begin() const noexcept(NO_EXCEPT) requires std::ranges::range<const V0> && std::ranges::range<const V1> { return iterator<true>(this, std::ranges::begin(this->_b0), std::ranges::begin(this->_b1), 0); } inline constexpr auto end() noexcept(NO_EXCEPT) requires (!internal::simple_view<V0> && !internal::simple_view<V1>) { if constexpr(std::ranges::common_range<V0> && std::ranges::common_range<V1>) { return iterator<false>(this, std::ranges::end(this->_b0), std::ranges::end(this->_b1), 1); } else { return std::default_sentinel; } } inline constexpr auto end() const noexcept(NO_EXCEPT) requires std::ranges::range<const V0> && std::ranges::range<const V1> { if constexpr(std::ranges::common_range<const V0> && std::ranges::common_range<const V1>) { return iterator<true>(this, std::ranges::end(this->_b0), std::ranges::end(this->_b1), 1); } else { return std::default_sentinel; } } inline constexpr auto size() noexcept(NO_EXCEPT) requires std::ranges::sized_range<V0> && std::ranges::sized_range<V1> { return static_cast<std::size_t>(std::ranges::distance(this->_b0) + std::ranges::distance(this->_b1)); } inline constexpr auto size() const noexcept(NO_EXCEPT) requires std::ranges::sized_range<const V0> && std::ranges::sized_range<const V1> { return static_cast<std::size_t>(std::ranges::distance(this->_b0) + std::ranges::distance(this->_b1)); } }; template<std::ranges::input_range V0, std::ranges::input_range V1> requires std::ranges::view<V0> && std::ranges::view<V1> template<bool Const> struct concat_view<V0, V1>::iterator : iterator_tag<Const> { private: using Parent = internal::maybe_const_t<Const, concat_view>; using B0 = concat_view::B0<Const>; using B1 = concat_view::B1<Const>; std::ranges::iterator_t<B0> _c0 = std::ranges::iterator_t<B0>(); std::ranges::iterator_t<B0> _b0 = std::ranges::iterator_t<B0>(); std::ranges::sentinel_t<B0> _e0 = std::ranges::sentinel_t<B0>(); std::ranges::iterator_t<B1> _c1 = std::ranges::iterator_t<B1>(); std::ranges::iterator_t<B1> _b1 = std::ranges::iterator_t<B1>(); std::ranges::sentinel_t<B1> _e1 = std::ranges::sentinel_t<B1>(); int _block = 0; constexpr iterator(Parent *const parent, const std::ranges::iterator_t<B0> c0, const std::ranges::iterator_t<B1> c1, const int block) noexcept(NO_EXCEPT) : _c0(std::move(c0)), _b0(std::ranges::begin(parent->_b0)), _e0(std::ranges::end(parent->_b0)), _c1(std::move(c1)), _b1(std::ranges::begin(parent->_b1)), _e1(std::ranges::end(parent->_b1)), _block(block) {} friend concat_view; public: using difference_type = std::common_type_t<std::ranges::range_difference_t<B0>, std::ranges::range_difference_t<B1>>; using value_type = std::common_type_t<std::ranges::range_value_t<B0>, std::ranges::range_value_t<B1>>; using reference_type = std::common_reference_t<std::ranges::range_reference_t<B0>, std::ranges::range_reference_t<B1>>; using iterator_concept = lib::internal::most_primitive_iterator_tag< internal::most_primitive_iterator_concept<Const, V0, V1> >; iterator() noexcept(NO_EXCEPT) requires std::default_initializable<std::ranges::iterator_t<B0>> && std::default_initializable<std::ranges::iterator_t<B0>> = default; constexpr iterator(iterator<!Const> itr) noexcept(NO_EXCEPT) requires Const && std::convertible_to<std::ranges::iterator_t<V0>, std::ranges::iterator_t<B0>> && std::convertible_to<std::ranges::sentinel_t<V0>, std::ranges::sentinel_t<B0>> && std::convertible_to<std::ranges::iterator_t<V1>, std::ranges::iterator_t<B1>> && std::convertible_to<std::ranges::sentinel_t<V1>, std::ranges::sentinel_t<B1>> : _c0(std::move(itr._c0)), _b0(std::move(itr._b0)), _e0(std::move(itr._e0)), _c1(std::move(itr._c0)), _b1(std::move(itr._b0)), _e1(std::move(itr._e1)), _block(itr._block) {} inline constexpr std::variant<std::ranges::iterator_t<B0>, std::ranges::iterator_t<B1>> base() && noexcept(NO_EXCEPT) { if(this->_block == 0) return std::move(this->_c0); else return std::move(this->_C1); } inline constexpr std::variant< std::reference_wrapper<const std::ranges::iterator_t<B0>>, std::reference_wrapper<const std::ranges::iterator_t<B1>> > base() const & noexcept { if(this->_block == 0) return std::move(this->_c0); else return std::move(this->_c1); } inline constexpr reference_type operator*() const noexcept(NO_EXCEPT) { if(this->_block == 0) return *this->_c0; else return *this->_c1; } inline constexpr iterator& operator++() noexcept(NO_EXCEPT) { assert(this->_c0 != this->_e0 or this->_c1 != this->_e1); if(this->_block == 0) { if(++this->_c0 == this->_e0) { this->_block = 1; assert(this->_c1 == this->_b1); } } else { ++this->_c1; } return *this; } inline constexpr void operator++(int) noexcept(NO_EXCEPT) { ++*this; } inline constexpr iterator operator++(int) noexcept(NO_EXCEPT) requires std::ranges::forward_range<B0> && std::ranges::forward_range<B1> { const auto res = *this; ++*this; return res; } inline constexpr iterator& operator--() noexcept(NO_EXCEPT) requires std::ranges::bidirectional_range<B0> && std::ranges::bidirectional_range<B1> && std::bidirectional_iterator<std::ranges::sentinel_t<B0>> { if(this->_block == 1) { if(this->_c1 == this->_b1) { this->_block = 0; this->_c0 = std::ranges::prev(this->_e0); } else { --this->_c1; } } else { --this->_c0; } return *this; } inline constexpr iterator operator--(int) noexcept(NO_EXCEPT) requires std::ranges::bidirectional_range<B0> && std::ranges::bidirectional_range<B1> { const auto res = *this; --*this; return res; } inline constexpr iterator& operator+=(const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { if(diff > 0) { if(this->_block == 0) { const auto missing = std::ranges::advance(this->_c0, diff, this->_e0); if(this->_c0 == this->_e0) { this->_block = 1; assert(this->_c1 == this->_b1); std::ranges::advance(this->_c1, missing, this->_e1); } } else { std::ranges::advance(this->_c1, diff, this->_e1); } } if(diff < 0) { if(this->_block == 1) { const auto missing = std::ranges::advance(this->_c1, diff, this->_b1); if(missing > 0) { this->_block = 0; assert(this->_c0 == this->_e0); std::ranges::advance(this->_c0, -missing, this->_b0); } } else { std::ranges::advance(this->_c0, diff, this->_b0); } } return *this; } inline constexpr iterator& operator-=(const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { return *this += -diff; } inline constexpr decltype(auto) operator[](const difference_type diff) const noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { return *(*this + diff); } friend inline constexpr bool operator==(const iterator& lhs, std::default_sentinel_t) noexcept(NO_EXCEPT) { if(lhs._block == 0) return false; if(lhs._block == 1) return lhs._c1 == lhs._e1; assert(false); } friend inline constexpr bool operator==(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::equality_comparable<std::ranges::iterator_t<B0>> && std::equality_comparable<std::ranges::iterator_t<B1>> { if(lhs._block != rhs._block) return false; return lhs._block == 0 ? lhs._c0 == rhs._c0 : lhs._c1 == rhs._c1; } friend inline constexpr bool operator<(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { if(lhs._block != rhs._block) return lhs._block < rhs._block; return lhs._block == 0 ? lhs._c0 < rhs._c0 : lhs._c1 < rhs._c1; } friend inline constexpr bool operator>(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { if(lhs._block != rhs._block) return lhs._block > rhs._block; return lhs._block == 0 ? lhs._c0 > rhs._c0 : lhs._c1 > rhs._c1; } friend inline constexpr bool operator<=(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { return !(rhs < lhs); } friend inline constexpr bool operator>=(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { return !(lhs < rhs); } friend inline constexpr auto operator<=>(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { if(lhs._block != rhs._block) return lhs._block <=> rhs._block; return lhs._block == 0 ? lhs._c0 <=> rhs._c0 : lhs._c1 <=> rhs._c1; } friend inline constexpr iterator operator+(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { auto res = itr; res += diff; return res; } friend inline constexpr iterator operator+(const difference_type diff, const iterator& itr) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { return itr + diff; } friend inline constexpr iterator operator-(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<B0> && std::ranges::random_access_range<B1> { auto res = itr; res -= diff; return res; } friend inline constexpr const difference_type operator-(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::sized_sentinel_for<std::ranges::iterator_t<B0>, std::ranges::iterator_t<B0>> && std::sized_sentinel_for<std::ranges::iterator_t<B1>, std::ranges::iterator_t<B1>> { if(lhs._block == rhs._block) { return lhs._block == 0 ? std::ranges::distance(rhs._c0, lhs._c0) : std::ranges::distance(rhs._c1, lhs._c1); } if(lhs._block > rhs._block) return std::ranges::distance(rhs._c0, rhs._e0) + std::ranges::distance(lhs._b1, lhs._c1); if(lhs._block < rhs._block) return -(rhs - lhs); assert(false); } friend inline constexpr const difference_type operator-(std::default_sentinel_t, const iterator& rhs) noexcept(NO_EXCEPT) requires std::sized_sentinel_for<std::ranges::sentinel_t<B0>, std::ranges::iterator_t<B0>> && std::sized_sentinel_for<std::ranges::sentinel_t<B1>, std::ranges::iterator_t<B1>> { if(rhs._block == 0) return std::ranges::distance(rhs._c0, rhs._e0) + std::ranges::distance(rhs._b1, rhs._e1); if(rhs._block == 1) return std::ranges::distance(rhs._c1, rhs._e1); assert(false); } friend inline constexpr const difference_type operator-(const iterator& lhs, std::default_sentinel_t rhs) noexcept(NO_EXCEPT) requires std::sized_sentinel_for<std::ranges::sentinel_t<B0>, std::ranges::iterator_t<B0>> && std::sized_sentinel_for<std::ranges::sentinel_t<B1>, std::ranges::iterator_t<B1>> { return -(rhs - lhs); } friend inline constexpr std::common_reference_t< std::ranges::range_rvalue_reference_t<B0>, std::ranges::range_rvalue_reference_t<B1> > iter_move(const iterator& itr) noexcept(NO_EXCEPT) { if(itr._block == 0) return std::ranges::iter_move(itr._c0); if(itr._block == 1) return std::ranges::iter_move(itr._c1); assert(false); } friend inline constexpr void iter_swap(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::indirectly_swappable<std::ranges::iterator_t<B0>> && std::indirectly_swappable<std::ranges::iterator_t<B1>> && std::indirectly_swappable<std::ranges::iterator_t<B0>, std::ranges::iterator_t<B1>> { if(lhs._block == 0 && rhs._block == 0) std::ranges::iter_swap(lhs._c0, rhs._c0); if(lhs._block == 0 && rhs._block == 1) std::ranges::iter_swap(lhs._c0, rhs._c1); if(lhs._block == 1 && rhs._block == 0) std::ranges::iter_swap(lhs._c1, rhs._c0); if(lhs._block == 1 && rhs._block == 1) std::ranges::iter_swap(lhs._c1, rhs._c1); assert(false); } }; } } template<class...> struct concat_view; template<class T> struct concat_view<T> : std::views::all_t<T> { explicit concat_view(T&& v) noexcept(NO_EXCEPT) : std::views::all_t<T>(std::forward<T>(v)) {} }; template<class T0, class T1> struct concat_view<T0, T1> : internal::view_impl::concat_view<std::views::all_t<T0>, std::views::all_t<T1>> { explicit concat_view(T0&& v0, T1&& v1) noexcept(NO_EXCEPT) : internal::view_impl::concat_view<std::views::all_t<T0>, std::views::all_t<T1>>(std::forward<T0>(v0), std::forward<T1>(v1)) {} }; template<class T0, class T1, class... Ts> struct concat_view<T0, T1, Ts...> : concat_view<concat_view<T0, T1>, Ts...> { explicit concat_view(T0&& v0, T1&& v1, Ts&&... vs) noexcept(NO_EXCEPT) : concat_view<concat_view<T0, T1>, Ts...>( concat_view<T0, T1>(std::forward<T0>(v0), std::forward<T1>(v1)), std::forward<Ts>(vs)... ) {} }; namespace views { namespace internal { template<class... Ts> concept can_concat_view = requires { concat_view<Ts...>(std::declval<Ts>()...); }; } struct Concat { template<class... Ts> requires (sizeof...(Ts) == 0 || internal::can_concat_view<Ts...>) inline constexpr auto operator() [[nodiscard]] (Ts&&... vs) const { if constexpr(sizeof...(Ts) == 0) return std::views::empty<std::nullptr_t>; else return concat_view<std::views::all_t<Ts>...>(std::forward<Ts>(vs)...); } }; inline constexpr Concat concat; } } namespace std::ranges { template<class... Views> inline constexpr bool enable_borrowed_range<lib::concat_view<Views...>> = (enable_borrowed_range<Views> && ...); }
/* [end]: view/concat.hpp*/
/* [begin]: global/constants.hpp */
/* [begin]: numeric/limits.hpp */
namespace lib { template<class T> struct numeric_limits : std::numeric_limits<T> { static constexpr long double FLOAT_EPSILON = 1E-14; static constexpr T arithmetic_infinity() noexcept(NO_EXCEPT) { return std::numeric_limits<T>::max() / 2 - 1; } static constexpr T arithmetic_negative_infinity() noexcept(NO_EXCEPT) { return std::numeric_limits<T>::lowest() / 2 + 1; } static constexpr T arithmetic_epsilon() noexcept(NO_EXCEPT) { if constexpr(std::is_floating_point_v<T>) { return numeric_limits::FLOAT_EPSILON; } else { return 0; } } }; constexpr i32 INF32 = numeric_limits<i32>::arithmetic_infinity(); constexpr i64 INF64 = numeric_limits<i64>::arithmetic_infinity(); template<class T> constexpr T INF = numeric_limits<T>::arithmetic_infinity(); template<class T> constexpr T EPSILON = numeric_limits<T>::arithmetic_epsilon(); }
/* [end]: numeric/limits.hpp*/
namespace lib { enum class comparison : std::uint8_t { equal_to, not_equal_to, equals = equal_to, eq = equal_to, under, over, or_under, or_over, less = under, more = over, less_than = under, more_than = over, not_less_than = or_over, not_more_than = or_under, leq = or_under, geq = or_over }; enum class interval_notation : std::uint8_t { right_open, left_open, open, closed, }; enum class replacement_policy : std::uint8_t { insert_sync, overwrite_sync, overwrite_async }; enum class rotation : std::int8_t { clockwise, counter_clockwise, anti_clockwise = counter_clockwise, }; enum class positional_relation : std::int8_t { clockwise, counter_clockwise, anti_clockwise = counter_clockwise, straight_backward, straight_forward, straight_middle, in, on, out }; enum class alignment : std::int8_t { left, center, right }; }
/* [end]: global/constants.hpp*/
namespace lib { template<std::input_iterator I, std::sentinel_for<I> S> std::string join(I first, S last, const char* sep = "") noexcept(NO_EXCEPT) { if(first == last) return ""; std::advance(last, -1); std::ostringstream res; std::copy(first, last, std::ostream_iterator<std::iter_value_t<I>>(res, sep)); res << *last; return res.str(); } template<std::ranges::input_range R> std::string join(R&& range, const char* sep = "") noexcept(NO_EXCEPT) { return join(ALL(range), sep); } template<std::ranges::input_range R0, std::ranges::input_range R1> requires std::constructible_from< R0, std::common_type_t<std::ranges::range_size_t<R0>,std::ranges::range_size_t<R1>> > R0 concat(R0&& r0, R1&& r1) noexcept(NO_EXCEPT) { R0 res(std::ranges::size(r0) + std::ranges::size(r1)); std::ranges::copy(r0, std::ranges::begin(res)); std::ranges::copy(r1, std::ranges::next(std::ranges::begin(res), std::ranges::size(r0))); return res; } template<std::ranges::input_range R, std::ranges::input_range... Rs> R concat(R&& range, Rs&&... tails) noexcept(NO_EXCEPT) { return lib::concat(range, lib::concat(tails...)); } template<class I, class T = std::iter_value_t<I>> requires std::sentinel_for<I, I> T sum(I first, I last, const T& base = {}) noexcept(NO_EXCEPT) { return std::accumulate(first, last, base); } template<std::ranges::input_range R, class T = std::ranges::range_value_t<R>> auto sum(R&& range, T base = {}) noexcept(NO_EXCEPT) { auto&& r = range | std::views::common; return sum(ALL(r), base); } template<std::ranges::input_range R> requires requires(R r) { r.erase(std::ranges::unique(ALL(r)), std::ranges::end(r)); } inline auto unique(R range) noexcept(NO_EXCEPT) { std::ranges::sort(range); range.erase(std::ranges::unique(ALL(range)), std::ranges::end(range)); return range; } template< std::input_iterator I, std::sentinel_for<I> S, class T = std::iter_value_t<I> > T mex(I first, S last, const T& base = {}) noexcept(NO_EXCEPT) { std::vector<T> val(first, last); std::ranges::sort(val); val.erase(std::ranges::unique(ALL(val)), val.end()); val.erase(val.begin(), std::ranges::lower_bound(val, base)); std::ranges::range_size_t<std::vector<T>> i = 0; while(i < std::ranges::size(val) and val[i] == T{i} + base) ++i; return T{i} + base; } template<class T> auto mex(const std::initializer_list<T> v) noexcept(NO_EXCEPT) { return mex(ALL(v)); } template<class T> auto mex(const std::initializer_list<T> v, const T& base) noexcept(NO_EXCEPT) { return mex(ALL(v), base); } template<std::input_iterator I, std::sentinel_for<I> S, class T> inline constexpr auto gcd(I first, S last) noexcept(NO_EXCEPT) { T res = T{0}; for(auto itr=first; itr!=last; ++itr) res = std::gcd(res, *itr); return res; } template<std::input_iterator I, std::sentinel_for<I> S, class T> inline constexpr auto lcm(I first, S last) noexcept(NO_EXCEPT) { T res = T{1}; for(auto itr=first; itr!=last; ++itr) res = std::lcm(res, *itr); return res; } template<std::ranges::input_range R, class T = std::ranges::range_value_t<R>> auto mex(R&& range, const T& base) noexcept(NO_EXCEPT) { return mex(ALL(range), base); } template<std::ranges::input_range R> auto gcd(R&& range) noexcept(NO_EXCEPT) { return gcd(ALL(range)); } template<std::ranges::input_range R> auto lcm(R&& range) noexcept(NO_EXCEPT) { return lcm(ALL(range)); } template<class R, std::input_iterator I, std::sentinel_for<I> S, class D> requires requires (R r, I itr) { r.emplace_back(itr, itr); } auto split(I first, S last, const D& delim = ' ') noexcept(NO_EXCEPT) { R res; for(auto itr=first, fnd=first; ; itr=std::next(fnd)) { fnd = std::find(itr, last, delim); res.emplace_back(itr, fnd); if(fnd == last) break; } return res; } template<class R, std::ranges::input_range V, class D> requires (!std::ranges::range<D>) auto split(V&& v, D&& d) noexcept(NO_EXCEPT) { return split<R>(ALL(v), d); } template<class R, std::ranges::input_range V, std::ranges::range Ds> auto split(V&& v, Ds&& ds) noexcept(NO_EXCEPT) { R res = { v }; ITR(d, ds) { R tmp; ITR(p, res) tmp = concat(tmp, split<R>(p, d)); res = std::move(tmp); } return res; } template<class R, std::ranges::input_range V, class T> auto split(V&& v, const std::initializer_list<T> ds) noexcept(NO_EXCEPT){ return split<R,V>(v, std::vector<T>(ALL(ds))); } template<std::ranges::sized_range R> auto find(R source, R query) noexcept(NO_EXCEPT) { using value_type = std::ranges::range_value_t<R>; const auto joined = views::concat(source, query); std::vector<value_type> pre_z(std::begin(joined), std::end(joined)); z_array z_arr(ALL(pre_z)); const internal::size_t query_size = std::ranges::size(query); vector<std::ranges::iterator_t<R>> res; { auto itr = std::ranges::begin(source); REP(i, query_size, z_arr.size()) { if(z_arr[i] >= query_size) res.push_back(internal::to_non_const_iterator(source, itr)); ++itr; } } return res; } template<std::ranges::input_range R, replacement_policy POLICY = replacement_policy::insert_sync> auto replace(R&& source, R&& from, R&& to) noexcept(NO_EXCEPT) { R res; if constexpr(POLICY == replacement_policy::insert_sync) { const auto found = find(source, from); auto itr = std::begin(source); ITRR(fn, found) { std::ranges::copy(itr, fn, std::back_inserter(res)); std::ranges::copy(ALL(to), std::back_inserter(res)); itr = std::ranges::next(fn, std::size(from)); } std::ranges::copy(itr, std::ranges::end(source), std::back_inserter(res)); } else { res = source; res.resize(std::size(source) + std::size(to)); const auto found = find(res, from); auto prev = std::ranges::begin(res); ITRR(fn, found) { if constexpr(POLICY == replacement_policy::overwrite_sync) { if(prev <= fn) prev = std::copy(ALL(to), internal::to_non_const_iterator(res, fn)); } else { std::copy(ALL(to), internal::to_non_const_iterator(res, fn)); } } res.resize(std::size(source)); } return res; } template<alignment ALIGNMENT, internal::resizable_range R, class T = std::ranges::range_value_t<R>> auto align(R&& source, const internal::size_t size, const T& v = {}) noexcept(NO_EXCEPT) { if(std::ssize(source) >= size) return source; if(ALIGNMENT == alignment::left) { R left, right; left = source; right.resize(size - std::size(left), v); return R(ALL(lib::views::concat(left, right))); } if(ALIGNMENT == alignment::center) { R left, center, right; center = source; left.resize((size - std::size(center)) / 2, v); right.resize(size - std::size(center) - std::size(left), v); return R(ALL(lib::views::concat(left, center, right))); } if(ALIGNMENT == alignment::right) { R left, right; right = source; left.resize(size - std::size(right), v); return R(ALL(lib::views::concat(left, right))); } assert(false); } template<internal::resizable_range R, class T = std::ranges::range_value_t<R>> auto ljust(R&& source, const internal::size_t size, const T& v = {}) noexcept(NO_EXCEPT) { return align<alignment::left>(source, size, v); } template<internal::resizable_range R, class T = std::ranges::range_value_t<R>> auto cjust(R&& source, const internal::size_t size, const T& v = {}) noexcept(NO_EXCEPT) { return align<alignment::center>(source, size, v); } template<internal::resizable_range R, class T = std::ranges::range_value_t<R>> auto rjust(R&& source, const internal::size_t size, const T& v = {}) noexcept(NO_EXCEPT) { return align<alignment::right>(source, size, v); } }
/* [end]: iterable/operation.hpp*/
namespace lib { template<class T> inline constexpr T div_floor(const T& x, const T& d) noexcept(NO_EXCEPT) { if constexpr(std::is_integral_v<T>) { return x / d - (x % d && ((x < 0) ^ (d < 0))); } else { return std::floor(x / d); } } template<class T> inline constexpr T div_ceil(const T& x, const T& d) noexcept(NO_EXCEPT) { if constexpr(std::is_integral_v<T>) { return div_floor(x + d - 1, d); } else { return std::ceil(x / d); } } template<class T> inline constexpr T div_round(const T& x, const T& d) noexcept(NO_EXCEPT) { if constexpr(std::is_integral_v<T>) { return div_round<ld>(x, d); } else { return std::round(x / d); } } template<class T> inline constexpr std::make_signed_t<T> to_signed(const T& x) noexcept(NO_EXCEPT) { return static_cast<std::make_signed_t<T>>(x); } template<class T> inline constexpr std::make_unsigned_t<T> to_unsigned(const T& x) noexcept(NO_EXCEPT) { return static_cast<std::make_unsigned_t<T>>(x); } template<class T, class R = T> inline constexpr R nPr(const T& n, const T& r) noexcept(NO_EXCEPT) { assert(0 <= n); assert(0 <= r); if(n < r) return 0; R res = 1; REP(i, r) res *= n-i; return res; } template<class T, class R = T> inline constexpr R nCr(const T& n, T r) noexcept(NO_EXCEPT) { assert(0 <= n); assert(0 <= r); if(n == r) return 1; if(n < r) return 0; if(n < r*2) r = n-r; R p = 1, q = 1; REP(i, r) p *= n-i, q *= r-i; return p / q; } template<class T, class U, std::invocable<T, T> F = std::multiplies<T>> constexpr T pow(T x, U n, F mul = {}, T one = T{1}, T zero = T{0}) noexcept(NO_EXCEPT) { if(n == 0) return one; if(n == 1 || x == zero || x == one) return x; T res = one; while(true) { if(n & 1) res = mul(res, x); x = mul(x, x); if(n == 0) return res; n >>= 1; } assert(false); } using atcoder::pow_mod; using atcoder::inv_mod; using atcoder::crt; template<class T> inline constexpr T sign(const T& x) noexcept(NO_EXCEPT) { if(x == 0) return 0; return (x > 0) ? 1 : -1; } template<class T, T FROM_MIN, T FROM_MAX, T TO_MIN, T TO_MAX> inline constexpr T mapping(const T x) { return (x - FROM_MIN) * (TO_MAX - TO_MIN) / (FROM_MAX - FROM_MIN) + TO_MIN; } template<class T> inline constexpr T mapping(const T x, const T from_min, const T from_max, const T to_min, const T to_max) { return (x - from_min) * (to_max - to_min) / (from_max - from_min) + to_min; } template<class... Args> inline constexpr std::common_type_t<Args...> min(const Args&... args) noexcept(NO_EXCEPT) { return std::min({ static_cast<std::common_type_t<Args...>>(args)... }); } template<class... Args> inline constexpr std::common_type_t<Args...> max(const Args&... args) noexcept(NO_EXCEPT) { return std::max({ static_cast<std::common_type_t<Args...>>(args)... }); } template<class T> inline constexpr T gcd(const std::initializer_list<T> args) noexcept(NO_EXCEPT) { return gcd(ALL(args)); } template<class... Args> inline constexpr std::common_type_t<Args...> gcd(const Args&... args) noexcept(NO_EXCEPT) { return gcd({ static_cast<std::common_type_t<Args...>>(args)... }); } template<class T> inline constexpr T lcm(const std::initializer_list<T> args) noexcept(NO_EXCEPT) { return lcm(ALL(args)); } template<class... Args> inline constexpr std::common_type_t<Args...> lcm(const Args&... args) noexcept(NO_EXCEPT) { return lcm({ static_cast<std::common_type_t<Args...>>(args)... }); } template<std::integral T0, std::integral T1> inline constexpr std::optional<std::common_type_t<T0, T1>> add_overflow(const T0& a, const T1& b) noexcept(NO_EXCEPT) { std::common_type_t<T0, T1> res; if(__builtin_add_overflow(a, b, &res)) return {}; return res; } template<std::integral T0, std::integral T1> inline constexpr std::optional<std::common_type_t<T0, T1>> sub_overflow(const T0& a, const T1& b) noexcept(NO_EXCEPT) { std::common_type_t<T0, T1> res; if(__builtin_sub_overflow(a, b, &res)) return {}; return res; } template<std::integral T0, std::integral T1> inline constexpr std::optional<std::common_type_t<T0, T1>> mul_overflow(const T0& a, const T1& b) noexcept(NO_EXCEPT) { std::common_type_t<T0, T1> res; if(__builtin_mul_overflow(a, b, &res)) return {}; return res; } template<std::integral T0, std::integral T1, std::integral Limit> inline auto add_clamp(const T0 x, const T1 y, const Limit inf, const Limit sup) noexcept(NO_EXCEPT) { using Common = std::common_type_t<T0, T1, Limit>; const auto res = add_overflow<Common>(x, y); if(!res) { if(x < 0 && y < 0) return inf; if(x > 0 && y > 0) return sup; assert(false); } return std::clamp<Common>(*res, inf, sup); } template<std::integral T0, std::integral T1, std::integral Limit> inline auto sub_clamp(const T0 x, const T1 y, const Limit inf, const Limit sup) noexcept(NO_EXCEPT) { using Common = std::common_type_t<T0, T1, Limit>; const auto res = sub_overflow<Common>(x, y); if(!res) { if(x < 0 && y > 0) return inf; if(x > 0 && y < 0) return sup; assert(false); } return std::clamp<Common>(*res, inf, sup); } template<std::integral T0, std::integral T1, std::integral Limit> inline auto mul_clamp(const T0 x, const T1 y, const Limit inf, const Limit sup) noexcept(NO_EXCEPT) { using Common = std::common_type_t<T0, T1, Limit>; const auto res = mul_overflow<Common>(x, y); if(!res) { if((x > 0) xor (y > 0)) return inf; else return sup; assert(false); } return std::clamp<Common>(*res, inf, sup); } template<class T> inline constexpr T sqrt_floor(const T x) noexcept(NO_EXCEPT) { return static_cast<T>(std::sqrt(static_cast<long double>(x))); } template<class T> inline constexpr T sqrt_ceil(const T x) noexcept(NO_EXCEPT) { T res = sqrt_floor(x); if constexpr(std::is_floating_point_v<T>) { while(res * res < x) res += 1; } else { while(mul_overflow(res, res).value_or(std::numeric_limits<T>::max()) < x) ++res; } return res; } template<class T> inline constexpr T kth_root_floor(T x, const i64 k) noexcept(NO_EXCEPT) { assert(x >= 0), assert(k > 0); if(x <= 1 or k == 1) return x; constexpr int DIGITS = std::numeric_limits<T>::digits; if(k >= DIGITS) return T{1}; if(k == 2) return sqrt_floor(x); constexpr T MAX = std::numeric_limits<T>::max(); if(x == MAX) --x; auto pow = [&](T t, i64 p) { if(p == 0) return T{1}; T res = 1; while(p) { if(p & 1) { T _res; if(__builtin_mul_overflow(res, t, &_res)) res = MAX; else res = _res; } T _x; if(__builtin_mul_overflow(t, t, &_x)) t = MAX; else t = _x; p >>= 1; } return res; }; T res = std::pow(x, std::nextafter(1 / static_cast<double>(k), 0)); while(pow(res + 1, k) <= x) ++res; return res; } }
/* [end]: numeric/arithmetic.hpp*/
namespace lib { namespace internal { template<class T> constexpr T plus(const T a, const T b) noexcept(NO_EXCEPT) { return std::plus<T>{}(a, b); } template<class T> constexpr T minus(const T a, const T b) noexcept(NO_EXCEPT) { return std::minus<T>{}(a, b); } template<class T> constexpr T bit_xor(const T a, const T b) noexcept(NO_EXCEPT) { return a xor b; } } template<class T, class U> inline auto to_optional_if_equal(const T& v, const U& ill) noexcept(NO_EXCEPT) -> std::optional<T> { return v == ill ? std::optional<T>{} : std::optional<T>(v); } template<class T, class U> inline auto to_optional_if_over(const T& v, const U& ill) noexcept(NO_EXCEPT) -> std::optional<T> { return v > ill ? std::optional<T>{} : std::optional<T>(v); } template<class T, class U> inline auto to_optional_if_or_over(const T& v, const U& ill) noexcept(NO_EXCEPT) -> std::optional<T> { return v >= ill ? std::optional<T>{} : std::optional<T>(v); } template<class T, class U> inline auto to_optional_if_under(const T& v, const U& ill) noexcept(NO_EXCEPT) -> std::optional<T> { return v < ill ? std::optional<T>{} : std::optional<T>(v); } template<class T, class U> inline auto to_optional_if_or_under(const T& v, const U& ill) noexcept(NO_EXCEPT) -> std::optional<T> { return v <= ill ? std::optional<T>{} : std::optional<T>(v); } template<class T, class F> inline auto to_optional_if(const T& v, F&& f) noexcept(NO_EXCEPT) -> decltype(f(v), std::optional<T>{}){ return f(v) ? std::optional<T>{} : std::optional<T>(v); } template<class T, class U> inline auto mod(const T& x, const U& r) noexcept(NO_EXCEPT) { return (x%r+r)%r; } template<class T, class U> inline bool chmin(T &a, const U& b) noexcept(NO_EXCEPT) { return (a>b ? a=b, true : false); } template<class T, class U> inline bool chmax(T &a, const U& b) noexcept(NO_EXCEPT) { return (a<b ? a=b, true : false); } template<class T, class... Ts> inline bool chmin(T &a, Ts... b) noexcept(NO_EXCEPT) { return chmin(a, min(b...)); } template<class T, class... Ts> inline bool chmax(T &a, Ts... b) noexcept(NO_EXCEPT) { return chmax(a, max(b...)); } template<class... Ts> inline constexpr std::common_type_t<Ts...> tuple_sum(const std::tuple<Ts...>& tuple, const std::common_type_t<Ts...>& base = {}) noexcept(NO_EXCEPT) { std::common_type_t<Ts...> res = base; tuple_for_each(tuple, [&](const auto& v) constexpr { res += v; }); return res; } template<class... Ts> inline constexpr std::common_type_t<Ts...> min_element(const std::tuple<Ts...>& tuple) noexcept(NO_EXCEPT) { return std::apply([&](auto&&... v) constexpr { return min(v...); }, tuple); } template<class... Ts> inline constexpr std::common_type_t<Ts...> max_element(const std::tuple<Ts...>& tuple) noexcept(NO_EXCEPT) {; return std::apply([&](auto&&... v) constexpr { return max(v...); }, tuple); } template<interval_notation INTERVAL, class T0, class T1, class T2> inline constexpr bool in_range(const T0& x, const T1& l, const T2& r) noexcept(NO_EXCEPT) { if constexpr(INTERVAL == interval_notation::right_open) return l <= x and x < r; else if constexpr(INTERVAL == interval_notation::left_open) return l < x and x <= r; else if constexpr(INTERVAL == interval_notation::open) return l < x and x < r; return l <= x and x <= r; } template<class F, class Tuple> constexpr void tuple_for_each(F&& f, Tuple&& tuple) { std::apply( [&]<class... Ts>(Ts&&... elems) { (std::invoke(f, std::forward<Ts>(elems)), ...); }, std::forward<Tuple>(tuple) ); } template<class F, class Tuple> constexpr auto tuple_transform(F&& f, Tuple&& tuple) { return std::apply( [&]<class...Ts>(Ts&&... elems) { return internal::tuple_or_pair_t<std::invoke_result_t<F&,Ts>...>( std::invoke(f, std::forward<Ts>(elems))... ); }, std::forward<Tuple>(tuple) ); } }
/* [end]: utility/functional.hpp*/
namespace lib { template<std::ranges::input_range View> requires std::ranges::view<View> struct cyclic_view : std::ranges::view_interface<cyclic_view<View>> { private: View _base; template<bool Const> using Base = internal::maybe_const_t<Const, View>; template<bool Const> struct iterator_tag {}; template<bool Const> requires std::ranges::forward_range<Base<Const>> struct iterator_tag<Const> { private: inline static constexpr auto _iterator_category() noexcept { using category = typename std::iterator_traits<std::ranges::iterator_t<Base<Const>>>::iterator_category; if constexpr(std::derived_from<category, std::random_access_iterator_tag>) return std::random_access_iterator_tag{}; else return category{}; } public: using iterator_category = decltype(_iterator_category()); }; public: template<bool> class iterator; constexpr explicit cyclic_view(View base) noexcept(NO_EXCEPT) : _base(std::move(base)) {} inline constexpr View base() const & noexcept(NO_EXCEPT) requires std::copy_constructible<View> { return this->_base; } inline constexpr View base() && noexcept(NO_EXCEPT) { return std::move(this->_base); } inline constexpr auto begin() noexcept(NO_EXCEPT) requires(!internal::simple_view<View>) { return iterator<false>(this, std::ranges::begin(this->_base)); } inline constexpr auto begin() const noexcept(NO_EXCEPT) requires std::ranges::range<const View> { return iterator<true>(this, std::ranges::begin(this->_base)); } inline constexpr auto end() noexcept(NO_EXCEPT) requires(!internal::simple_view<View>) { return std::unreachable_sentinel; } inline constexpr auto end() const noexcept(NO_EXCEPT) requires std::ranges::range<const View> { return std::unreachable_sentinel; } }; template<class Range> cyclic_view(Range &&) -> cyclic_view<std::views::all_t<Range>>; template<std::ranges::input_range View> requires std::ranges::view<View> template<bool Const> struct cyclic_view<View>::iterator : iterator_tag<Const> { private: using Parent = internal::maybe_const_t<Const, cyclic_view>; using Base = cyclic_view::Base<Const>; std::ranges::iterator_t<Base> _current = std::ranges::iterator_t<Base>(); std::ranges::iterator_t<Base> _begin = std::ranges::iterator_t<Base>(); std::ranges::sentinel_t<Base> _end = std::ranges::sentinel_t<Base>(); constexpr iterator(Parent *const parent, const std::ranges::iterator_t<Base> current) noexcept(NO_EXCEPT) : _current(std::move(current)), _begin(std::ranges::begin(parent->_base)), _end(std::ranges::end(parent->_base)) {} friend cyclic_view; public: using difference_type = std::ranges::range_difference_t<Base>; using value_type = std::ranges::range_value_t<Base>; using iterator_concept = typename internal::iterator_concept<Base>; iterator() noexcept(NO_EXCEPT) requires std::default_initializable<std::ranges::iterator_t<Base>> = default; constexpr iterator(iterator<!Const> itr) noexcept(NO_EXCEPT) requires Const && std::convertible_to<std::ranges::iterator_t<View>, std::ranges::iterator_t<Base>> && std::convertible_to<std::ranges::sentinel_t<View>, std::ranges::sentinel_t<Base>> : _current(std::move(itr._current)), _begin(std::move(itr._begin)), _end(std::move(itr._end)) {} inline constexpr std::ranges::iterator_t<Base> base() && noexcept(NO_EXCEPT) { return std::move(this->_current); } inline constexpr const std::ranges::iterator_t<Base> &base() const & noexcept { return this->_current; } inline constexpr decltype(auto) operator*() const noexcept(NO_EXCEPT) { return *this->_current; } inline constexpr iterator& operator++() noexcept(NO_EXCEPT) { assert(this->_current != _end); ++this->_current; if(this->_current == this->_end) this->_current = this->_begin; return *this; } inline constexpr void operator++(int) noexcept(NO_EXCEPT) { ++*this; } inline constexpr iterator operator++(int) noexcept(NO_EXCEPT) requires std::ranges::forward_range<Base> { const auto res = *this; ++*this; return res; } inline constexpr iterator& operator--() noexcept(NO_EXCEPT) requires std::ranges::bidirectional_range<Base> { if(this->_current == this->_begin) this->_current = std::prev(this->_end); else --this->_current; return *this; } inline constexpr iterator operator--(int) noexcept(NO_EXCEPT) requires std::ranges::bidirectional_range<Base> { const auto res = *this; --*this; return res; } inline constexpr iterator& operator+=(const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { if(diff > 0) { auto missing = std::ranges::advance(this->_current, diff, this->_end); if constexpr(std::ranges::sized_range<Base>) missing %= std::ranges::distance(this->_begin, this->_end); while(this->_current == this->_end) { this->_current = this->_begin; missing = std::ranges::advance(this->_current, missing, this->_end); } } if(diff < 0) { auto missing = std::ranges::advance(this->_current, diff, this->_begin); if constexpr(std::ranges::sized_range<Base>) missing %= std::ranges::distance(this->_begin, this->_end); while(missing > 0) { this->_current = this->_end; missing = std::ranges::advance(this->_current, -missing, this->_begin); } } return *this; } inline constexpr iterator& operator-=(const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return *this += -diff; } inline constexpr decltype(auto) operator[](const difference_type diff) const noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return *(*this + diff); } friend inline constexpr bool operator==(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::equality_comparable<std::ranges::iterator_t<Base>> { return lhs._current == rhs._current; } friend inline constexpr bool operator<(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return lhs._current < rhs._current; } friend inline constexpr bool operator>(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return rhs._current < lhs._current; } friend inline constexpr bool operator<=(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return !(rhs._current < lhs._current); } friend inline constexpr bool operator>=(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return !(lhs._current < rhs._current); } friend inline constexpr auto operator<=>(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> && std::three_way_comparable<std::ranges::iterator_t<Base>> { return lhs._current <=> rhs._current; } friend inline constexpr iterator operator+(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { auto res = itr; res += diff; return res; } friend inline constexpr iterator operator+(const difference_type diff, const iterator& itr) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return itr + diff; } friend inline constexpr iterator operator-(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { auto res = itr; res -= diff; return res; } friend inline constexpr const difference_type operator-(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::sized_sentinel_for<std::ranges::iterator_t<Base>, std::ranges::iterator_t<Base>> { return lhs._current - rhs._current; } friend inline constexpr std::ranges::range_rvalue_reference_t<Base> iter_move(const iterator& itr) noexcept(NO_EXCEPT) { return std::ranges::iter_move(itr._current); } friend inline constexpr void iter_swap(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::indirectly_swappable<std::ranges::iterator_t<Base>> { std::ranges::iter_swap(lhs._current, rhs._current); } }; namespace views { namespace internal { template<class Range> concept can_cyclic_view = requires { cyclic_view(std::declval<Range>()); }; } struct Cyclic : adapter::range_adapter<Cyclic> { template<std::ranges::viewable_range Range> requires internal::can_cyclic_view<Range> inline constexpr auto operator() [[nodiscard]] (Range &&res) const { return cyclic_view(std::forward<Range>(res)); } using adapter::range_adapter<Cyclic>::operator(); inline static constexpr int arity = 1; inline static constexpr bool has_simple_call_op = true; }; inline constexpr Cyclic cyclic; } } namespace std::ranges { template<class View> inline constexpr bool enable_borrowed_range<lib::cyclic_view<View>> = enable_borrowed_range<View>; }
/* [end]: view/cyclic.hpp*/
/* [begin]: view/zip.hpp */
namespace lib { template<std::ranges::input_range... Views> requires(std::ranges::view<Views> && ...) && (sizeof...(Views) > 0) struct zip_view : std::ranges::view_interface<zip_view<Views...>> { private: std::tuple<Views...> _views; public: template<bool> struct iterator; template<bool> struct sentinel; zip_view() = default; constexpr explicit zip_view(Views... views) noexcept(NO_EXCEPT) : _views(std::move(views)...) {} constexpr auto begin() noexcept(NO_EXCEPT) requires(!(internal::simple_view<Views> && ...)) { return iterator<false>(tuple_transform(std::ranges::begin, this->_views)); } constexpr auto begin() const noexcept(NO_EXCEPT) requires(std::ranges::range<const Views> && ...) { return iterator<true>(tuple_transform(std::ranges::begin, this->_views)); } constexpr auto end() noexcept(NO_EXCEPT) requires(!(internal::simple_view<Views> && ...)) { if constexpr(!internal::zip_is_common<Views...>) return sentinel<false>(tuple_transform(std::ranges::end, this->_views)); else if constexpr((std::ranges::random_access_range<Views> && ...)) return begin() + std::iter_difference_t<iterator<false>>(this->size()); else return iterator<false>(tuple_transform(std::ranges::end, this->_views)); } constexpr auto end() const noexcept(NO_EXCEPT) requires(std::ranges::range<const Views> && ...) { if constexpr(!internal::zip_is_common<const Views...>) return sentinel<true>(tuple_transform(std::ranges::end, this->_views)); else if constexpr((std::ranges::random_access_range<const Views> && ...)) return this->begin() + std::iter_difference_t<iterator<true>>(this->size()); else return iterator<true>(tuple_transform(std::ranges::end, _views)); } constexpr auto size() noexcept(NO_EXCEPT) requires(std::ranges::sized_range<Views> && ...) { return std::apply( [](auto... sizes) { using size_type = std::make_unsigned_t<std::common_type_t<decltype(sizes)...>>; return lib::min(size_type(sizes)...); }, tuple_transform(std::ranges::size, _views) ); } constexpr auto size() const noexcept(NO_EXCEPT) requires(std::ranges::sized_range<const Views> && ...) { return std::apply( [](auto... sizes) { using size_type = std::make_unsigned_t<std::common_type_t<decltype(sizes)...>>; return lib::min(size_type(sizes)...); }, tuple_transform(std::ranges::size, _views) ); } }; template<class... Ranges> zip_view(Ranges &&...) -> zip_view<std::views::all_t<Ranges>...>; namespace internal { template<class iterator> constexpr const typename iterator::iterator_collection& get_current(const iterator& itr) noexcept(NO_EXCEPT); } template<std::ranges::input_range... Views> requires(std::ranges::view<Views> && ...) && (sizeof...(Views) > 0) template<bool Const> struct zip_view<Views...>::iterator : internal::zip_view_iterator_category<Const, Views...> { using iterator_collection = internal::tuple_or_pair_t< std::ranges::iterator_t<internal::maybe_const_t<Const, Views>>... >; private: friend struct zip_view; template<bool> friend struct zip_view::sentinel; iterator_collection _current; constexpr explicit iterator(decltype(_current) __current) : _current(std::move(__current)) {} public: using iterator_concept = internal::most_primitive_iterator_concept<Const, Views...>; using value_type = internal::tuple_or_pair_t<std::ranges::range_value_t<internal::maybe_const_t<Const, Views>>...>; using difference_type = std::common_type_t<std::ranges::range_difference_t<internal::maybe_const_t<Const, Views>>...>; iterator() = default; constexpr iterator(iterator<!Const> itr) noexcept(NO_EXCEPT) requires Const && ( std::convertible_to< std::ranges::iterator_t<Views>, std::ranges::iterator_t<internal::maybe_const_t<Const, Views>> > && ... ) : _current(std::move(itr._current)) {} constexpr auto operator*() const noexcept(NO_EXCEPT) { const auto f = [](auto &itr) -> decltype(auto) { return *itr; }; return tuple_transform(f, this->_current); } constexpr iterator& operator++() noexcept(NO_EXCEPT) { tuple_for_each([](auto &itr) { ++itr; }, this->_current); return *this; } constexpr void operator++(int) noexcept(NO_EXCEPT) { ++*this; } constexpr iterator operator++(int) noexcept(NO_EXCEPT) requires internal::all_forward<Const, Views...> { const auto res = *this; ++*this; return res; } constexpr iterator& operator--() noexcept(NO_EXCEPT) requires internal::all_bidirectional<Const, Views...> { tuple_for_each([](auto &itr) { --itr; }, this->_current); return *this; } constexpr iterator operator--(int) noexcept(NO_EXCEPT) requires internal::all_bidirectional<Const, Views...> { const auto res = *this; --*this; return res; } constexpr iterator& operator+=(const difference_type diff) noexcept(NO_EXCEPT) requires internal::all_random_access<Const, Views...> { const auto f = [&]<class Itr>(Itr& itr) constexpr noexcept(NO_EXCEPT) { itr += std::iter_difference_t<Itr>(diff); }; tuple_for_each(f, this->_current); return *this; } constexpr iterator& operator-=(const difference_type diff) noexcept(NO_EXCEPT) requires internal::all_random_access<Const, Views...> { const auto f = [&]<class Itr>(Itr& itr) constexpr noexcept(NO_EXCEPT) { itr -= std::iter_difference_t<Itr>(diff); }; tuple_for_each(f, this->_current); return *this; } constexpr auto operator[](const difference_type diff) const noexcept(NO_EXCEPT) requires internal::all_random_access<Const, Views...> { const auto f = [&]<class Itr>(Itr& itr) constexpr noexcept(NO_EXCEPT) -> decltype(auto) { return itr[std::iter_difference_t<Itr>(diff)]; }; return tuple_transform(f, _current); } friend constexpr bool operator==(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires ( std::equality_comparable< std::ranges::iterator_t<internal::maybe_const_t<Const, Views>> > && ... ) { if constexpr(internal::all_bidirectional<Const, Views...>) return lhs._current == rhs._current; else return [&]<std::size_t... Is>(std::index_sequence<Is...>) constexpr noexcept(NO_EXCEPT) { return ( (std::get<Is>(lhs._current) == std::get<Is>(rhs._current)) || ... ); }(std::make_index_sequence<sizeof...(Views)>{}); } friend constexpr auto operator<=>(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires internal::all_random_access<Const, Views...> { return lhs._current <=> rhs._current; } friend constexpr iterator operator+(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires internal::all_random_access<Const, Views...> { auto res = itr; res += diff; return res; } friend constexpr iterator operator+(const difference_type diff, const iterator& itr) noexcept(NO_EXCEPT) requires internal::all_random_access<Const, Views...> { auto res = itr; res += diff; return res; } friend constexpr iterator operator-(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires internal::all_random_access<Const, Views...> { auto res = itr; res -= diff; return res; } friend constexpr difference_type operator-(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires ( std::sized_sentinel_for< std::ranges::iterator_t<internal::maybe_const_t<Const, Views>>, std::ranges::iterator_t<internal::maybe_const_t<Const, Views>> > && ... ) { return [&]<std::size_t... Is>(std::index_sequence<Is...>) constexpr noexcept(NO_EXCEPT) { return std::ranges::min( { difference_type(std::get<Is>(lhs._current) - std::get<Is>(rhs._current)) ... }, std::ranges::less{}, [](const difference_type diff) constexpr noexcept(NO_EXCEPT) { return to_unsigned(diff < 0 ? -diff : diff); } ); }(std::make_index_sequence<sizeof...(Views)>{}); } friend constexpr auto iter_move(const iterator& itr) noexcept(NO_EXCEPT) { return tuple_transform(std::ranges::iter_move, itr._current); } friend constexpr void iter_swap(const iterator& lhs, const iterator& res) noexcept(NO_EXCEPT) requires ( std::indirectly_swappable< std::ranges::iterator_t<internal::maybe_const_t<Const, Views>> > && ... ) { [&]<std::size_t... Is>(std::index_sequence<Is...>) constexpr noexcept(NO_EXCEPT) { ( std::ranges::iter_swap(std::get<Is>(lhs._current), std::get<Is>(res._current)), ... ); }(std::make_index_sequence<sizeof...(Views)>{}); } template<class Itr> friend constexpr const typename Itr::iterator_collection& internal::get_current(const Itr&) noexcept(NO_EXCEPT); }; template<class iterator> constexpr const typename iterator::iterator_collection& internal::get_current(const iterator& itr) noexcept(NO_EXCEPT) { return itr._current; }; template<std::ranges::input_range... Views> requires(std::ranges::view<Views> && ...) && (sizeof...(Views) > 0) template<bool Const> struct zip_view<Views...>::sentinel { friend struct zip_view; template<bool> friend struct zip_view::iterator; using sentinel_collection = internal::tuple_or_pair_t< std::ranges::sentinel_t<internal::maybe_const_t<Const, Views>>... >; sentinel_collection _end; constexpr explicit sentinel(decltype(_end) __end) noexcept(NO_EXCEPT) : _end(__end) {} public: sentinel() = default; constexpr sentinel(sentinel<!Const> itr) noexcept(NO_EXCEPT) requires Const && ( std::convertible_to< std::ranges::sentinel_t<Views>, std::ranges::sentinel_t<internal::maybe_const_t<Const, Views>> > && ... ) : _end(std::move(itr._end)) {} template<bool Const_> requires ( std::sentinel_for< std::ranges::sentinel_t<internal::maybe_const_t<Const, Views>>, std::ranges::iterator_t<internal::maybe_const_t<Const_, Views>> > && ... ) friend constexpr bool operator==(const iterator<Const_>& lhs, const sentinel& rhs) noexcept(NO_EXCEPT) { return [&]<std::size_t... Is>(std::index_sequence<Is...>) constexpr noexcept(NO_EXCEPT) { return ( (std::get<Is>(internal::get_current(lhs)) == std::get<Is>(rhs._end)) || ...); }(std::make_index_sequence<sizeof...(Views)>{}); } template<bool Const_> requires ( std::sized_sentinel_for< std::ranges::sentinel_t<internal::maybe_const_t<Const, Views>>, std::ranges::iterator_t<internal::maybe_const_t<Const_, Views>> > && ... ) friend constexpr auto operator-(const iterator<Const_>& lhs, const sentinel& rhs) noexcept(NO_EXCEPT) { using return_type = std::common_type_t<std::ranges::range_difference_t<internal::maybe_const_t<Const_, Views>>...>; return [&]<std::size_t... Is>(std::index_sequence<Is...>) constexpr noexcept(NO_EXCEPT) { return std::ranges::min( { return_type(std::get<Is>(internal::get_current(lhs)) - std::get<Is>(rhs._end))... }, std::ranges::less{}, [](const return_type diff) { return to_unsigned(diff < 0 ? -diff : diff); } ); }(std::make_index_sequence<sizeof...(Views)>{}); } template<bool Const_> requires ( std::sized_sentinel_for< std::ranges::sentinel_t<internal::maybe_const_t<Const, Views>>, std::ranges::iterator_t<internal::maybe_const_t<Const_, Views>> > && ... ) friend constexpr auto operator-(const sentinel &lhs, const iterator<Const_>& rhs) noexcept(NO_EXCEPT) { return -(rhs - lhs); } }; namespace views { namespace internal { template<class... Ts> concept can_zip_view = requires { zip_view<std::views::all_t<Ts>...>(std::declval<Ts>()...); }; } struct Zip { template<class... Ts> requires(sizeof...(Ts) == 0 || internal::can_zip_view<Ts...>) constexpr auto operator() [[nodiscard]] (Ts&&... vs) const { if constexpr(sizeof...(Ts) == 0) return std::views::empty<std::tuple<>>; else return zip_view<std::views::all_t<Ts>...>(std::forward<Ts>(vs)...); } }; inline constexpr Zip zip; } } namespace std::ranges { template<class... Views> inline constexpr bool enable_borrowed_range<lib::zip_view<Views...>> = (enable_borrowed_range<Views> && ...); }
/* [end]: view/zip.hpp*/
/* [begin]: view/stride.hpp */
namespace lib { template<std::ranges::input_range View> requires std::ranges::view<View> struct stride_view : std::ranges::view_interface<stride_view<View>> { private: View _base; std::ranges::range_difference_t<View> _stride; template<bool Const> using Base = internal::maybe_const_t<Const, View>; template<bool Const> struct iterator_tag {}; template<bool Const> requires std::ranges::forward_range<Base<Const>> struct iterator_tag<Const> { private: inline static constexpr auto _iterator_category() noexcept { using category = typename std::iterator_traits<std::ranges::iterator_t<Base<Const>>>::iterator_category; if constexpr(std::derived_from<category, std::random_access_iterator_tag>) return std::random_access_iterator_tag{}; else return category{}; } public: using iterator_category = decltype(_iterator_category()); }; public: template<bool> class iterator; constexpr explicit stride_view(View base, const std::ranges::range_difference_t<View> stride) noexcept(NO_EXCEPT) : _base(std::move(base)), _stride(stride) { assert(stride > 0); } inline constexpr View base() const & noexcept(NO_EXCEPT) requires std::copy_constructible<View> { return this->_base; } inline constexpr View base() && noexcept(NO_EXCEPT) { return std::move(this->_base); } inline constexpr std::ranges::range_difference_t<View> stride() const noexcept { return this->_stride; } inline constexpr auto begin() noexcept(NO_EXCEPT) requires(!internal::simple_view<View>) { return iterator<false>(this, std::ranges::begin(this->_base)); } inline constexpr auto begin() const noexcept(NO_EXCEPT) requires std::ranges::range<const View> { return iterator<true>(this, std::ranges::begin(this->_base)); } inline constexpr auto end() noexcept(NO_EXCEPT) requires(!internal::simple_view<View>) { if constexpr(std::ranges::common_range<View> && std::ranges::sized_range<View> && std::ranges::forward_range<View>) { const auto missing = (this->_stride - std::ranges::distance(this->_base) % this->_stride) % this->_stride; return iterator<false>(this, std::ranges::end(this->_base), missing); } else if constexpr(std::ranges::common_range<View> && !std::ranges::bidirectional_range<View>) return iterator<false>(this, std::ranges::end(this->_base)); else return std::default_sentinel; } inline constexpr auto end() const noexcept(NO_EXCEPT) requires std::ranges::range<const View> { if constexpr(std::ranges::common_range<const View> && std::ranges::sized_range<const View> && std::ranges::forward_range<const View>) { const auto missing = (this->_stride - std::ranges::distance(this->_base) % this->_stride) % this->_stride; return iterator<true>(this, std::ranges::end(this->_base), missing); } else if constexpr(std::ranges::common_range<const View> && !std::ranges::bidirectional_range<const View>) return iterator<true>(this, std::ranges::end(this->_base)); else return std::default_sentinel; } inline constexpr auto size() noexcept(NO_EXCEPT) requires std::ranges::sized_range<View> { return to_unsigned(div_ceil(std::ranges::distance(this->_base), this->_stride)); } inline constexpr auto size() const noexcept(NO_EXCEPT) requires std::ranges::sized_range<const View> { return to_unsigned(div_ceil(std::ranges::distance(this->_base), this->_stride)); } }; template<class Range> stride_view(Range &&, std::ranges::range_difference_t<Range>) -> stride_view<std::views::all_t<Range>>; template<std::ranges::input_range View> requires std::ranges::view<View> template<bool Const> struct stride_view<View>::iterator : iterator_tag<Const> { private: using Parent = internal::maybe_const_t<Const, stride_view>; using Base = stride_view::Base<Const>; std::ranges::iterator_t<Base> _current = std::ranges::iterator_t<Base>(); std::ranges::sentinel_t<Base> _end = std::ranges::sentinel_t<Base>(); std::ranges::range_difference_t<Base> _stride = 0; std::ranges::range_difference_t<Base> _missing = 0; constexpr iterator(Parent *const parent, const std::ranges::iterator_t<Base> current, const std::ranges::range_difference_t<Base> missing = 0) noexcept(NO_EXCEPT) : _current(std::move(current)), _end(std::ranges::end(parent->_base)), _stride(parent->_stride), _missing(missing) {} friend stride_view; public: using difference_type = std::ranges::range_difference_t<Base>; using value_type = std::ranges::range_value_t<Base>; using iterator_concept = typename internal::iterator_concept<Base>; iterator() noexcept(NO_EXCEPT) requires std::default_initializable<std::ranges::iterator_t<Base>> = default; constexpr iterator(iterator<!Const> itr) noexcept(NO_EXCEPT) requires Const && std::convertible_to<std::ranges::iterator_t<View>, std::ranges::iterator_t<Base>> && std::convertible_to<std::ranges::sentinel_t<View>, std::ranges::sentinel_t<Base>> : _current(std::move(itr._current)), _end(std::move(itr._end)), _stride(itr._stride), _missing(itr._missing) {} inline constexpr std::ranges::iterator_t<Base> base() && noexcept(NO_EXCEPT) { return std::move(this->_current); } inline constexpr const std::ranges::iterator_t<Base>& base() const & noexcept { return this->_current; } inline constexpr decltype(auto) operator*() const noexcept(NO_EXCEPT) { return *this->_current; } inline constexpr iterator& operator++() noexcept(NO_EXCEPT) { assert(this->_current != _end); this->_missing = std::ranges::advance(this->_current, this->_stride, this->_end); return *this; } inline constexpr void operator++(int) noexcept(NO_EXCEPT) { ++*this; } inline constexpr iterator operator++(int) noexcept(NO_EXCEPT) requires std::ranges::forward_range<Base> { const auto res = *this; ++*this; return res; } inline constexpr iterator& operator--() noexcept(NO_EXCEPT) requires std::ranges::bidirectional_range<Base> { std::ranges::advance(this->_current, this->_missing - this->_stride); this->_missing = 0; return *this; } inline constexpr iterator operator--(int) noexcept(NO_EXCEPT) requires std::ranges::bidirectional_range<Base> { const auto res = *this; --*this; return res; } inline constexpr iterator& operator+=(const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { if(diff > 0) { assert(std::ranges::distance(this->_current, this->_end) > this->_stride * (diff - 1)); this->_missing = std::ranges::advance(this->_current, this->_stride * diff, this->_end); } if(diff < 0) { std::ranges::advance(this->_current, this->_stride * diff + this->_missing); this->_missing = 0; } return *this; } inline constexpr iterator& operator-=(const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return *this += -diff; } inline constexpr decltype(auto) operator[](const difference_type diff) const noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return *(*this + diff); } friend inline constexpr bool operator==(const iterator& lhs, std::default_sentinel_t) noexcept(NO_EXCEPT) { return lhs._current == lhs._end; } friend inline constexpr bool operator==(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::equality_comparable<std::ranges::iterator_t<Base>> { return lhs._current == rhs._current; } friend inline constexpr bool operator<(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return lhs._current < rhs._current; } friend inline constexpr bool operator>(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return rhs._current < lhs._current; } friend inline constexpr bool operator<=(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return !(rhs._current < lhs._current); } friend inline constexpr bool operator>=(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return !(lhs._current < rhs._current); } friend inline constexpr auto operator<=>(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> && std::three_way_comparable<std::ranges::iterator_t<Base>> { return lhs._current <=> rhs._current; } friend inline constexpr iterator operator+(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { auto res = itr; res += diff; return res; } friend inline constexpr iterator operator+(const difference_type diff, const iterator& itr) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { return itr + diff; } friend inline constexpr iterator operator-(const iterator& itr, const difference_type diff) noexcept(NO_EXCEPT) requires std::ranges::random_access_range<Base> { auto res = itr; res -= diff; return res; } friend inline constexpr const difference_type operator-(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::sized_sentinel_for<std::ranges::iterator_t<Base>, std::ranges::iterator_t<Base>> { const auto diff = lhs._current - rhs._current; if constexpr(std::ranges::forward_range<Base>) return (diff + lhs._missing - rhs._missing) / lhs._stride; else if(diff < 0) return -div_ceil(-diff, lhs._stride); else return div_ceil(diff, lhs._stride); } friend inline constexpr const difference_type operator-(std::default_sentinel_t, const iterator& rhs) noexcept(NO_EXCEPT) requires std::sized_sentinel_for<std::ranges::sentinel_t<Base>, std::ranges::iterator_t<Base>> { return div_ceil(rhs._end - rhs._current, rhs._stride); } friend inline constexpr const difference_type operator-(const iterator& lhs, std::default_sentinel_t rhs) noexcept(NO_EXCEPT) requires std::sized_sentinel_for<std::ranges::sentinel_t<Base>, std::ranges::iterator_t<Base>> { return -(rhs - lhs); } friend inline constexpr std::ranges::range_rvalue_reference_t<Base> iter_move(const iterator& itr) noexcept(NO_EXCEPT) { return std::ranges::iter_move(itr._current); } friend inline constexpr void iter_swap(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) requires std::indirectly_swappable<std::ranges::iterator_t<Base>> { std::ranges::iter_swap(lhs._current, rhs._current); } }; namespace views { namespace internal { template<class Range, class T> concept can_stride_view = requires { stride_view(std::declval<Range>(), std::declval<T>()); }; } struct Stride : adapter::range_adapter<Stride> { template<std::ranges::viewable_range Range, class T = std::ranges::range_difference_t<Range>> requires internal::can_stride_view<Range, T> inline constexpr auto operator() [[nodiscard]] (Range &&res, std::type_identity_t<T> diff) const { return stride_view(std::forward<Range>(res), diff); } using adapter::range_adapter<Stride>::operator(); inline static constexpr int arity = 2; inline static constexpr bool has_simple_call_op = true; }; inline constexpr Stride stride; } } namespace std::ranges { template<class View> inline constexpr bool enable_borrowed_range<lib::stride_view<View>> = enable_borrowed_range<View>; }
/* [end]: view/stride.hpp*/
/* [begin]: view/repeat.hpp */
/* [begin]: view/internal/box.hpp */
#include <memory>
namespace lib { namespace internal {
#if CPP23
template<class T> concept boxable = std::copy_constructible<T> && std::is_object_v<T>;
#else
template<class T> concept boxable = std::copy_constructible<T> && std::is_object_v<T>;
#endif
template<boxable T> struct box : std::optional<T> { using std::optional<T>::optional; constexpr box() noexcept(std::is_nothrow_default_constructible_v<T>) requires std::default_initializable<T> : std::optional<T> { std::in_place } {} box(const box&) = default; box(box&&) = default; using std::optional<T>::operator=; constexpr box &operator=(const box& other) noexcept( std::is_nothrow_copy_constructible_v<T>) requires(!std::copyable<T>) && std::copy_constructible<T> { if(this != std::addressof(other)) { if((bool)other) this->emplace(*other); else this->reset(); } return *this; } constexpr box& operator=(box&& other) noexcept(std::is_nothrow_move_constructible_v<T>) requires(!std::movable<T>) { if(this != std::addressof(other)) { if((bool)other) this->emplace(std::move(*other)); else this->reset(); } return *this; } }; template<class T> concept boxable_copyable = std::copy_constructible<T> && ( std::copyable<T> || (std::is_nothrow_move_constructible_v<T> && std::is_nothrow_copy_constructible_v<T>) ); template<class T> concept boxable_movable = (!std::copy_constructible<T>) && (std::movable<T> || std::is_nothrow_move_constructible_v<T>); template<boxable T> requires boxable_copyable<T> || boxable_movable<T> struct box<T> { private: [[no_unique_address]] T _value = T(); public: box() requires std::default_initializable<T> = default; constexpr explicit box(const T &__t) noexcept( std::is_nothrow_copy_constructible_v<T> ) requires std::copy_constructible<T> : _value(__t) {} constexpr explicit box(T &&__t) noexcept( std::is_nothrow_move_constructible_v<T> ) : _value(std::move(__t)) {} template<class... Args> requires std::constructible_from<T, Args...> constexpr explicit box(std::in_place_t, Args &&...args) noexcept( std::is_nothrow_constructible_v<T, Args...> ) : _value(std::forward<Args>(args)...) {} box(const box &) = default; box(box &&) = default; box &operator=(const box &) requires std::copyable<T> = default; box &operator=(box &&) requires std::movable<T> = default; constexpr box &operator=(const box &other) noexcept requires(!std::copyable<T>) && std::copy_constructible<T> { static_assert(std::is_nothrow_copy_constructible_v<T>); if(this != std::addressof(other)) { _value.~T(); std::construct_at(std::addressof(_value), *other); } return *this; } constexpr box &operator=(box &&other) noexcept requires(!std::movable<T>) { static_assert(std::is_nothrow_move_constructible_v<T>); if(this != std::addressof(other)) { _value.~T(); std::construct_at(std::addressof(_value), std::move(*other)); } return *this; } constexpr bool has_value() const noexcept { return true; }; constexpr T &operator*() noexcept { return _value; } constexpr const T &operator*() const noexcept { return _value; } constexpr T *operator->() noexcept { return std::addressof(_value); } constexpr const T *operator->() const noexcept { return std::addressof(_value); } }; } }
/* [end]: view/internal/box.hpp*/
namespace lib { template <std::move_constructible T, std::semiregular Bound = std::unreachable_sentinel_t> requires std::is_object_v<T> && std::same_as<T, std::remove_cv_t<T>> && ( std::is_integral_v<Bound> || std::same_as<Bound, std::unreachable_sentinel_t> ) struct repeat_view : public std::ranges::view_interface<repeat_view<T, Bound>> { private: internal::box<T> _value; [[no_unique_address]] Bound _bound = Bound(); struct Iterator; template <typename Range> friend constexpr auto take_of_repeat_view(Range&&, std::ranges::range_difference_t<Range>); template <typename Range> friend constexpr auto drop_of_repeat_view(Range &&, std::ranges::range_difference_t<Range>); public: repeat_view() requires std::default_initializable<T> = default; constexpr explicit repeat_view(const T &val, Bound bound = Bound()) requires std::copy_constructible<T> : _value(val), _bound(bound) { if constexpr(!std::same_as<Bound, std::unreachable_sentinel_t>) assert(bound >= 0); } constexpr explicit repeat_view(T &&val, Bound bound = Bound()) : _value(std::move(val)), _bound(bound) {} template <typename... Args, typename... BoundArgs> requires std::constructible_from<T, Args...> && std::constructible_from<Bound, BoundArgs...> constexpr explicit repeat_view( std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<BoundArgs...> bound_args = std::tuple<>{} ) : _value(std::make_from_tuple<T>(std::move(args))), _bound(std::make_from_tuple<Bound>(std::move(bound_args))) {} constexpr Iterator begin() const { return Iterator(std::addressof(*this->_value)); } constexpr Iterator end() const requires(!std::same_as<Bound, std::unreachable_sentinel_t>) { return Iterator(std::addressof(*this->_value), this->_bound); } constexpr std::unreachable_sentinel_t end() const noexcept { return std::unreachable_sentinel; } constexpr auto size() const requires(!std::same_as<Bound, std::unreachable_sentinel_t>) { return to_unsigned(this->_bound); } }; template <typename T, typename Bound> repeat_view(T, Bound) -> repeat_view<T, Bound>; template <std::move_constructible T, std::semiregular Bound> requires std::is_object_v<T> && std::same_as<T, std::remove_cv_t<T>> && (std::is_integral_v<Bound> || std::same_as<Bound, std::unreachable_sentinel_t>) struct repeat_view<T, Bound>::Iterator { private: using index_type = std::conditional_t<std::same_as<Bound, std::unreachable_sentinel_t>, std::ptrdiff_t, Bound>; const T* _value = nullptr; index_type _crrent = index_type(); constexpr explicit Iterator(const T* val, index_type bound = index_type()) : _value(val), _crrent(bound) { if constexpr(!std::same_as<Bound, std::unreachable_sentinel_t>) assert(bound >= 0); } friend repeat_view; public: using iterator_concept = std::random_access_iterator_tag; using iterator_category = std::random_access_iterator_tag; using value_type = T; using difference_type = std::conditional_t< std::is_integral_v<index_type>, index_type, internal::iota_diff_t<index_type> >; Iterator() = default; constexpr const T& operator*() const noexcept { return *this->_value; } constexpr Iterator& operator++() { ++this->_crrent; return *this; } constexpr Iterator operator++(int) { auto _tmp = *this; ++*this; return _tmp; } constexpr Iterator& operator--() { if constexpr(!std::same_as<Bound, std::unreachable_sentinel_t>) assert(this->_crrent > 0); --this->_crrent; return *this; } constexpr Iterator operator--(int) { auto _tmp = *this; --*this; return _tmp; } constexpr Iterator& operator+=(difference_type diff) { if constexpr(!std::same_as<Bound, std::unreachable_sentinel_t>) assert(this->_crrent + diff >= 0); this->_crrent += diff; return *this; } constexpr Iterator& operator-=(difference_type diff) { if constexpr(!std::same_as<Bound, std::unreachable_sentinel_t>) assert(this->_crrent - diff >= 0); this->_crrent -= diff; return *this; } constexpr const T& operator[](difference_type diff) const noexcept { return *(*this + diff); } friend constexpr bool operator==(const Iterator& lhs, const Iterator& rhs) { return lhs._crrent == rhs._crrent; } friend constexpr auto operator<=>(const Iterator& lhs, const Iterator& rhs) { return lhs._crrent <=> rhs._crrent; } friend constexpr Iterator operator+(Iterator itr, difference_type diff) { return itr += diff; } friend constexpr Iterator operator+(difference_type diff, Iterator itr) { return itr + diff; } friend constexpr Iterator operator-(Iterator itr, difference_type diff) { return itr -= diff; } friend constexpr difference_type operator-(const Iterator& lhs, const Iterator& rhs) { return ( static_cast<difference_type>(lhs._crrent) - static_cast<difference_type>(rhs._crrent) ); } }; namespace views { namespace internal { template<typename _Range> inline constexpr bool is_repeat_view = false; template <class T, class Bound> inline constexpr bool is_repeat_view<repeat_view<T, Bound>> = true; template <class T> concept can_repeat_view = requires { repeat_view(std::declval<T>()); }; template <class T, class Bound> concept can_bounded_repeat_view = requires { repeat_view(std::declval<T>(), std::declval<Bound>()); }; } struct Repeat { template <class T> requires internal::can_repeat_view<T> constexpr auto operator() [[nodiscard]] (T&& val) const { return repeat_view(std::forward<T>(val)); } template <class T, class Bound> requires internal::can_bounded_repeat_view<T, Bound> constexpr auto operator() [[nodiscard]] (T&& val, Bound bound) const { return repeat_view(std::forward<T>(val), bound); } }; inline constexpr Repeat repeat; namespace internal { template<class Range> constexpr auto take_of_repeat_view(Range&& range, std::ranges::range_difference_t<Range> diff) { using T = std::remove_cvref_t<Range>; static_assert(is_repeat_view<T>); if constexpr(std::ranges::sized_range<T>) return views::repeat(*range._value, std::min(std::ranges::distance(range), diff)); else return views::repeat(*range._value, diff); } template<class Range> constexpr auto drop_of_repeat_view(Range&& range, std::ranges::range_difference_t<Range> diff) { using T = std::remove_cvref_t<Range>; static_assert(is_repeat_view<T>); if constexpr(std::ranges::sized_range<T>) { auto size = std::ranges::distance(range); return views::repeat(*range._value, size - std::min(size, diff)); } else { return range; } } } } }
/* [end]: view/repeat.hpp*/
/* [end]: include/views.hpp*/
/* [begin]: include/geometries.hpp */
/* [begin]: geometry/basic.hpp */
/* [begin]: numeric/float.hpp */
namespace lib { template<class T> inline std::int32_t compare(const T x, const T y, const T tolerance) { if(x > y + tolerance) return 1; if(y > x + tolerance) return -1; return 0; } template<class T> inline std::int32_t compare(const T x, const T y = 0) { if constexpr(std::is_floating_point_v<T>) { return compare(x, y, max(1, x, y) * numeric_limits<T>::arithmetic_epsilon()); } else { if(x > y) return 1; if(x < y) return -1; return 0; } } }
/* [end]: numeric/float.hpp*/
/* [begin]: geometry/point.hpp */
#include <complex>
#include <cmath>
namespace lib { template <class T> struct point { using value_type = T; private: value_type _x, _y; public: constexpr point() : point(0, 0) {} constexpr point(const T& x, const T& y) noexcept(NO_EXCEPT) : _x(x), _y(y) {} template<class U> constexpr point(const point<U>& p) noexcept(NO_EXCEPT) : _x(p.x()), _y(p.y()) {}; template<class U> constexpr point(point<U>&& p) noexcept(NO_EXCEPT) : _x(p.x()), _y(p.y()) {}; template<class U> constexpr point& operator=(const point<U>& p) & noexcept(NO_EXCEPT) { this->_x = p._x, this->_y = p._y; return *this; }; template<class U> constexpr point& operator=(point<U>&& p) && noexcept(NO_EXCEPT) { this->_x = p._x, this->_y = p._y; return *this; }; inline constexpr value_type& x() noexcept(NO_EXCEPT) { return this->_x; } inline constexpr value_type& y() noexcept(NO_EXCEPT) { return this->_y; } inline constexpr const value_type& x() const noexcept(NO_EXCEPT) { return this->_x; } inline constexpr const value_type& y() const noexcept(NO_EXCEPT) { return this->_y; } inline constexpr value_type argument() const noexcept(NO_EXCEPT) { return static_cast<value_type>(std::arg(std::complex<value_type>(this->x(), this->y()))); } inline constexpr point& operator+=(const point& v) noexcept(NO_EXCEPT) { this->x() += v.x(), this->y() += v.y(); return *this; } inline constexpr point& operator-=(const point& v) noexcept(NO_EXCEPT) { this->x() -= v.x(), this->y() -= v.y(); return *this; } inline constexpr point& operator+=(const value_type& v) noexcept(NO_EXCEPT) { this->x() += v, this->y() += v; return *this; } inline constexpr point& operator-=(const value_type& v) noexcept(NO_EXCEPT) { this->x() -= v, this->y() -= v; return *this; } inline constexpr point& operator*=(const value_type& v) noexcept(NO_EXCEPT) { this->x() *= v, this->y() *= v; return *this; } inline constexpr point& operator/=(const value_type& v) noexcept(NO_EXCEPT) { this->x() /= v, this->y() /= v; return *this; } friend inline constexpr point operator+(const point& p) noexcept(NO_EXCEPT) { return { +p.x(), +p.y() }; } friend inline constexpr point operator-(const point& p) noexcept(NO_EXCEPT) { return { -p.x(), -p.y() }; } friend inline constexpr point operator+(point a, const point& b) noexcept(NO_EXCEPT) { return a += b; } friend inline constexpr point operator-(point a, const point& b) noexcept(NO_EXCEPT) { return a -= b; } friend inline constexpr value_type operator*(const point& a, const point& b) noexcept(NO_EXCEPT) { return a.x() * b.x() + a.y() * b.y(); } friend inline constexpr point operator+(point a, const value_type& b) noexcept(NO_EXCEPT) { return a += b; } friend inline constexpr point operator-(point a, const value_type& b) noexcept(NO_EXCEPT) { return a -= b; } friend inline constexpr point operator*(point a, const value_type& b) noexcept(NO_EXCEPT) { return a *= b; } friend inline constexpr point operator/(point a, const value_type& b) noexcept(NO_EXCEPT) { return a /= b; } friend inline constexpr point operator+(const value_type& a, point b) noexcept(NO_EXCEPT) { return b += a; } friend inline constexpr point operator-(const value_type& a, point b) noexcept(NO_EXCEPT) { return b += a; } friend inline constexpr point operator*(const value_type& a, point b) noexcept(NO_EXCEPT) { return b *= a; } friend inline constexpr point operator/(const value_type& a, point b) noexcept(NO_EXCEPT) { return b /= a; } friend inline constexpr bool operator==(const point& a, const point& b) noexcept(NO_EXCEPT) { return compare(a.x(), b.x()) == 0 and compare(a.y(), b.y()) == 0; } friend inline constexpr bool operator!=(const point& a, const point& b) noexcept(NO_EXCEPT) { return !(a == b); } friend inline constexpr bool operator<(const point& a, const point& b) noexcept(NO_EXCEPT) { return compare(a.x(), b.x()) != 0 ? compare(a.x(), b.x()) < 0 : compare(a.y(), b.y()) < 0; } friend inline constexpr bool operator>(const point& a, const point& b) noexcept(NO_EXCEPT) { return compare(a.x(), b.x()) != 0 ? compare(a.x(), b.x()) > 0 : compare(a.y(), b.y()) > 0; } friend inline constexpr bool operator<=(const point& a, const point& b) noexcept(NO_EXCEPT) { return !(a > b); } friend inline constexpr bool operator>=(const point& a, const point& b) noexcept(NO_EXCEPT) { return !(a < b); } inline std::pair<value_type,value_type> _debug() const { return { this->x(), this->y() }; } }; template<size_t I, class T> inline const typename point<T>::value_type& get(const point<T>& p) noexcept(NO_EXCEPT) { if constexpr(I == 0) { return p.x(); } else if constexpr(I == 1) { return p.y(); } else { static_assert(lib::internal::EXCEPTION<I>); } } template<size_t I, class T> inline typename point<T>::value_type& get(point<T>& p) noexcept(NO_EXCEPT) { if constexpr(I == 0) return p.x(); else if constexpr(I == 1) return p.y(); else static_assert(internal::EXCEPTION<I>); } } namespace std { template<class T> struct tuple_size<lib::point<T>> : integral_constant<size_t,2> {}; template<size_t I, class T> struct tuple_element<I,lib::point<T>> { using type = typename lib::point<T>::value_type; }; template<class T> inline constexpr T norm(const lib::point<T>& v) noexcept(NO_EXCEPT) { return v.x() * v.x() + v.y() * v.y(); } template<class T> inline constexpr T abs(const lib::point<T>& v) noexcept(NO_EXCEPT) { if constexpr(is_floating_point_v<T>) { return static_cast<T>(std::abs(std::complex<T>(v.x(), v.y()))); } else { return static_cast<T>(sqrt(norm(v))); } } template<class T, class C, class S> inline basic_istream<C,S>& operator>>(basic_istream<C,S>& in, lib::point<T>& v) noexcept(NO_EXCEPT) { T x, y; in >> x >> y; v = { x, y }; return in; } template<class T, class C, class S> inline basic_ostream<C,S>& operator<<(basic_ostream<C,S>& out, const lib::point<T>& v) noexcept(NO_EXCEPT) { out << v.x() << " " << v.y(); return out; } } namespace lib { template<class T> inline constexpr T distance(const point<T>& a, const point<T>& b) noexcept(NO_EXCEPT) { return std::abs(a - b); } template<class T> inline constexpr T squared_distance(const point<T>& a, const point<T>& b) noexcept(NO_EXCEPT) { return std::norm(a - b); } template<class T> inline constexpr T cross(point<T> a, point<T> b, const point<T>& o = {}) noexcept(NO_EXCEPT) { a -= o, b -= o; return a.x() * b.y() - a.y() * b.x(); } template<class T, class Angle = T> inline constexpr point<T> rotate(const point<T>& p, const Angle angle) noexcept(NO_EXCEPT) { return { std::cos(angle) * p.x() - std::sin(angle) * p.y(), std::sin(angle) * p.x() + std::cos(angle) * p.y() }; } template<class T, class Angle = T> inline constexpr point<T> rotate(const point<T>& p, const point<T>& q, const Angle angle) noexcept(NO_EXCEPT) { return rotate(p - q, angle) + q; } template<class T> inline constexpr positional_relation relation(const point<T>& p, point<T> q, point<T> r) noexcept(NO_EXCEPT) { q -= p, r -= p; const auto comp_qr = compare(cross(q, r)); if(comp_qr > 0) return positional_relation::counter_clockwise; if(comp_qr < 0) return positional_relation::clockwise; if(compare(q * r) < 0) return positional_relation::straight_backward; if(compare(std::norm(q), std::norm(r)) < 0) return positional_relation::straight_forward; return positional_relation::straight_middle; }; template<class T> inline constexpr positional_relation relation(const point<T>& p, const point<T>& q) noexcept(NO_EXCEPT) { return relation<T>({ 0, 0 }, p, q); } template<bool ALLOW_LINE, std::ranges::range R> inline bool is_convex(R&& range) noexcept(NO_EXCEPT) { const auto n = std::ranges::size(range); REP(i, n) { const positional_relation r = relation(range[i], range[lib::mod(i+1,n)], range[lib::mod(i+2,n)]); if constexpr(ALLOW_LINE) { if(r == positional_relation::clockwise) return false; } else { if(r != positional_relation::anti_clockwise) return false; } } return true; } template<std::input_iterator I, std::sentinel_for<I> S> inline bool is_convex(I first, S last) noexcept(NO_EXCEPT) { return is_convex<true>(first, last); } template<bool ALLOW_LINE, std::ranges::input_range R> inline bool is_convex(R&& range) noexcept(NO_EXCEPT) { return is_convex<ALLOW_LINE>(std::ranges::begin(range), std::ranges::end(range)); } template<std::ranges::input_range R> inline bool is_convex(R&& range) noexcept(NO_EXCEPT) { return is_convex<true>(std::ranges::begin(range), std::ranges::end(range)); } }
/* [end]: geometry/point.hpp*/
/* [begin]: geometry/triangle.hpp */
#include <array>
namespace lib { template<class Point> struct triangle { using point_type = Point; using value_type = typename point_type::value_type; private: point_type _p0 = {}, _p1 = {}, _p2 = {}; protected: inline constexpr void _normalize() noexcept(NO_EXCEPT) { std::array<point_type,3> vs = { this->_p0, this->_p1, this->_p2 }; std::sort(std::begin(vs), std::end(vs)); std::tie(this->_p0, this->_p1, this->_p2) = std::tie(vs[0], vs[1], vs[2]); } public: constexpr triangle() noexcept(NO_EXCEPT) {} template<class P0, class P1, class P2 = point_type> constexpr triangle(const P0& p0, const P1& p1, const P2& p2 = {}) noexcept(NO_EXCEPT) : _p0(p0), _p1(p1), _p2(p2) { this->_normalize(); } constexpr triangle(const point_type& p0, const point_type& p1, const point_type& p2 = {}) noexcept(NO_EXCEPT) : _p0(p0), _p1(p1), _p2(p2) { this->_normalize(); } inline constexpr point_type& p0() noexcept(NO_EXCEPT) { return this->_p0; } inline constexpr point_type& p1() noexcept(NO_EXCEPT) { return this->_p1; } inline constexpr point_type& p2() noexcept(NO_EXCEPT) { return this->_p2; } inline constexpr const point_type& p0() const noexcept(NO_EXCEPT) { return this->_p0; } inline constexpr const point_type& p1() const noexcept(NO_EXCEPT) { return this->_p1; } inline constexpr const point_type& p2() const noexcept(NO_EXCEPT) { return this->_p2; } inline constexpr auto vertices() noexcept(NO_EXCEPT) { return std::tuple<point_type&,point_type&,point_type&>{ this->p0(), this->p1(), this->p2() }; } inline constexpr auto vertices() const noexcept(NO_EXCEPT) { return std::tuple<const point_type&, const point_type&, const point_type&>{ this->p0(), this->p1(), this->p2() }; } inline constexpr const value_type area() const noexcept(NO_EXCEPT) { return std::abs(cross(this->p0(), this->p1(), this->p2())) / 2; } inline constexpr std::tuple<value_type,value_type,value_type> distances() const noexcept(NO_EXCEPT) { return { lib::distance(this->p1(), this->p2()), lib::distance(this->p2(), this->p0()), lib::distance(this->p0(), this->p1()) }; } inline constexpr std::tuple<value_type,value_type,value_type> squared_distances() const noexcept(NO_EXCEPT) { return { lib::squared_distance(this->p1(), this->p2()), lib::squared_distance(this->p2(), this->p0()), lib::squared_distance(this->p0(), this->p1()) }; } inline constexpr std::tuple<value_type,value_type,value_type> angles() const noexcept(NO_EXCEPT) { const auto [ d0, d1, d2 ] = this->distances(); return { std::acos((d1 * d1 + d2 * d2 - d0 * d0) / (2 * d1 * d2)), std::acos((d2 * d2 + d0 * d0 - d1 * d1) / (2 * d2 * d0)), std::acos((d0 * d0 + d1 * d1 - d2 * d2) / (2 * d0 * d1)) }; } inline constexpr point_type centroid() const noexcept(NO_EXCEPT) { return tuple_sum(this->vertices()) / 3; } inline constexpr point_type circum_center() const noexcept(NO_EXCEPT) { const auto [ d0, d1, d2 ] = this->squared_distances(); const value_type t0 = d0 * (d1 + d2 - d0); const value_type t1 = d1 * (d2 + d0 - d1); const value_type t2 = d2 * (d0 + d1 - d2); return (t0 * this->p0() + t1 * this->p1() + t2 * this->p2()) / (t0 + t1 + t2); } inline constexpr point_type inner_center() const noexcept(NO_EXCEPT) { const auto [ d0, d1, d2 ] = this->distances(); return (d0 * this->p0() + d1 * this->p1() + d2 * this->p2()) / (d0 + d1 + d2); } inline constexpr point_type ortho_center() const noexcept(NO_EXCEPT) { return tuple_sum(this->vertices()) - 2 * this->circum_center(); } inline constexpr triangle excenters() const noexcept(NO_EXCEPT) { const auto [ d0, d1, d2 ] = this->distances(); return { (d1 * this->p1() + d2 * this->p2() - d0 * this->p0()) / (d1 + d2 - d0), (d2 * this->p1() + d0 * this->p2() - d1 * this->p0()) / (d2 + d0 - d1), (d0 * this->p1() + d1 * this->p2() - d2 * this->p0()) / (d0 + d1 - d2) }; } std::tuple<point_type,point_type,point_type> _debug() const noexcept(NO_EXCEPT) { return std::tuple{ this->p0(), this->p1(), this->p2() }; } }; template<size_t I, class T> inline const typename triangle<T>::value_type& get(const triangle<T>& t) noexcept(NO_EXCEPT) { if constexpr(I == 0) { return t.p0(); } else if constexpr(I == 1) { return t.p1(); } else if constexpr(I == 2) { return t.p2(); } else { static_assert(internal::EXCEPTION<I>); } } template<size_t I, class T> inline typename triangle<T>::value_type& get(triangle<T>& t) noexcept(NO_EXCEPT) { if constexpr(I == 0) return t.p0(); else if constexpr(I == 1) return t.p1(); else if constexpr(I == 2) return t.p2(); else static_assert(internal::EXCEPTION<I>); } } namespace std { template<class T> struct tuple_size<lib::triangle<T>> : integral_constant<size_t,3> {}; template<size_t I, class T> struct tuple_element<I,lib::triangle<T>> { using type = typename lib::triangle<T>::value_type; }; template<class T, class C, class S> inline basic_istream<C,S>& operator>>(basic_istream<C,S>& in, lib::triangle<T>& v) noexcept(NO_EXCEPT) { typename lib::triangle<T>::point_type p, q, r; in >> p >> q >> r; v = { p, q, r }; return in; } }
/* [end]: geometry/triangle.hpp*/
/* [begin]: geometry/segment.hpp */
/* [begin]: geometry/line.hpp */
namespace lib { template<class P> struct line { using point_type = P; using value_type = typename point_type::value_type; private: point_type _p0 = {}, _p1 = {}; protected: inline constexpr void _normalize() noexcept(NO_EXCEPT) { if(this->_p0 > this->_p1) std::swap(this->_p0, this->_p1); } public: constexpr line() noexcept = default; constexpr line(const point_type& p0, const point_type& p1) noexcept(NO_EXCEPT) : _p0(p0), _p1(p1) { this->_normalize(); } constexpr line(const value_type a, const value_type b, const value_type c) noexcept(NO_EXCEPT) { if(compare(a) == 0) this->_p0 = { 0, c / b }, this->_p1 = { 1, c / b }; else if(compare(b) == 0) this->_p0 = { c / a, 0 }, this->_p1 = { c / a, 1 }; else this->_p0 = { 0, c / b }, this->_p1 = { c / a, 0 }; this->_normalize(); } inline constexpr point_type& p0() noexcept(NO_EXCEPT) { return this->_p0; } inline constexpr point_type& p1() noexcept(NO_EXCEPT) { return this->_p1; } inline constexpr const point_type& p0() const noexcept(NO_EXCEPT) { return this->_p0; } inline constexpr const point_type& p1() const noexcept(NO_EXCEPT) { return this->_p1; } inline constexpr auto vertices() noexcept(NO_EXCEPT) { return std::tuple<point_type&,point_type&>{ this->p0(), this->p1() }; } inline const constexpr auto vertices() const noexcept(NO_EXCEPT) { return std::tuple<const point_type&, const point_type&>{ this->p0(), this->p1() }; } inline constexpr const point_type to_vector() const noexcept(NO_EXCEPT) { return this->p1() - this->p0(); } inline constexpr const value_type length() const noexcept(NO_EXCEPT) { return lib::distance(this->p0(), this->p1()); } inline constexpr const value_type squared_length() const noexcept(NO_EXCEPT) { return lib::squared_distance(this->p0(), this->p1()); } inline constexpr const point_type midpoint() const noexcept(NO_EXCEPT) { return tuple_sum(this->vertices()) / 2; } inline std::pair<point_type,point_type> _debug() const { return { this->p0(), this->p1() }; } }; template<size_t I, class T> inline const typename line<T>::value_type& get(const line<T>& ln) noexcept(NO_EXCEPT) { if constexpr(I == 0) { return ln.p0(); } else if constexpr(I == 1) { return ln.p1(); } else { static_assert(lib::internal::EXCEPTION<I>); } } template<size_t I, class T> inline typename line<T>::value_type& get(line<T>& ln) noexcept(NO_EXCEPT) { if constexpr(I == 0) return ln.p0(); else if constexpr(I == 1) return ln.p1(); else static_assert(lib::internal::EXCEPTION<I>); } } namespace std { template<class T> struct tuple_size<lib::line<T>> : integral_constant<size_t,2> {}; template<size_t I, class T> struct tuple_element<I,lib::line<T>> { using type = typename lib::line<T>::value_type; }; template<class P, class C, class S> inline basic_istream<C,S>& operator>>(basic_istream<C,S>& in, lib::line<P>& v) noexcept(NO_EXCEPT) { P x, y; in >> x >> y; v = { x, y }; return in; } template<class P, class C, class S> inline basic_ostream<C,S>& operator<<(basic_ostream<C,S>& out, const lib::line<P>& v) noexcept(NO_EXCEPT) { out << v.p0() << " " << v.p1(); return out; } } namespace lib { template<class P> bool is_parallel(const line<P>& p, const line<P>& q) noexcept(NO_EXCEPT) { return compare(p.to_vector() * q.to_vector()) == 0; } template<class P> bool is_orthogonal(const line<P>& p, const line<P>& q) noexcept(NO_EXCEPT) { return compare(cross(p.to_vector(), q.to_vector())) == 0; } template<class P> inline constexpr std::optional<P> intersection(const line<P>& s, const line<P>& t) noexcept(NO_EXCEPT) { using value_type = typename P::value_type; const P p = s.to_vector(), q = t.to_vector(); const value_type d0 = cross(p, q); const value_type d1 = cross(p, s.p1() - t.p0()); if(compare(d0) == 0 and compare(d1) == 0) return {}; return t.p0() + q * (d1 / d0); } }
/* [end]: geometry/line.hpp*/
namespace lib { template<class Point> struct segment : line<Point> { using point_type = Point; using value_type = typename point_type::value_type; constexpr segment(const point_type& p0, const point_type& p1 = {}) noexcept(NO_EXCEPT) : line<Point>(p0, p1) {}; template<class U> constexpr segment(const line<U>& ln) noexcept(NO_EXCEPT) : line<Point>(ln.p0(), ln.p1()) {} }; template<bool ALLOW_END_POINT, class P> bool is_intersecting(const segment<P>& p, const segment<P>& q) noexcept(NO_EXCEPT) { using value_type = typename P::value_type; const value_type cp0 = cross(p.p1(), q.p0(), p.p0()); const value_type cp1 = cross(p.p1(), q.p1(), p.p0()); const value_type cp2 = cross(q.p1(), p.p0(), q.p0()); const value_type cp3 = cross(q.p1(), p.p1(), q.p0()); if(compare(cp0) == 0 and compare(cp1) == 0 and compare(cp2) == 0 and compare(cp3) == 0) { return lib::max(p.p0(), q.p0()) <= lib::min(p.p1(), q.p1()); } if constexpr(ALLOW_END_POINT) return compare(cp0 * cp1) <= 0 and compare(cp2 * cp3) <= 0; else return compare(cp0 * cp1) < 0 and compare(cp2 * cp3) < 0; } template<class P> bool is_intersecting(const segment<P>& p, const segment<P>& q) noexcept(NO_EXCEPT) { return is_intersecting<true>(p, q); } template<class P> inline constexpr std::optional<P> intersection(const segment<P>& p, const segment<P>& q) noexcept(NO_EXCEPT) { if(not is_intersecting(p, q)) return {}; return intersection(line<P>(p), line<P>(q)); } }
/* [end]: geometry/segment.hpp*/
/* [begin]: geometry/circle.hpp */
namespace lib { template<class Point, class Radius = typename Point::value_type> struct circle { using point_type = Point; using radius_type = Radius; using value_type = std::common_type_t<typename point_type::value_type, radius_type>; protected: point_type _c = 0; radius_type _r2 = 0; public: constexpr circle(const point_type& c, const radius_type& r) noexcept(NO_EXCEPT) : _c(c), _r2(r * r) {} constexpr circle(const radius_type& r) noexcept(NO_EXCEPT) : _c({ 0, 0 }), _r2(r * r) {} template<class P0, class P1, class P2> constexpr circle(const P0& p0, const P1& p1, const P2& p2) noexcept(NO_EXCEPT) : circle(triangle(p0, p1, p2)) {}; constexpr circle(const point_type& p0, const point_type& p1, const point_type& p2) noexcept(NO_EXCEPT) : circle(triangle(p0, p1, p2)) {}; template<class P> constexpr circle(const segment<P>& seg) noexcept(NO_EXCEPT) : _c(seg.midpoint()), _r2(seg.squared_length() / 4) {}; constexpr circle(const segment<point_type>& seg) noexcept(NO_EXCEPT) : _c(seg.midpoint()), _r2(seg.squared_length() / 4) {}; template<class P> constexpr circle(const triangle<P>& t) noexcept(NO_EXCEPT) : _c(t.circum_center()), _r2(lib::squared_distance(this->_c, t.p0())) {} constexpr circle(const triangle<point_type>& t) noexcept(NO_EXCEPT) : _c(t.circum_center()), _r2(lib::squared_distance(this->_c, t.p0())) {} inline constexpr point_type& center() noexcept(NO_EXCEPT) { return this->_c; } inline radius_type radius() noexcept(NO_EXCEPT) { return static_cast<value_type>(std::sqrt(this->_r2)); } inline constexpr radius_type& squared_radius() noexcept(NO_EXCEPT) { return this->_r2; } inline constexpr const point_type& center() const noexcept(NO_EXCEPT) { return this->_c; } inline const radius_type radius() const noexcept(NO_EXCEPT) { return static_cast<value_type>(std::sqrt(this->_r2)); } inline constexpr const radius_type& squared_radius() const noexcept(NO_EXCEPT) { return this->_r2; } std::pair<point_type,radius_type> _debug() const noexcept(NO_EXCEPT) { return std::make_pair(this->center(), this->radius()); } }; }
/* [end]: geometry/circle.hpp*/
namespace lib { template<class T> inline constexpr point<T> projected(const point<T>& p, const line<point<T>>& ln) noexcept(NO_EXCEPT) { const point<T> q = ln.p0() - ln.p1(); const T t = (p - ln.p0()) * q / std::norm(q); return ln.p0() + q * t; } template<class T> inline constexpr point<T> reflected(const point<T>& p, const line<point<T>>& ln) { return p + (projection(ln, p) - p) * 2; } template<class T> inline constexpr positional_relation relation(const point<T>& p, const circle<T>& o) noexcept(NO_EXCEPT) { const T dist = lib::squared_distance(o.center(), p); const auto comp = compare(dist, o.squared_radius()); if(comp > 0) return positional_relation::out; if(comp < 0) return positional_relation::in; return positional_relation::on; } namespace internal { template<class T> inline constexpr positional_relation relation( const point<T>& p, const line<point<T>>& ln, T *const _al = nullptr, T *const _bl = nullptr ) noexcept(NO_EXCEPT) { const point<T> a = ln.to_vector(); const point<T> b = p - ln.p0(); T al = std::norm(a), bl = std::norm(b); if(_al) *_al = al; if(_bl) *_bl = bl; const T t = al * bl; const T dot = a * b; if(compare(t, dot * dot) != 0) return positional_relation::out; return positional_relation::in; } } template<class T> inline constexpr positional_relation relation(const point<T>& p, const line<point<T>>& seg) noexcept(NO_EXCEPT) { return internal::relation(p, seg); } template<class T> inline constexpr positional_relation relation(const point<T>& p, const segment<point<T>>& seg) noexcept(NO_EXCEPT) { if(p == seg.p0() or p == seg.p1()) return positional_relation::on; T al, bl; if(internal::relation(p, seg, &al, &bl) == positional_relation::out) { return positional_relation::out; }; const auto comp = compare(al, bl); if(comp < 0) return positional_relation::out; if(comp > 0) return positional_relation::in; assert(false); } }
/* [end]: geometry/basic.hpp*/
/* [begin]: geometry/convex_full.hpp */
namespace lib { template<bool LEAVE_MARGIN, bool ALLOW_LINE, std::input_iterator I, std::sentinel_for<I> S> vector<std::iter_value_t<I>> convex_hull(I first, S last) noexcept(NO_EXCEPT) { using P = std::iter_value_t<I>; using size_type = internal::size_t; auto remove = [&](const P& p, const P& q, const P& r) -> bool { if constexpr(ALLOW_LINE) { return compare(cross(p, q, r)) < 0; } else { return compare(cross(p, q, r)) <= 0; } }; std::vector<P> points(first, last); const auto n = static_cast<size_type>(points.size()); std::sort(std::begin(points), std::end(points)); vector<P> res(2 * n); size_type k = 0; for(size_type i=0; i<n; res[k++] = points[i++]) { while(k >= 2 and remove(points[i], res[k-2], res[k-1])) --k; } for(auto i=n-2, t=k+1; i>=0; res[k++] = points[i--]) { while(k >= t and remove(points[i], res[k-2], res[k-1])) --k; } if constexpr(LEAVE_MARGIN) res.resize(k); else res.resize(k - 1); return res; } template<std::input_iterator I, std::sentinel_for<I> S> inline auto convex_hull(I first, S last) noexcept(NO_EXCEPT) { return convex_hull<false,true>(first, last); } template<bool LEAVE_MARGIN, bool ALLOW_LINE, std::ranges::input_range V> inline auto convex_hull(V&& v) noexcept(NO_EXCEPT) { return convex_hull<LEAVE_MARGIN,ALLOW_LINE>(std::begin(v), std::end(v)); } template<std::ranges::input_range V> inline auto convex_hull(V&& v) noexcept(NO_EXCEPT) { return convex_hull<false,true>(std::begin(v), std::end(v)); } }
/* [end]: geometry/convex_full.hpp*/
/* [end]: include/geometries.hpp*/
/* [begin]: include/adapters.hpp */
/* [begin]: adapter/io.hpp */
/* [begin]: adapter/internal/input.hpp */
/* [begin]: ac-library/atcoder/modint */
/* [begin]: ac-library/atcoder/modint.hpp */
#ifndef ATCODER_MODINT_HPP
#define ATCODER_MODINT_HPP 1
#ifdef _MSC_VER
#endif
/* [begin]: ac-library/atcoder/internal_type_traits */
/* [begin]: ac-library/atcoder/internal_type_traits.hpp */
#ifndef ATCODER_INTERNAL_TYPE_TRAITS_HPP
#define ATCODER_INTERNAL_TYPE_TRAITS_HPP 1
namespace atcoder { namespace internal {
#ifndef _MSC_VER
template <class T> using is_signed_int128 = typename std::conditional<std::is_same<T, __int128_t>::value || std::is_same<T, __int128>::value, std::true_type, std::false_type>::type; template <class T> using is_unsigned_int128 = typename std::conditional<std::is_same<T, __uint128_t>::value || std::is_same<T, unsigned __int128>::value, std::true_type, std::false_type>::type; template <class T> using make_unsigned_int128 = typename std::conditional<std::is_same<T, __int128_t>::value, __uint128_t, unsigned __int128>; template <class T> using is_integral = typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value || is_unsigned_int128<T>::value, std::true_type, std::false_type>::type; template <class T> using is_signed_int = typename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) || is_signed_int128<T>::value, std::true_type, std::false_type>::type; template <class T> using is_unsigned_int = typename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) || is_unsigned_int128<T>::value, std::true_type, std::false_type>::type; template <class T> using to_unsigned = typename std::conditional< is_signed_int128<T>::value, make_unsigned_int128<T>, typename std::conditional<std::is_signed<T>::value, std::make_unsigned<T>, std::common_type<T>>::type>::type;
#else
template <class T> using is_integral = typename std::is_integral<T>; template <class T> using is_signed_int = typename std::conditional<is_integral<T>::value && std::is_signed<T>::value, std::true_type, std::false_type>::type; template <class T> using is_unsigned_int = typename std::conditional<is_integral<T>::value && std::is_unsigned<T>::value, std::true_type, std::false_type>::type; template <class T> using to_unsigned = typename std::conditional<is_signed_int<T>::value, std::make_unsigned<T>, std::common_type<T>>::type;
#endif
template <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>; template <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>; template <class T> using to_unsigned_t = typename to_unsigned<T>::type; } }
#endif
/* [end]: ac-library/atcoder/internal_type_traits.hpp*/
/* [end]: ac-library/atcoder/internal_type_traits*/
namespace atcoder { namespace internal { struct modint_base {}; struct static_modint_base : modint_base {}; template <class T> using is_modint = std::is_base_of<modint_base, T>; template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>; } template <int m, std::enable_if_t<(1 <= m)>* = nullptr> struct static_modint : internal::static_modint_base { using mint = static_modint; public: static constexpr int mod() { return m; } static mint raw(int v) { mint x; x._v = v; return x; } static_modint() : _v(0) {} template <class T, internal::is_signed_int_t<T>* = nullptr> static_modint(T v) { long long x = (long long)(v % (long long)(umod())); if (x < 0) x += umod(); _v = (unsigned int)(x); } template <class T, internal::is_unsigned_int_t<T>* = nullptr> static_modint(T v) { _v = (unsigned int)(v % umod()); } unsigned int val() const { return _v; } mint& operator++() { _v++; if (_v == umod()) _v = 0; return *this; } mint& operator--() { if (_v == 0) _v = umod(); _v--; return *this; } mint operator++(int) { mint result = *this; ++*this; return result; } mint operator--(int) { mint result = *this; --*this; return result; } mint& operator+=(const mint& rhs) { _v += rhs._v; if (_v >= umod()) _v -= umod(); return *this; } mint& operator-=(const mint& rhs) { _v -= rhs._v; if (_v >= umod()) _v += umod(); return *this; } mint& operator*=(const mint& rhs) { unsigned long long z = _v; z *= rhs._v; _v = (unsigned int)(z % umod()); return *this; } mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); } mint operator+() const { return *this; } mint operator-() const { return mint() - *this; } mint pow(long long n) const { assert(0 <= n); mint x = *this, r = 1; while (n) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; } mint inv() const { if (prime) { assert(_v); return pow(umod() - 2); } else { auto eg = internal::inv_gcd(_v, m); assert(eg.first == 1); return eg.second; } } friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs; } friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs; } friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs; } friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs; } friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v; } friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v; } private: unsigned int _v; static constexpr unsigned int umod() { return m; } static constexpr bool prime = internal::is_prime<m>; }; template <int id> struct dynamic_modint : internal::modint_base { using mint = dynamic_modint; public: static int mod() { return (int)(bt.umod()); } static void set_mod(int m) { assert(1 <= m); bt = internal::barrett(m); } static mint raw(int v) { mint x; x._v = v; return x; } dynamic_modint() : _v(0) {} template <class T, internal::is_signed_int_t<T>* = nullptr> dynamic_modint(T v) { long long x = (long long)(v % (long long)(mod())); if (x < 0) x += mod(); _v = (unsigned int)(x); } template <class T, internal::is_unsigned_int_t<T>* = nullptr> dynamic_modint(T v) { _v = (unsigned int)(v % mod()); } unsigned int val() const { return _v; } mint& operator++() { _v++; if (_v == umod()) _v = 0; return *this; } mint& operator--() { if (_v == 0) _v = umod(); _v--; return *this; } mint operator++(int) { mint result = *this; ++*this; return result; } mint operator--(int) { mint result = *this; --*this; return result; } mint& operator+=(const mint& rhs) { _v += rhs._v; if (_v >= umod()) _v -= umod(); return *this; } mint& operator-=(const mint& rhs) { _v += mod() - rhs._v; if (_v >= umod()) _v -= umod(); return *this; } mint& operator*=(const mint& rhs) { _v = bt.mul(_v, rhs._v); return *this; } mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); } mint operator+() const { return *this; } mint operator-() const { return mint() - *this; } mint pow(long long n) const { assert(0 <= n); mint x = *this, r = 1; while (n) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; } mint inv() const { auto eg = internal::inv_gcd(_v, mod()); assert(eg.first == 1); return eg.second; } friend mint operator+(const mint& lhs, const mint& rhs) { return mint(lhs) += rhs; } friend mint operator-(const mint& lhs, const mint& rhs) { return mint(lhs) -= rhs; } friend mint operator*(const mint& lhs, const mint& rhs) { return mint(lhs) *= rhs; } friend mint operator/(const mint& lhs, const mint& rhs) { return mint(lhs) /= rhs; } friend bool operator==(const mint& lhs, const mint& rhs) { return lhs._v == rhs._v; } friend bool operator!=(const mint& lhs, const mint& rhs) { return lhs._v != rhs._v; } private: unsigned int _v; static internal::barrett bt; static unsigned int umod() { return bt.umod(); } }; template <int id> internal::barrett dynamic_modint<id>::bt(998244353); using modint998244353 = static_modint<998244353>; using modint1000000007 = static_modint<1000000007>; using modint = dynamic_modint<-1>; namespace internal { template <class T> using is_static_modint = std::is_base_of<internal::static_modint_base, T>; template <class T> using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>; template <class> struct is_dynamic_modint : public std::false_type {}; template <int id> struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {}; template <class T> using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>; } }
#endif
/* [end]: ac-library/atcoder/modint.hpp*/
/* [end]: ac-library/atcoder/modint*/
/* [begin]: internal/resolving_rank.hpp */
namespace lib { namespace internal { template<int P> struct resolving_rank : resolving_rank<P-1> {}; template<> struct resolving_rank<0> {}; } }
/* [end]: internal/resolving_rank.hpp*/
/* [begin]: numeric/modular/modint_interface.hpp */
/* [begin]: numeric/modular/builtin_reduction.hpp */
namespace lib { namespace internal { template<std::unsigned_integral Value, std::unsigned_integral Large> requires has_double_digits_of<Large, Value> struct builtin_reduction { using value_type = Value; using large_type = Large; private: value_type _mod; public: static constexpr int digits = std::numeric_limits<value_type>::digits; static constexpr value_type max() noexcept { return std::numeric_limits<value_type>::max(); } inline constexpr value_type mod() const noexcept(NO_EXCEPT) { return this->_mod; } constexpr builtin_reduction() noexcept = default; constexpr builtin_reduction(const value_type mod) noexcept(NO_EXCEPT) : _mod(mod) { assert(0 < mod && mod < builtin_reduction::max()); } inline constexpr value_type reduce(const large_type v) const noexcept(NO_EXCEPT) { return v % this->_mod; } inline constexpr value_type add(value_type x, const value_type y) const noexcept(NO_EXCEPT) { if(x >= this->_mod - y) x -= this->_mod; x += y; return x; } inline constexpr value_type subtract(value_type x, const value_type y) const noexcept(NO_EXCEPT) { if(x < y) x += this->_mod; x -= y; return x; } inline constexpr value_type multiply(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return this->reduce(static_cast<large_type>(x) * static_cast<large_type>(y)); } inline constexpr value_type pow(const value_type v, i64 p) const noexcept(NO_EXCEPT) { if(this->_mod == 0) return 0; return lib::pow(v, p, [this](const value_type x, const value_type y) { return this->multiply(x, y); }); } inline constexpr bool equal(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return x == y; } constexpr value_type convert_raw(const value_type v) const noexcept(NO_EXCEPT) { return v; } template<std::integral T> constexpr value_type convert(T v) const noexcept(NO_EXCEPT) { using common_type = std::common_type_t<T, value_type>; const common_type mod = static_cast<common_type>(this->_mod); if(std::is_constant_evaluated()) { v %= mod; if(v < 0) v += mod; } else { if(v > 0 && static_cast<common_type>(v) >= mod) { v %= mod; } if constexpr(std::signed_integral<T>) { if(v < 0) { if(static_cast<common_type>(-v) <= mod) v += mod; else { v %= mod; if(v != 0) v += mod; } } } } return static_cast<value_type>(v); } constexpr value_type revert(const value_type v) const noexcept(NO_EXCEPT) { return this->_mod == 1 ? 0 : v; } }; } using builtin_reduction_32bit = internal::builtin_reduction<u32, u64>; using builtin_reduction_64bit = internal::builtin_reduction<u64, u128>; }
/* [end]: numeric/modular/builtin_reduction.hpp*/
/* [begin]: numeric/modular/binary_reduction.hpp */
/* [begin]: numeric/bit.hpp */
#include <immintrin.h>
#include <bit>
namespace lib { template<std::unsigned_integral T> constexpr T multiply_high(const T x, const T y) noexcept(NO_EXCEPT) { constexpr int digits = std::numeric_limits<T>::digits; if constexpr(digits <= 16) { return static_cast<T>((static_cast<u32>(x) * static_cast<u32>(y)) >> digits); } else if constexpr(digits <= 32) { return static_cast<T>((static_cast<u64>(x) * static_cast<u64>(y)) >> digits); } else if constexpr(digits <= 64) { return static_cast<T>((static_cast<u128>(x) * static_cast<u128>(y)) >> digits); } else { constexpr int h_digits = digits / 2; constexpr T mask = (T{ 1 } << h_digits) - 1; const T xh = x >> h_digits, yh = y >> h_digits; const T xl = x & mask, yl = y & mask; const T ph = xh * yh, pl = xl * yl; return (((pl >> h_digits) + (xh + xl) * (yh + yl) - (ph + pl)) >> h_digits) + ph; } } template<std::unsigned_integral T> inline constexpr int highest_bit_pos(const T v) noexcept(NO_EXCEPT) { return std::bit_width(v) - 1; } template<std::unsigned_integral T> inline constexpr int lowest_bit_pos(const T v) noexcept(NO_EXCEPT) { if(v == 0) return -1; return std::countr_zero(v); } template<std::unsigned_integral T> __attribute__((target("bmi2"))) inline constexpr T clear_higher_bits(const T v, const T p) { constexpr int DIGITS = std::numeric_limits<T>::digits; assert(p < DIGITS); if constexpr(DIGITS <= 32) return _bzhi_u64(v, p); if constexpr(DIGITS <= 64) return _bzhi_u64(v, p); else { static_assert(DIGITS <= 128); constexpr std::uint64_t MAX64 = std::numeric_limits<std::uint64_t>::max(); const std::uint64_t high = v >> 64; const std::uint64_t low = v & MAX64; if(p < 64) return _bzhi_u64(low, p); return low | (T{_bzhi_u64(high, p - 64)} << 64); } } template<std::unsigned_integral T> constexpr T shiftl(const T, const int); template<std::unsigned_integral T> constexpr T shiftr(const T, const int); template<std::unsigned_integral T> constexpr T shiftl(const T x, const int n) { constexpr int DIGITS = std::numeric_limits<T>::digits; if(n < 0) return shiftr(x, -n); if(n >= DIGITS) return 0; return x << n; } template<std::unsigned_integral T> constexpr T shiftr(const T x, const int n) { constexpr int DIGITS = std::numeric_limits<T>::digits; if(n < 0) return shiftl(x, -n); if(n >= DIGITS) return 0; return x >> n; } template<std::unsigned_integral T> inline constexpr T bit(const T x, const int p) { return shiftr(x, p) & T{1}; } namespace internal { template<std::unsigned_integral T> constexpr T binary_gcd(T a, T b) noexcept(NO_EXCEPT) { if(!a || !b) return a | b; T t, s = std::countr_zero(a | b); a >>= std::countr_zero(a); do { b >>= std::countr_zero(b); if(a > b) t = a, a = b, b = t; b -= a; } while(b); return a << s; } template<std::signed_integral T> inline constexpr T binary_gcd(const T a, const T b) noexcept(NO_EXCEPT) { return binary_gcd(a < 0 ? -a : a, b < 0 ? -b : b); } } template<std::integral T0, std::integral T1> inline constexpr auto binary_gcd(T0 v0, T1 v1) noexcept(NO_EXCEPT) { using common_type = std::common_type_t<T0, T1>; return internal::binary_gcd(static_cast<common_type>(v0), static_cast<common_type>(v1)); } }
/* [end]: numeric/bit.hpp*/
namespace lib { namespace internal { template<std::unsigned_integral Value> struct binary_reduction { using value_type = Value; private: value_type _mask; public: static constexpr int digits = std::numeric_limits<value_type>::digits; static constexpr value_type max() noexcept { return std::numeric_limits<value_type>::max(); } inline constexpr value_type mod() const noexcept(NO_EXCEPT) { return this->_mask + 1; } constexpr binary_reduction() noexcept = default; constexpr explicit inline binary_reduction(const value_type mod) noexcept(NO_EXCEPT) : _mask(mod - 1) { assert(std::has_single_bit(mod)); } inline constexpr value_type reduce(const value_type v) const noexcept(NO_EXCEPT) { return v; } inline constexpr value_type add(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return x + y; } inline constexpr value_type subtract(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return x - y; } inline constexpr value_type multiply(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return x * y; } inline constexpr value_type pow(const value_type v, i64 p) const noexcept(NO_EXCEPT) { if(this->_mask == 0) return 0; return lib::pow(v, p); } inline constexpr bool equal(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return this->revert(x) == this->revert(y); } constexpr value_type convert_raw(const value_type v) const noexcept(NO_EXCEPT) { return v; } template<std::integral T> constexpr value_type convert(T v) const noexcept(NO_EXCEPT) { return static_cast<value_type>(v); } constexpr value_type revert(const value_type v) const noexcept(NO_EXCEPT) { return v & this->_mask; } }; } using binary_reduction_32bit = internal::binary_reduction<u32>; using binary_reduction_64bit = internal::binary_reduction<u64>; using binary_reduction_128bit = internal::binary_reduction<u128>; }
/* [end]: numeric/modular/binary_reduction.hpp*/
/* [begin]: numeric/modular/barrett_reduction.hpp */
namespace lib { namespace internal { template<std::unsigned_integral Value, std::unsigned_integral Large> requires has_double_digits_of<Large, Value> struct barrett_reduction { using value_type = Value; using large_type = Large; private: large_type _mod = 0, _mi; inline constexpr std::pair<large_type,value_type> _reduce(const large_type v) const noexcept(NO_EXCEPT) { large_type x = multiply_high(v, this->_mi); return { x, static_cast<value_type>(v - x * this->_mod) }; } public: static constexpr int digits = std::numeric_limits<value_type>::digits - 1; static constexpr value_type max() noexcept { return (value_type{ 1 } << barrett_reduction::digits) - 1; } inline constexpr value_type mod() const noexcept(NO_EXCEPT) { return this->_mod; } constexpr barrett_reduction() noexcept = default; constexpr explicit inline barrett_reduction(const value_type mod) : _mod(mod), _mi(std::numeric_limits<large_type>::max() / mod + 1) { assert(0 < mod && mod <= barrett_reduction::max()); } inline constexpr large_type quotient(const large_type v) const noexcept(NO_EXCEPT) { const auto [ x, r ] = this->_reduce(v); return static_cast<large_type>(this->_mod <= r ? x - 1 : x); } inline constexpr value_type reduce(const large_type v) const noexcept(NO_EXCEPT) { const auto [ x, r ] = this->_reduce(v); return static_cast<value_type>(this->_mod <= r ? r + this->_mod : r); } inline constexpr std::pair<large_type,value_type> divide(const large_type v) const noexcept(NO_EXCEPT) { const auto [ x, r ] = this->_reduce(v); if(this->_mod <= r) return { static_cast<large_type>(x - 1), static_cast<value_type>(r + this->_mod) }; return { static_cast<large_type>(x), static_cast<value_type>(r) }; } inline constexpr value_type add(value_type x, const value_type y) const noexcept(NO_EXCEPT) { x += y; if(x >= this->_mod) x -= this->_mod; return x; } inline constexpr value_type subtract(value_type x, const value_type y) const noexcept(NO_EXCEPT) { if(x < y) x += this->_mod; x -= y; return x; } inline constexpr value_type multiply(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return this->reduce(static_cast<large_type>(x) * static_cast<large_type>(y)); } inline constexpr value_type pow(const large_type v, i64 p) const noexcept(NO_EXCEPT) { if(this->_mod == 1) return 0; return lib::pow( this->reduce(v), p, [&](const value_type x, const value_type y) noexcept(NO_EXCEPT) { return this->multiply(x, y); } ); } inline constexpr bool equal(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return x == y; } constexpr value_type convert_raw(const value_type v) const noexcept(NO_EXCEPT) { return v; } template<std::integral T> constexpr value_type convert(T v) const noexcept(NO_EXCEPT) { using common_type = std::common_type_t<T, value_type>; const common_type mod = static_cast<common_type>(this->_mod); if(v > 0 && static_cast<common_type>(v) >= mod) { if(static_cast<common_type>(v) <= barrett_reduction::max()) v = this->reduce(v); else v %= mod; } if constexpr(std::signed_integral<T>) { if(v < 0) { if(static_cast<common_type>(-v) <= mod) v += mod; else if(static_cast<common_type>(-v) <= barrett_reduction::max()) { v = mod - this->reduce(static_cast<value_type>(-v - 1)) - 1; } else { v %= mod; if(v != 0) v += mod; } } } return static_cast<value_type>(v); } constexpr value_type revert(const value_type v) const noexcept(NO_EXCEPT) { return this->reduce(v); } }; } using barrett_reduction_32bit = internal::barrett_reduction<u32, u64>; using barrett_reduction_64bit = internal::barrett_reduction<u64, u128>; }
/* [end]: numeric/modular/barrett_reduction.hpp*/
/* [begin]: numeric/modular/montgomery_reduction.hpp */
namespace lib { namespace internal { template<std::unsigned_integral Value, std::unsigned_integral Large> requires has_double_digits_of<Large, Value> struct montgomery_reduction { using value_type = Value; using large_type = Large; private: value_type _mod = 0, _r2, _mp; constexpr value_type _inv() const noexcept(NO_EXCEPT) { value_type res = this->_mod; while(this->_mod * res != 1) res *= value_type{ 2 } - this->_mod * res; return res; } public: static constexpr int digits = std::numeric_limits<value_type>::digits - 2; static inline constexpr value_type max() noexcept { return (value_type{ 1 } << montgomery_reduction::digits) - 1; } inline constexpr value_type mod() const noexcept(NO_EXCEPT) { return this->_mod; } value_type zero = 0; value_type one; constexpr montgomery_reduction() noexcept = default; constexpr montgomery_reduction(const value_type mod) noexcept(NO_EXCEPT) : _mod(mod), _r2(static_cast<value_type>(-static_cast<large_type>(mod) % mod)), _mp(-this->_inv()), one(this->reduce(this->_r2)) { assert((mod & 1) == 1); assert(mod <= montgomery_reduction::max()); } constexpr value_type reduce(const large_type v) const noexcept(NO_EXCEPT) { return static_cast<value_type>( ( v + static_cast<large_type>(static_cast<value_type>(v) * this->_mp) * this->_mod ) >> std::numeric_limits<value_type>::digits ); } inline constexpr value_type add(value_type x, const value_type y) const noexcept(NO_EXCEPT) { x += y; if(x >= (this->_mod << 1)) x -= (this->_mod << 1); return x; } inline constexpr value_type subtract(value_type x, const value_type y) const noexcept(NO_EXCEPT) { if(x < y) x += (this->_mod << 1); x -= y; return x; } inline constexpr value_type multiply(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return this->reduce(static_cast<large_type>(x) * static_cast<large_type>(y)); } inline constexpr value_type pow(const large_type v, i64 p) const noexcept(NO_EXCEPT) { if(this->_mod == 1) return 0; return lib::pow( v, p, [&](const value_type x, const value_type y) noexcept(NO_EXCEPT) { return this->multiply(x, y); }, static_cast<large_type>(this->one) ); } inline constexpr value_type normalize(const value_type v) const noexcept(NO_EXCEPT) { assert(0 <= v && v < (this->_mod << 1)); if(v < this->_mod) return v; return v - this->_mod; } inline constexpr bool equal(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return this->normalize(x) == this->normalize(y); } inline constexpr value_type convert_raw(const value_type v) const noexcept(NO_EXCEPT) { if(v == 1) return this->one; return this->multiply(v, this->_r2); } template<std::integral T> constexpr value_type convert(T v) const noexcept(NO_EXCEPT) { if(v == 1) return this->one; using common_type = std::common_type_t<T, value_type>; const common_type mod2 = static_cast<common_type>(this->_mod << 1); if(v > 0 && static_cast<common_type>(v) >= mod2) { v %= mod2; } if constexpr(std::is_signed_v<T>) { if(v < 0 && static_cast<common_type>(-v) >= mod2) { v %= mod2; if(v != 0) v += mod2; } } return this->multiply(v, this->_r2); } constexpr value_type revert(const value_type v) const noexcept(NO_EXCEPT) { return this->normalize(this->reduce(v)); } }; template<std::unsigned_integral Value, std::unsigned_integral Large> requires has_double_digits_of<Large, Value> struct arbitrary_montgomery_reduction { using value_type = Value; using large_type = Large; private: using context = arbitrary_montgomery_reduction; static constexpr int width = std::numeric_limits<value_type>::digits; value_type _mod = 0; int _tz; value_type _m0; large_type _m0i, _mask; value_type _r2; constexpr large_type _inv() const noexcept(NO_EXCEPT) { large_type res = this->_m0; while(((this->_m0 * res) & this->_mask) != 1) res *= large_type{ 2 } - this->_m0 * res; return res & this->_mask; } constexpr value_type _m0ip() const noexcept(NO_EXCEPT) { if(this->_tz == 0) return 0; value_type res = this->_m0; const value_type mask = (value_type{ 1 } << this->_tz) - 1; while(((this->_m0 * res) & mask) != 1) res *= value_type{ 2 } - this->_m0 * res; return res & mask; } public: static constexpr int digits = std::numeric_limits<value_type>::digits - 2; static inline constexpr value_type max() noexcept { return (value_type{ 1 } << context::digits) - 1; } inline constexpr value_type mod() const noexcept(NO_EXCEPT) { return this->_mod; } value_type one; constexpr arbitrary_montgomery_reduction() noexcept = default; constexpr arbitrary_montgomery_reduction(value_type m) noexcept(NO_EXCEPT) { assert(0 < m); if(this->_mod == m) return; this->_mod = m; this->_tz = std::countr_zero(m); this->_m0 = m >> this->_tz; assert(this->_mod < context::max()); this->_mask = (large_type{ 1 } << (context::width + this->_tz)) - 1; this->_m0i = this->_inv(); { const value_type x = (std::numeric_limits<large_type>::max() % this->_m0) + 1; const value_type mask = (value_type{ 1 } << this->_tz) - 1; this->_r2 = (x + ((((large_type{ 1 } - x) * this->_m0ip()) & mask) * this->_m0)); } this->one = this->reduce(this->_r2); } constexpr value_type reduce(const large_type v) const noexcept(NO_EXCEPT) { const value_type res = static_cast<value_type>( ( v + this->_m0 * ((((v << std::numeric_limits<value_type>::digits) - v) * this->_m0i) & this->_mask) ) >> std::numeric_limits<value_type>::digits ); return res; } inline constexpr value_type add(value_type x, const value_type y) const noexcept(NO_EXCEPT) { x += y; if(x >= (this->_mod << 1)) x -= (this->_mod << 1); return x; } inline constexpr value_type subtract(value_type x, const value_type y) const noexcept(NO_EXCEPT) { if(x < y) x += (this->_mod << 1); x -= y; return x; } inline constexpr value_type multiply(const value_type x, const value_type y) const noexcept(NO_EXCEPT) { return this->reduce(static_cast<large_type>(x) * static_cast<large_type>(y)); } inline constexpr value_type pow(const large_type v, i64 p) const noexcept(NO_EXCEPT) { if(this->_mod == 1) return 0; return lib::pow( v, p, [&](const value_type x, const value_type y) noexcept(NO_EXCEPT) { return this->multiply(x, y); }, static_cast<large_type>(this->one) ); } inline constexpr value_type normalize(const value_type v) const noexcept(NO_EXCEPT) { assert(0 <= v && v < (this->_mod << 1)); if(v < this->_mod) return v; return v - this->_mod; } inline constexpr bool equal(const large_type x, const large_type y) const noexcept(NO_EXCEPT) { return this->normalize(x) == this->normalize(y); } inline constexpr value_type convert_raw(const value_type v) const noexcept(NO_EXCEPT) { if(v == 1) return this->one; return this->multiply(v, this->_r2); } template<std::integral T> constexpr value_type convert(T v) const noexcept(NO_EXCEPT) { if(v == 1) return this->one; using common_type = std::common_type_t<T, value_type>; const common_type mod2 = static_cast<common_type>(this->_mod << 1); if(v > 0 && static_cast<common_type>(v) >= mod2) { v %= mod2; } if constexpr(std::signed_integral<T>) { if(v < 0) { if(static_cast<common_type>(-v) >= mod2) v %= mod2; if(v < 0) v += mod2; } } return this->multiply(v, this->_r2); } constexpr value_type revert(const value_type v) const noexcept(NO_EXCEPT) { return this->normalize(this->reduce(v)); } }; } using montgomery_reduction_32bit = internal::montgomery_reduction<u32, u64>; using montgomery_reduction_64bit = internal::montgomery_reduction<u64, u128>; using arbitrary_montgomery_reduction_32bit = internal::arbitrary_montgomery_reduction<u32, u64>; using arbitrary_montgomery_reduction_64bit = internal::arbitrary_montgomery_reduction<u64, u128>; }
/* [end]: numeric/modular/montgomery_reduction.hpp*/
namespace lib { namespace internal { template<class T> concept modint_family = numeric<T> && has_static_one<T> && has_static_zero<T> && requires (T v, i64 p, typename T::value_type x) { { v.pow(p) } -> std::same_as<T>; { v.inv() } -> std::same_as<T>; { T::raw(x) } -> std::same_as<T>; { v.val() } -> std::same_as<typename T::value_type>; { T::mod() } -> std::same_as<typename T::value_type>; { T::max() } -> std::same_as<typename T::value_type>; T::digits; T::context::dynamic; }; template<class T> concept dynamic_modint_family = modint_family<T> && T::context::dynamic && requires (typename T::value_type v) { T::set_mod(v); }; template<class T> concept static_modint_family = modint_family<T> && (!T::context::dynamic); template<class T> concept modular_reduction = std::default_initializable<T> && std::constructible_from<T, typename T::value_type> && requires (T v, typename T::value_type x, i64 p) { typename T::value_type; T::digits; { T::max() } -> std::same_as<typename T::value_type>; { v.mod() } -> std::same_as<typename T::value_type>; { v.reduce(x) } -> std::same_as<typename T::value_type>; { v.add(x, x) } -> std::same_as<typename T::value_type>; { v.subtract(x, x) } -> std::same_as<typename T::value_type>; { v.multiply(x, x) } -> std::same_as<typename T::value_type>; { v.multiply(x, x) } -> std::same_as<typename T::value_type>; { v.pow(x, p) } -> std::same_as<typename T::value_type>; { v.convert_raw(x) } -> std::same_as<typename T::value_type>; { v.convert(x) } -> std::same_as<typename T::value_type>; { v.revert(x) } -> std::same_as<typename T::value_type>; { v.equal(x, x) } -> std::same_as<bool>; }; template<class T> concept modular_context = requires { typename T::reduction; typename T::value_type; { T::get() } -> std::same_as<std::add_lvalue_reference_t<std::add_const_t<typename T::reduction>>>; }; } template<internal::modular_reduction Reduction, typename Reduction::value_type Mod> struct static_modular_context { using reduction = Reduction; using value_type = typename reduction::value_type; static constexpr bool dynamic = false; private: using context = static_modular_context; static inline constexpr reduction _reduction = reduction(Mod); public: static constexpr const reduction& get() noexcept(NO_EXCEPT) { return context::_reduction; } }; template<internal::modular_reduction Reduction, i64 Id> struct dynamic_modular_context { using reduction = Reduction; using value_type = typename reduction::value_type; static constexpr bool dynamic = true; private: using context = dynamic_modular_context; static inline reduction _reduction; public: static constexpr void set_mod(const value_type mod) noexcept(NO_EXCEPT) { context::_reduction = reduction(mod); } static constexpr const reduction& get() noexcept(NO_EXCEPT) { return context::_reduction; } }; template<internal::modular_context> struct modint; template<u32 Mod> using static_builtin_modular_context_32bit = static_modular_context<builtin_reduction_32bit, Mod>; template<u64 Mod> using static_builtin_modular_context_64bit = static_modular_context<builtin_reduction_64bit, Mod>; template<u32 Mod> using static_barrett_modular_context_32bit = static_modular_context<barrett_reduction_32bit, Mod>; template<u64 Mod> using static_barrett_modular_context_64bit = static_modular_context<barrett_reduction_64bit, Mod>; template<u32 Mod> using static_montgomery_modular_context_32bit = static_modular_context<montgomery_reduction_32bit, Mod>; template<u64 Mod> using static_montgomery_modular_context_64bit = static_modular_context<montgomery_reduction_64bit, Mod>; template<u32 Mod> using static_arbitrary_montgomery_modular_context_32bit = static_modular_context<arbitrary_montgomery_reduction_32bit, Mod>; template<u64 Mod> using static_arbitrary_montgomery_modular_context_64bit = static_modular_context<arbitrary_montgomery_reduction_64bit, Mod>; template<u32 Mod> using static_binary_modular_context_32bit = static_modular_context<binary_reduction_32bit, Mod>; template<u64 Mod> using static_binary_modular_context_64bit = static_modular_context<binary_reduction_64bit, Mod>; template<u128 Mod> using static_binary_modular_context_128bit = static_modular_context<binary_reduction_128bit, Mod>; template<u32 Mod> using static_builtin_modint_32bit = modint<static_builtin_modular_context_32bit<Mod>>; template<u64 Mod> using static_builtin_modint_64bit = modint<static_builtin_modular_context_64bit<Mod>>; template<u32 Mod> using static_barrett_modint_32bit = modint<static_barrett_modular_context_32bit<Mod>>; template<u64 Mod> using static_barrett_modint_64bit = modint<static_barrett_modular_context_64bit<Mod>>; template<u32 Mod> using static_montgomery_modint_32bit = modint<static_montgomery_modular_context_32bit<Mod>>; template<u64 Mod> using static_montgomery_modint_64bit = modint<static_montgomery_modular_context_64bit<Mod>>; template<u32 Mod> using static_arbitrary_montgomery_modint_32bit = modint<static_arbitrary_montgomery_modular_context_32bit<Mod>>; template<u64 Mod> using static_arbitrary_montgomery_modint_64bit = modint<static_arbitrary_montgomery_modular_context_64bit<Mod>>; template<u32 Mod> using static_binary_modint_32bit = modint<static_binary_modular_context_32bit<Mod>>; template<u64 Mod> using static_binary_modint_64bit = modint<static_binary_modular_context_64bit<Mod>>; template<u128 Mod> using static_binary_modint_128bit = modint<static_binary_modular_context_128bit<Mod>>; template<i64 Id> using dynamic_builtin_modular_context_32bit = dynamic_modular_context<builtin_reduction_32bit, Id>; template<i64 Id> using dynamic_builtin_modular_context_64bit = dynamic_modular_context<builtin_reduction_64bit, Id>; template<i64 Id> using dynamic_barrett_modular_context_32bit = dynamic_modular_context<barrett_reduction_32bit, Id>; template<i64 Id> using dynamic_barrett_modular_context_64bit = dynamic_modular_context<barrett_reduction_64bit, Id>; template<i64 Id> using dynamic_montgomery_modular_context_32bit = dynamic_modular_context<montgomery_reduction_32bit, Id>; template<i64 Id> using dynamic_montgomery_modular_context_64bit = dynamic_modular_context<montgomery_reduction_64bit, Id>; template<i64 Id> using dynamic_arbitrary_montgomery_modular_context_32bit = dynamic_modular_context<arbitrary_montgomery_reduction_32bit, Id>; template<i64 Id> using dynamic_arbitrary_montgomery_modular_context_64bit = dynamic_modular_context<arbitrary_montgomery_reduction_64bit, Id>; template<i64 Id> using dynamic_binary_modular_context_32bit = dynamic_modular_context<binary_reduction_32bit, Id>; template<i64 Id> using dynamic_binary_modular_context_64bit = dynamic_modular_context<binary_reduction_64bit, Id>; template<i64 Id> using dynamic_binary_modular_context_128bit = dynamic_modular_context<binary_reduction_128bit, Id>; template<i64 Id> using dynamic_builtin_modint_32bit = modint<dynamic_builtin_modular_context_32bit<Id>>; template<i64 Id> using dynamic_builtin_modint_64bit = modint<dynamic_builtin_modular_context_64bit<Id>>; template<i64 Id> using dynamic_barrett_modint_32bit = modint<dynamic_barrett_modular_context_32bit<Id>>; template<i64 Id> using dynamic_barrett_modint_64bit = modint<dynamic_barrett_modular_context_64bit<Id>>; template<i64 Id> using dynamic_montgomery_modint_32bit = modint<dynamic_montgomery_modular_context_32bit<Id>>; template<i64 Id> using dynamic_montgomery_modint_64bit = modint<dynamic_montgomery_modular_context_64bit<Id>>; template<i64 Id> using dynamic_arbitrary_montgomery_modint_32bit = modint<dynamic_arbitrary_montgomery_modular_context_32bit<Id>>; template<i64 Id> using dynamic_arbitrary_montgomery_modint_64bit = modint<dynamic_arbitrary_montgomery_modular_context_64bit<Id>>; template<i64 Id> using dynamic_binary_modint_32bit = modint<dynamic_binary_modular_context_32bit<Id>>; template<i64 Id> using dynamic_binary_modint_64bit = modint<dynamic_binary_modular_context_64bit<Id>>; template<i64 Id> using dynamic_binary_modint_128bit = modint<dynamic_binary_modular_context_128bit<Id>>; template<u32 Mod> using static_modint_32bit = static_builtin_modint_32bit<Mod>; template<u64 Mod> using static_modint_64bit = static_builtin_modint_64bit<Mod>; using modint998244353 = static_modint_32bit<998244353>; using modint1000000007 = static_modint_32bit<1000000007>; using modint_32 = dynamic_barrett_modint_32bit<-1>; using modint_64 = dynamic_barrett_modint_64bit<-1>; template<const unsigned Val, const unsigned Mod = 998244353> const lib::static_modint_32bit<Mod> MINT = Val; template<const unsigned Val, const unsigned Mod = 998244353> const unsigned INV = lib::static_modint_32bit<Mod>{ Val }.inv().val(); template<const unsigned Val, const unsigned Mod = 998244353> const int SINV = lib::static_modint_32bit<Mod>{ Val }.inv().val(); }
/* [end]: numeric/modular/modint_interface.hpp*/
namespace lib { template<std::derived_from<std::ios_base> Source = std::istream> struct input_adapter { using source_type = Source; private: template<class T> requires std::derived_from<T, std::valarray<typename T::value_type>> auto _set(lib::internal::resolving_rank<6>, T& val) noexcept(NO_EXCEPT) -> int { this->operator()(ALL(val)); return 0; } template<class T> requires requires (source_type& in, T& val) { in >> val; } int _set(lib::internal::resolving_rank<5>, T& val) noexcept(NO_EXCEPT) { *this->in >> val; return 0; } template<std::ranges::range T> int _set(lib::internal::resolving_rank<4>, T& val) noexcept(NO_EXCEPT) { this->operator()(std::ranges::begin(val), std::ranges::end(val)); return 0; } template<class T> requires requires (T& val) { val.first; val.second; } int _set(lib::internal::resolving_rank<3>, T& val) noexcept(NO_EXCEPT) { *this >> val.first >> val.second; return 0; } template<class T> requires requires (T& val) { std::get<0>(val); } int _set(lib::internal::resolving_rank<2>, T& val) noexcept(NO_EXCEPT) { tuple_for_each([this](auto&& v) { *this >> v; }, val); return 0; } template<lib::internal::modint_family T> int _set(lib::internal::resolving_rank<1>, T& val) noexcept(NO_EXCEPT) { std::int64_t v; std::cin >> v; val = { v }; return 0; } template<class T> requires requires { typename T::value_type; } int _set(lib::internal::resolving_rank<0>, T& val) noexcept(NO_EXCEPT) { typename T::value_type v; *this >> v; val = { v }; return 0; } protected: template<class T> source_type *set(T& val) noexcept(NO_EXCEPT) { this->_set(lib::internal::resolving_rank<10>{}, val); return this->in; } template<class T> source_type *set(T&& _val) noexcept(NO_EXCEPT) { T val = _val; this->_set(lib::internal::resolving_rank<10>{}, val); return this->in; } public: using char_type = typename source_type::char_type; source_type *in; input_adapter(source_type *_in = &std::cin) noexcept(NO_EXCEPT) : in(_in) {} template<class T> inline input_adapter& operator>>(T&& s) noexcept(NO_EXCEPT) { this->set(std::forward<T>(s)); return *this; } template<class T> inline T one() noexcept(NO_EXCEPT) { T val; *this >> val; return val; } template<class T> inline auto& operator()(T& val) noexcept(NO_EXCEPT) { *this >> val; return *this; } template<class T, class... Args> inline auto& operator()(T& head, Args&... tail) noexcept(NO_EXCEPT) { *this >> head; this->operator()(tail...); return *this; } template<std::input_or_output_iterator I, std::sentinel_for<I> S> inline auto& operator()(I first, S last) noexcept(NO_EXCEPT) { for(I itr=first; itr!=last; ++itr) *this >> *itr; return *this; } }; }
/* [end]: adapter/internal/input.hpp*/
/* [begin]: adapter/internal/output.hpp */
#include <iomanip>
namespace lib { template<class Destination = std::ostream> struct output_adapter { using destination_type = Destination; private: template<class T> requires requires (destination_type& out, T& val) { out << val; } int _put(lib::internal::resolving_rank<5>, T&& val) noexcept(NO_EXCEPT) { *this->out << std::forward<T>(val); return 0; } template<class T> requires requires (T&& val) { val.val(); } int _put(lib::internal::resolving_rank<4>, T&& val) noexcept(NO_EXCEPT) { this->put(val.val()); return 0; } template<std::ranges::range T> int _put(lib::internal::resolving_rank<3>, T&& val) noexcept(NO_EXCEPT) { (*this)(std::ranges::begin(val), std::ranges::end(val), false); return 0; } template<class T> requires requires (T&& val) { val.first; val.second; } int _put(lib::internal::resolving_rank<2>, T&& val) noexcept(NO_EXCEPT) { *this << val.first, this->put_separator(); *this << val.second; return 0; } template<class T> requires requires (T&& val) { std::get<0>(val); } auto _put(lib::internal::resolving_rank<1>, T&& val) noexcept(NO_EXCEPT) { std::apply([this](const auto&... args) constexpr { ((*this << args, this->put_separator()), ...); }, std::forward<T>(val)); return 0; } template<std::input_or_output_iterator T> int _put(lib::internal::resolving_rank<0>, T&& val) noexcept(NO_EXCEPT) { (*this)(*std::forward<T>(val)); return 0; } protected: template<class T> destination_type* put(T&& val) noexcept(NO_EXCEPT){ this->_put(lib::internal::resolving_rank<10>{}, std::forward<T>(val)); return this->out; } public: using char_type = typename destination_type::char_type; static constexpr auto sendl = std::endl<char_type,std::char_traits<char_type>>; static constexpr auto sflush = std::flush<char_type,std::char_traits<char_type>>; protected: using sfunc_type = std::remove_const_t<decltype(output_adapter::sendl)>; public: using separator_type = std::variant<std::string,sfunc_type>; destination_type *out; separator_type endline; separator_type separator; protected: void put_separator() noexcept(NO_EXCEPT) { if(this->separator.index() == 0) *this->out << std::get<std::string>(this->separator); if(this->separator.index() == 1) *this->out << std::get<sfunc_type>(this->separator); } void put_endline() noexcept(NO_EXCEPT) { if(this->endline.index() == 0) *this->out << std::get<std::string>(this->endline); if(this->endline.index() == 1) *this->out << std::get<sfunc_type>(this->endline); } public: template<class Terminator = std::string, class Separator = std::string> output_adapter(destination_type *des = &std::cout, Terminator endl = "\n", Separator sep = " ") noexcept(NO_EXCEPT) : out(des), endline(endl), separator(sep) { *this << std::fixed << std::setprecision(20); } inline auto& seekp(const typename destination_type::off_type off, const std::ios_base::seekdir dir = std::ios_base::cur) noexcept(NO_EXCEPT) { this->out->seekp(off, dir); return *this; }; template<class T> inline output_adapter& operator<<(T&& s) noexcept(NO_EXCEPT){ this->put(std::forward<T>(s)); return *this; } template<class T = std::string> inline auto& operator()(T&& val = "") noexcept(NO_EXCEPT){ *this << std::forward<T>(val), this->put_endline(); return *this; } template<class T, class ...Args> inline auto& operator()(T&& head, Args&& ...tail) noexcept(NO_EXCEPT){ *this << std::forward<T>(head), this->put_separator(); (*this)(std::forward<Args>(tail)...); return *this; } template<std::forward_iterator I, std::sentinel_for<I> S> inline auto& operator()(I first, S last, const bool terminate = true) noexcept(NO_EXCEPT) { for(I itr=first; itr!=last;) { *this << *itr; if(++itr == last) { if(terminate) this->put_endline(); } else this->put_separator(); } return *this; } template<class T> inline auto& operator()(const std::initializer_list<T> vals) noexcept(NO_EXCEPT) { std::vector wrapped(vals.begin(), vals.end()); (*this)(wrapped.begin(), wrapped.end()); return *this; } template<class T0, class T1> inline auto& conditional(const bool cond, const T0& a, const T1& b) noexcept(NO_EXCEPT) { if(cond) (*this)(a); else (*this)(b); return *this; } inline auto& yesno(const bool cond) noexcept(NO_EXCEPT) { if(cond) this->yes(); else this->no(); return *this; } inline auto yes() noexcept(NO_EXCEPT) { *this->out << "Yes"; this->put_endline(); return *this; } inline auto no() noexcept(NO_EXCEPT) { *this->out << "No"; this->put_endline(); return *this; } }; }
/* [end]: adapter/internal/output.hpp*/
namespace lib { lib::input_adapter _input; lib::output_adapter _print; }
#define input lib::_input
#define print lib::_print
/* [end]: adapter/io.hpp*/
/* [begin]: adapter/set.hpp */
#include <set>
#include <unordered_set>
namespace lib { namespace internal { template<class Set> struct set_wrapper : Set { using Set::Set; using value_type = typename Set::value_type; using size_type = internal::size_t; inline std::optional<typename Set::iterator> remove(const typename Set::key_type& key) noexcept(NO_EXCEPT) { const auto itr = this->Set::find(key); if(itr == this->Set::end()) return {}; return this->erase(itr); } inline auto min_element() const noexcept(NO_EXCEPT) { return this->begin(); } inline auto max_element() const noexcept(NO_EXCEPT) { return std::prev(this->end()); } inline auto min() const noexcept(NO_EXCEPT) { return *this->begin(); } inline auto max() const noexcept(NO_EXCEPT) { return *std::prev(this->end()); } inline auto& pop_min() noexcept(NO_EXCEPT) { this->erase(this->begin()); return *this; } inline auto& pop_max() noexcept(NO_EXCEPT) { this->erase(std::prev(this->end())); return *this; } inline auto kth_smallest_element(const size_type k) const noexcept(NO_EXCEPT) { return std::ranges::next(this->begin(), k); } inline auto kth_largest_element(const size_type k) const noexcept(NO_EXCEPT) { return std::ranges::prev(this->end(), k + 1); } inline auto kth_smallest(const size_type k) const noexcept(NO_EXCEPT) { return *std::ranges::next(this->begin(), k); } inline auto kth_largest(const size_type k) const noexcept(NO_EXCEPT) { return *std::ranges::prev(this->end(), k + 1); } inline auto& pop_kth_smallest(const size_type k) const noexcept(NO_EXCEPT) { return this->erase(std::ranges::next(this->begin(), k)); return *this; } inline auto& pop_kth_largest(const size_type k) const noexcept(NO_EXCEPT) { return this->erase(std::ranges::prev(this->end(), k + 1)); return *this; } auto next_element(const typename Set::key_type& key, const size_type _count = 0) const noexcept(NO_EXCEPT) { size_type count = std::abs(_count); auto itr = this->lower_bound(key); const auto begin = this->begin(), end = this->end(); if(itr == end) return this->end(); if(itr == begin) return this->begin(); while(count--) { if(_count < 0) if(itr-- == begin) return this->begin(); if(_count > 0) if(++itr == end) return this->end(); } return itr; } auto prev_element(const typename Set::key_type& key, const size_type _count = 0) const noexcept(NO_EXCEPT) { size_type count = std::abs(_count); auto itr = this->upper_bound(key); const auto begin = this->begin(), end = this->end(); if(itr == end) return this->end(); if(itr-- == begin) return this->begin(); while(count--) { if(_count < 0) if(itr-- == begin) return this->begin(); if(_count > 0) if(++itr == end) return this->end(); } return itr; } std::optional<typename Set::value_type> next(const typename Set::key_type& key, size_type count = 0) const noexcept(NO_EXCEPT) { auto itr = this->lower_bound(key); const auto end = this->end(); if(itr == end) return {}; while(count--) if(++itr == end) return {}; return { *itr }; } std::optional<typename Set::value_type> prev(const typename Set::key_type& key, size_type count = 0) const noexcept(NO_EXCEPT) { auto itr = this->upper_bound(key); const auto begin = this->begin(); if(itr-- == begin) return {}; while(count--) if(itr-- == begin) return {}; return { *itr }; } friend inline set_wrapper operator|(set_wrapper s, const set_wrapper& t) noexcept(NO_EXCEPT) { s.merge(t); return s; } friend inline set_wrapper operator&(const set_wrapper& s, const set_wrapper& t) noexcept(NO_EXCEPT) { set_wrapper res; std::ranges::set_intersection(s, t, std::inserter(res, res.end())); return res; } friend inline set_wrapper operator^(const set_wrapper& s, const set_wrapper& t) noexcept(NO_EXCEPT) { set_wrapper res; std::ranges::set_symmetric_difference(s, t, std::inserter(res, res.end())); return res; } template<std::equality_comparable_with<value_type> V> friend inline set_wrapper operator<=(const V& val, const set_wrapper& st) noexcept(NO_EXCEPT) { return st.contains(val); } template<std::equality_comparable_with<value_type> V> friend inline set_wrapper operator>=(const set_wrapper& st, const V&val) noexcept(NO_EXCEPT) { return val <= st; } template<std::equality_comparable_with<value_type> V> friend inline set_wrapper operator<(const V& val, const set_wrapper& st) noexcept(NO_EXCEPT) { return val <= st; } template<std::equality_comparable_with<value_type> V> friend inline set_wrapper operator>(const set_wrapper& st, const V& val) noexcept(NO_EXCEPT) { return val <= st; } friend inline set_wrapper operator<=(const set_wrapper& s, const set_wrapper& t) noexcept(NO_EXCEPT) { if(s.size() > t.size()) return false; return std::ranges::all_of(s, [&](auto&& v) { return t.contains(v); }); } friend inline set_wrapper operator>=(const set_wrapper& s, const set_wrapper& t) noexcept(NO_EXCEPT) { return t <= s; } friend inline set_wrapper operator<(const set_wrapper& s, const set_wrapper& t) noexcept(NO_EXCEPT) { return s <= t; } friend inline set_wrapper operator>(const set_wrapper& s, const set_wrapper& t) noexcept(NO_EXCEPT) { return t <= s; } }; } template<class... Args> using set = internal::set_wrapper<std::set<Args...>>; template<class... Args> using unordered_set = internal::set_wrapper<std::unordered_set<Args...>>; template<class... Args> using multiset = internal::set_wrapper<std::multiset<Args...>>; template<class... Args> using unordered_multiset = internal::set_wrapper<std::unordered_multiset<Args...>>; }
/* [end]: adapter/set.hpp*/
/* [begin]: adapter/map.hpp */
#include <map>
#include <unordered_map>
namespace lib { namespace internal { template<class Map> using map_wrapper_base = set_wrapper<Map>; template<class Map> struct map_wrapper : map_wrapper_base<Map> { private: using base = map_wrapper_base<Map>; public: using base::base; using mapped_type = typename base::mapped_type; using key_type = typename base::key_type; protected: using default_func_noarg_type = std::function<mapped_type(void)>; using default_func_type = std::function<mapped_type(key_type)>; int _default_type = 0; mapped_type _default_val = {}; default_func_noarg_type _default_func_noarg; default_func_type _default_func; inline mapped_type _get_default(const key_type& key) const noexcept(NO_EXCEPT) { if(this->_default_type == 0) return this->_default_val; if(this->_default_type == 1) return this->_default_func_noarg(); if(this->_default_type == 2) return this->_default_func(key); else assert(false); } public: inline auto& set_default(const mapped_type& val) noexcept(NO_EXCEPT) { this->_default_val = val; this->_default_type = 0; return *this; } inline auto& set_default(const default_func_noarg_type func) noexcept(NO_EXCEPT) { this->_default_func_noarg = func; this->_default_type = 1; return *this; } inline auto& set_default(const default_func_type func) noexcept(NO_EXCEPT) { this->_default_func = func; this->_default_type = 2; return *this; } inline auto& operator[](const key_type& key) noexcept(NO_EXCEPT) { auto found = this->base::find(key); if(found == this->base::end()) return this->base::emplace(key, this->_get_default(key)).first->second; return found->second; } inline auto& operator()(const key_type& key) noexcept(NO_EXCEPT) { return this->base::operator[](key); } inline std::optional<mapped_type> get(const key_type& key) const noexcept(NO_EXCEPT) { const auto found = this->base::find(key); if(found == this->base::end()) return {}; return found->second; } }; } template<class... Args> using map = internal::map_wrapper<std::map<Args...>>; template<class... Args> using unordered_map = internal::map_wrapper<std::unordered_map<Args...>>; template<class... Args> using multimap = internal::map_wrapper<std::multimap<Args...>>; template<class... Args> using unordered_multimap = internal::map_wrapper<std::unordered_multimap<Args...>>; }
/* [end]: adapter/map.hpp*/
/* [begin]: adapter/array.hpp */
namespace lib { template<class T, int N> using array = internal::extended_container<std::array<T,N>>; }
/* [end]: adapter/array.hpp*/
/* [begin]: adapter/multi_container.hpp */
namespace lib { namespace internal { namespace multi_container_impl { template<class container> struct base : container { using container::container; protected: inline void _validate_index(__attribute__ ((unused)) const internal::size_t index) const noexcept(NO_EXCEPT) { assert(0 <= index and index < (internal::size_t)this->size()); } inline internal::size_t _positivize_index(const internal::size_t x) const noexcept(NO_EXCEPT) { return x < 0 ? this->size() + x : x; } }; } } template<class T, const unsigned int RANK, template<class...> class container = valarray> struct multi_container : internal::multi_container_impl::base<container<multi_container<T,RANK-1,container>>> { using internal::multi_container_impl::base<container<multi_container<T,RANK-1,container>>>::base; template<std::integral Head, class... Tail> multi_container(const Head head, const Tail... tail) noexcept(NO_EXCEPT) : internal::multi_container_impl::base<container<multi_container<T,RANK-1,container>>>(head, multi_container<T,RANK-1,container>(tail...)) { assert(head >= 0); } template<class Head, class... Tail> T& operator()(const Head _head, const Tail... tail) noexcept(NO_EXCEPT) { static_assert(std::is_integral_v<Head>, "index must be integral"); const internal::size_t head = this->_positivize_index(_head); this->_validate_index(head); return (*this)[head](tail...); } template<class Head, class... Tail> const T& operator()(const Head _head, const Tail... tail) const noexcept(NO_EXCEPT) { static_assert(std::is_integral_v<Head>, "index must be integral"); const internal::size_t head = this->_positivize_index(_head); this->_validate_index(head); return (*this)[head](tail...); } }; template<class T, template<class...> class container> struct multi_container<T,1,container> : internal::multi_container_impl::base<container<T>> { using internal::multi_container_impl::base<container<T>>::base; template<class... Args> multi_container(const Args&... args) noexcept(NO_EXCEPT) : internal::multi_container_impl::base<container<T>>(args...) {} T& operator()(const internal::size_t _index) noexcept(NO_EXCEPT) { const internal::size_t index = this->_positivize_index(_index); this->_validate_index(index); return (*this)[index]; } const T& operator()(const internal::size_t _index) const noexcept(NO_EXCEPT) { const internal::size_t index = this->_positivize_index(_index); this->_validate_index(index); return (*this)[index]; } }; template<class T, template<class...> class container> struct multi_container<T,0,container> { static_assert(internal::EXCEPTION<T>, "invalid rank: 0, should be 1 or more"); }; }
/* [end]: adapter/multi_container.hpp*/
/* [begin]: adapter/range_extractor.hpp */
namespace lib { template<class Container> struct range_extractor : Container { using size_type = typename Container::size_type; using value_type = typename Container::value_type; protected: using default_func_noarg_type = std::function<value_type(void)>; using default_func_type = std::function<value_type(size_type)>; size_type _begin = 0; size_type _end; int _default_type = 0; value_type _default_val = {}; default_func_noarg_type _default_func_noarg; default_func_type _default_func; inline static value_type _tmp; inline value_type _get_default(const size_type key) const noexcept(NO_EXCEPT) { if(this->_default_type == 0) return this->_default_val; if(this->_default_type == 1) return this->_default_func_noarg(); if(this->_default_type == 2) return this->_default_func(key); else assert(false); } public: template<class... Args> explicit range_extractor(const Args&... args) noexcept(NO_EXCEPT) : Container(args...) { this->_begin = 0; this->_end = this->size(); } inline auto& extract(const size_type begin, const size_type end) noexcept(NO_EXCEPT) { assert(begin <= end); this->_begin = begin, this->_end = end; return *this; } inline auto& set_default(const value_type& val) noexcept(NO_EXCEPT) { this->_default_val = val; this->_default_type = 0; return *this; } inline auto& set_default(const default_func_noarg_type func) noexcept(NO_EXCEPT) { this->_default_func_noarg = func; this->_default_type = 1; return *this; } inline auto& set_default(const default_func_type func) noexcept(NO_EXCEPT) { this->_default_func = func; this->_default_type = 2; return *this; } inline auto& operator[](const size_type pos) noexcept(NO_EXCEPT) { if(pos < this->_begin or this->_end <= pos) return range_extractor::_tmp = this->_get_default(pos); return this->Container::operator[](pos); } inline const auto& operator[](const size_type pos) const noexcept(NO_EXCEPT) { if(pos < this->_begin or this->_end <= pos) return range_extractor::_tmp = this->_get_default(pos); return this->Container::operator[](pos); } inline auto& operator()(const size_type pos) noexcept(NO_EXCEPT) { return this->Container::operator[](pos); } inline const auto& operator()(const size_type pos) const noexcept(NO_EXCEPT) { return this->Container::operator[](pos); } inline std::optional<value_type> get(const size_type pos) const noexcept(NO_EXCEPT) { if(pos < this->_begin or this->_end <= pos) return {}; return this->Container::operator[](pos); } }; }
/* [end]: adapter/range_extractor.hpp*/
/* [begin]: adapter/virtual_map.hpp */
namespace lib { template<class> struct virtual_combined_map {}; template<class Mapped, class... Keys> struct virtual_combined_map<Mapped(Keys...)> { using key_type = std::tuple<Keys...>; using mapped_type = Mapped; using value_type = std::pair<key_type,mapped_type>; protected: std::function<Mapped(Keys...)> _f; public: virtual_combined_map() = default; template<class F> explicit virtual_combined_map(F&& f) noexcept(NO_EXCEPT) : _f(f) {}; inline const auto* get_functor() const noexcept(NO_EXCEPT) { return this->_f; } inline auto* get_functor() noexcept(NO_EXCEPT) { return this->_f; } template<class F> inline auto& set_functor(F&& f) const noexcept(NO_EXCEPT) { return this->_f = f; } inline mapped_type operator()(const Keys&... key) const noexcept(NO_EXCEPT) { return this->_f(key...); } inline mapped_type operator[](const key_type& key) const noexcept(NO_EXCEPT) { return std::apply(this->_f, key); } }; template<class Key, class Mapped> struct virtual_map : virtual_combined_map<Mapped(Key)> { using key_type = Key; using mapped_type = Mapped; using value_type = std::pair<key_type,mapped_type>; using virtual_combined_map<mapped_type(key_type)>::virtual_combined_map; inline mapped_type operator[](const key_type& key) const noexcept(NO_EXCEPT) { return this->_f(key); } }; };
/* [end]: adapter/virtual_map.hpp*/
/* [end]: include/adapters.hpp*/
/* [begin]: iterable/applied.hpp */
namespace lib { template<std::ranges::input_range R, class F> inline R applied(R v, F func) noexcept(NO_EXCEPT) { func(std::ranges::begin(v), std::ranges::end(v)); return v; } template<std::ranges::input_range R> inline auto sorted(R&& v) noexcept(NO_EXCEPT) { return applied(v, std::ranges::sort); } template<std::ranges::input_range R> inline auto reversed(R v) noexcept(NO_EXCEPT) { return applied(v, std::ranges::reverse); } }
/* [end]: iterable/applied.hpp*/
/* [begin]: iterable/adjacent_difference.hpp */
namespace lib { template<class T, class container = valarray<T>> struct adjacent_difference : container { public: explicit adjacent_difference() noexcept(NO_EXCEPT) {} template< std::input_iterator I, std::sentinel_for<I> S, class Operator = std::minus<T> > explicit adjacent_difference(I first, S last, const bool remove_first = true, const Operator op = std::minus<T>{}) noexcept(NO_EXCEPT) { this->resize(std::ranges::distance(first, last)); std::vector<T> diff(this->size()); std::adjacent_difference(first, last, std::ranges::begin(diff), op); if(remove_first) diff.erase(std::ranges::begin(diff)); this->assign(std::ranges::begin(diff), std::ranges::end(diff)); } }; template<std::input_iterator I, std::sentinel_for<I> S> explicit adjacent_difference(I, S) -> adjacent_difference<typename std::iterator_traits<I>::value_type>; }
/* [end]: iterable/adjacent_difference.hpp*/
/* [begin]: iterable/accumulation.hpp */
namespace lib { template<class T, class container = valarray<T>> struct accumulation : container { using size_type = internal::size_t; protected: inline size_type _positivize_index(const size_type x) const noexcept(NO_EXCEPT) { return x < 0 ? std::size(*this) + x : x; } public: accumulation() noexcept(NO_EXCEPT) {} template<std::ranges::input_range R, class Operator = std::plus<T>> requires std::regular_invocable<Operator, T, T> accumulation(R&& range, const T& head = {}, Operator&& op = std::plus<T>{}) noexcept(NO_EXCEPT) { this->resize(std::ranges::size(range) + 1); std::exclusive_scan(ALL(range), std::begin(*this), head, op); const auto back = std::prev(std::end(*this)); *back = op(*std::prev(back), *std::prev(std::ranges::end(range))); } template< std::input_iterator I, std::sentinel_for<I> S, class Operator = std::plus<T> > accumulation(I first, S last, const T& head = {}, Operator&& op = std::plus<T>{}) noexcept(NO_EXCEPT) { this->resize(std::distance(first, last) + 1); std::exclusive_scan(first, last, std::begin(*this), head, op); const auto back = std::prev(std::end(*this)); *back = op(*std::prev(back), *std::prev(last)); } template<class Operator = std::minus<T>> requires std::regular_invocable<Operator, T, T> inline T operator()(size_type left, size_type right, Operator&& op = std::minus<T>{}) const noexcept(NO_EXCEPT) { left = _positivize_index(left), right = _positivize_index(right); assert(0 <= left and left <= right and right < (size_type)std::size(*this)); return op((*this)[right], (*this)[left]); } }; template<std::input_iterator I, std::sentinel_for<I> S> explicit accumulation(I, S) -> accumulation<typename std::iterator_traits<I>::value_type>; template<std::ranges::input_range R> explicit accumulation(R&&) -> accumulation<typename std::ranges::range_value_t<R>>; template<class T, class container = valarray<valarray<T>>, class Operator = std::plus<T>> struct accumulation_2d : container { using size_type = internal::size_t; protected: inline size_type _positivize_index(const size_type x) const noexcept(NO_EXCEPT) { return x < 0 ? std::size(*this) + x : x; } Operator _op; public: explicit accumulation_2d() noexcept(NO_EXCEPT) {} template<std::input_iterator I, std::sentinel_for<I> S> explicit accumulation_2d(I first, S last, const T head = T{}, const Operator op = std::plus<T>{}) noexcept(NO_EXCEPT) : _op(op) { const size_type h = static_cast<size_type>(std::distance(first, last)); const size_type w = static_cast<size_type>(std::distance(std::begin(*first), std::end(*first))); { auto row = first; this->assign(h+1, head); (*this)[0].assign(w+1, head); REP(i, h) { assert(w == std::distance(std::begin(*row), std::end(*row))); (*this)[i+1].assign(w+1, head); REP(j, w) (*this)[i+1][j+1] = first[i][j]; ++row; } } FOR(i, 1, h) FOR(j, w) (*this)[i][j] = op((*this)[i][j], (*this)[i-1][j]); FOR(i, h) FOR(j, 1, w) (*this)[i][j] = op((*this)[i][j], (*this)[i][j-1]); } template<class Rev = std::minus<T>> inline T operator()(size_type a, size_type b, size_type c, size_type d, const Rev rev = std::minus<T>{}) const noexcept(NO_EXCEPT) { a = _positivize_index(a), b = _positivize_index(b); c = _positivize_index(c), d = _positivize_index(d); assert(0 <= a and a <= b and b < (size_type)std::size(*this)); assert(0 <= c and c <= d and d < (size_type)std::size((*this)[0])); return this->_op(rev((*this)[b][d], this->_op((*this)[a][d], (*this)[b][c])), (*this)[a][c]); } template<class Rev = std::minus<T>> inline T operator()(const std::pair<size_type,size_type> p, const std::pair<size_type,size_type> q, const Rev rev = std::minus<T>{}) const noexcept(NO_EXCEPT) { return this->operator()(p.first, p.second, q.first, q.second, rev); } }; template<std::input_iterator I, std::sentinel_for<I> S> explicit accumulation_2d(I, S) -> accumulation_2d< typename std::iterator_traits<typename std::ranges::iterator_t<typename std::iterator_traits<I>::value_type>>::value_type >; template<std::input_iterator I, std::sentinel_for<I> S> explicit accumulation_2d(I, S) -> accumulation_2d< typename std::iterator_traits<typename lib::internal::iterator_t<typename std::iterator_traits<I>::value_type>>::value_type >; }
/* [end]: iterable/accumulation.hpp*/
/* [begin]: iterable/compressed.hpp */
namespace lib { template<class T, std::ranges::range Container = valarray<internal::size_t>> struct compressed : Container { using size_type = internal::size_t; using value_type = T; std::vector<value_type> values; public: explicit compressed() noexcept(NO_EXCEPT) = default; template<std::input_iterator I, std::sized_sentinel_for<I> S> compressed(I first, S last) noexcept(NO_EXCEPT) { this->values.assign(first, last); std::ranges::sort(ALL(this->values)); this->values.erase(std::unique(ALL(this->values)), std::ranges::end(this->values)); this->resize(std::ranges::distance(first, last)); { auto itr = std::ranges::begin(*this); auto e = first; for(; e!=last; ++itr, ++e) *itr = this->rank(*e); } } template<std::ranges::input_range R> compressed(R&& range) noexcept(NO_EXCEPT) : compressed(ALL(range)) {} inline size_type rank_sup() const { return static_cast<size_type>(this->values.size()); } inline size_type rank(const value_type& val) const noexcept(NO_EXCEPT) { return static_cast<size_type>( std::ranges::distance(std::ranges::begin(this->values), std::ranges::lower_bound(this->values, val)) ); } inline size_type rank2(const value_type& val) const noexcept(NO_EXCEPT) { return static_cast<size_type>( std::ranges::distance(std::ranges::begin(this->values), std::ranges::upper_bound(this->values, val)) ) - 1; } inline value_type value(const size_type rank) const noexcept(NO_EXCEPT) { return this->values[rank]; } inline value_type operator()(const internal::size_t val) const noexcept(NO_EXCEPT) { return this->values[val]; } }; template<std::input_iterator I, std::sized_sentinel_for<I> S> explicit compressed(I, S) -> compressed<typename std::iterator_traits<I>::value_type>; template<std::ranges::input_range R> explicit compressed(R&&) -> compressed<typename std::ranges::range_value_t<R>>; }
/* [end]: iterable/compressed.hpp*/
/* [begin]: iterable/counter.hpp */
/* [begin]: internal/auto_holder.hpp */
namespace lib { namespace internal { namespace auto_holder_impl { template<class T, bool DYNAMIC, class = std::enable_if_t<std::is_integral_v<T> && not DYNAMIC>> constexpr int _holder_type(resolving_rank<2>) { return 0; } template<class T, bool> constexpr auto _holder_type(resolving_rank<1>) -> decltype(std::unordered_set<T>(), 0){ return 1; } template<class T, bool> constexpr int _holder_type(resolving_rank<0>) { return 2; } template<class T, bool DYNAMIC = false> constexpr int holder_type = _holder_type<T,DYNAMIC>(resolving_rank<10>{}); template<class,class,int> struct holder {}; template<class T, class U> struct holder<T,U,0> : valarray<U> { using valarray<U>::valarray; }; template<class T, class U> struct holder<T,U,1> : unordered_map<T,U> { using unordered_map<T,U>::unordered_map; template<class V> inline void assign(const internal::size_t, const V& v) { this->set_default(v); } }; template<class T, class U> struct holder<T,U,2> : map<T,U> { using map<T,U>::map; template<class V> inline void assign(const internal::size_t, const V& v) { this->set_default(v); } }; } } template<class T, class U> struct auto_holder : internal::auto_holder_impl::holder<T,U,internal::auto_holder_impl::holder_type<T>> { using internal::auto_holder_impl::holder<T,U,internal::auto_holder_impl::holder_type<T>>::holder; }; template<class T, class U> struct dynamic_auto_holder : internal::auto_holder_impl::holder<T,U,internal::auto_holder_impl::holder_type<T,true>> { using internal::auto_holder_impl::holder<T,U,internal::auto_holder_impl::holder_type<T,true>>::holder; }; }
/* [end]: internal/auto_holder.hpp*/
namespace lib { template<class T, class container = dynamic_auto_holder<T,internal::size_t>> struct counter : container { counter() noexcept(NO_EXCEPT) = default; template<std::input_iterator I, std::sentinel_for<I> S> counter(I first, S last) noexcept(NO_EXCEPT) { for(auto itr=first; itr!=last; ++itr) ++(*this)[*itr]; } template<std::ranges::input_range R> explicit counter(R&& range) noexcept(NO_EXCEPT) : counter(ALL(range)) {} }; template<std::input_iterator I, std::sentinel_for<I> S> explicit counter(I, S) -> counter<std::iter_value_t<I>>; template<std::ranges::input_range R> explicit counter(R) -> counter<std::ranges::range_value_t<R>>; }
/* [end]: iterable/counter.hpp*/
/* [begin]: iterable/inverse.hpp */
namespace lib { template<class T, class V = vector<internal::size_t>, class container = dynamic_auto_holder<T,V>> struct inverse : container { explicit inverse() noexcept(NO_EXCEPT) {} template<class R> inverse(R&& range) noexcept(NO_EXCEPT) : inverse(std::begin(range), std::end(range)) {} template<std::input_iterator I, std::sentinel_for<I> S> inverse(I first, S last) noexcept(NO_EXCEPT) { for(auto itr=first; itr!=last; ++itr) (*this)[*itr].push_back(static_cast<typename V::value_type>(std::distance(first,itr))); } }; template<std::input_iterator I, std::sentinel_for<I> S> explicit inverse(I, S) -> inverse<typename std::iterator_traits<I>::value_type>; template<class R> explicit inverse(R&&) -> inverse<typename R::value_type>; }
/* [end]: iterable/inverse.hpp*/
/* [begin]: iterable/run_length_encoding.hpp */
namespace lib { template<class T, class container = vector<std::pair<T,internal::size_t>>> struct run_length : container { run_length() noexcept(NO_EXCEPT) = default; template<std::input_iterator I, std::sentinel_for<I> S> run_length(I first, S last) noexcept(NO_EXCEPT) { this->clear(); typename container::value_type::second_type cnt = 0; for(I itr=first, prev=itr; itr!=last; ++itr) { if(*prev != *itr) this->emplace_back(*prev, cnt), cnt = 0; ++cnt; prev = itr; } this->emplace_back(*std::ranges::prev(last), cnt); } template<std::ranges::input_range R> explicit run_length(R&& range) : run_length(ALL(range)) {}; }; template<std::input_iterator I, std::sentinel_for<I> S> run_length(I, S) -> run_length<std::iter_value_t<I>>; template<std::ranges::range R> explicit run_length(R&& range) -> run_length<std::ranges::range_value_t<R>>; }
/* [end]: iterable/run_length_encoding.hpp*/
/* [begin]: graph/shortest_path.hpp */
/* [begin]: graph/internal/bfs.hpp */
#include <queue>
/* [begin]: structure/graph.hpp */
/* [begin]: structure/grid.hpp */
namespace lib { namespace internal { namespace grid_impl { template<class T> struct interface { }; template<class T> struct container_base : virtual interface<T> { private: size_t _h, _w; protected: inline void _validate_index(__attribute__ ((unused)) const size_t i, __attribute__ ((unused)) const size_t j) const noexcept(NO_EXCEPT) { assert(0 <= i and i < this->height()); assert(0 <= j and j < this->width()); } inline size_t _positivize_row_index(const size_t x) const noexcept(NO_EXCEPT) { return x < 0 ? this->height() + x : x; } inline size_t _positivize_col_index(const size_t x) const noexcept(NO_EXCEPT) { return x < 0 ? this->width() + x : x; } public: container_base() = default; container_base(const size_t h, const size_t w) noexcept(NO_EXCEPT) : _h(h), _w(w) {} virtual void resize(const size_t h, const size_t w) noexcept(NO_EXCEPT) /*override*/ { this->_h = h, this->_w = w; } inline size_t height() const noexcept(NO_EXCEPT) /*override*/ { return this->_h; } inline size_t width() const noexcept(NO_EXCEPT) /*override*/ { return this->_w; } inline size_t id(const size_t i, const size_t j) const noexcept(NO_EXCEPT) /*override*/ { const size_t _i = this->_positivize_row_index(i); const size_t _j = this->_positivize_col_index(j); this->_validate_index(_i, _j); return _i * this->width() + _j; } inline size_t id(const std::pair<size_t,size_t>& p) const noexcept(NO_EXCEPT) /*override*/ { return this->id(p.first, p.second); } inline std::pair<size_t,size_t> pos(const size_t id) const noexcept(NO_EXCEPT) /*override*/ { return { id / this->width(), id % this->width() }; } }; template<class T, class Row, class base> struct container : base, container_base<T>, virtual interface<T> { container(const size_t n = 0) noexcept(NO_EXCEPT) : container(n, n) {} container(const size_t h, const size_t w, const T &val = T{}) noexcept(NO_EXCEPT) : base(h, Row(w, val)), container_base<T>(h, w) {} container(const std::initializer_list<Row> init_list) noexcept(NO_EXCEPT) : base(init_list) { const size_t rows = std::distance(ALL(init_list)); const size_t first_cols = init_list.begin()->size(); if constexpr (DEV_ENV) { ITR(init_row, init_list) assert((size_t)init_row.size() == first_cols); } this->container_base<T>::resize(rows, first_cols); } inline void assign(const container &source) noexcept(NO_EXCEPT) { this->resize(source.height(), source.width()); this->base::assign(ALL(source)); } inline void assign(const size_t h, const size_t w, const T &val = T{}) noexcept(NO_EXCEPT) /*override*/ { this->container_base<T>::resize(h, w); this->base::resize(h); ITRR(row, *this) row.assign(w, val); } inline void resize(const size_t h, const size_t w) noexcept(NO_EXCEPT) /*override*/ { this->container_base<T>::resize(h, w); this->base::resize(h); ITRR(row, *this) row.resize(w); } inline T& operator()(const size_t i, const size_t j) noexcept(NO_EXCEPT) /*override*/ { const size_t _i = this->_positivize_row_index(i); const size_t _j = this->_positivize_col_index(j); this->_validate_index(_i, _j); return (*this)[_i][_j]; } inline const T& operator()(const size_t i, const size_t j) const noexcept(NO_EXCEPT) /*override*/ { const size_t _i = this->_positivize_row_index(i); const size_t _j = this->_positivize_col_index(j); this->_validate_index(_i, _j); return (*this)[_i][_j]; } inline T& operator()(const std::pair<size_t,size_t>& p) noexcept(NO_EXCEPT) /*override*/ { return this->operator()(p.first, p.second); } inline const T& operator()(const std::pair<size_t,size_t>& p) const noexcept(NO_EXCEPT) /*override*/ { return this->operator()(p.first, p.second); } }; template<class T, class base = std::vector<T>> struct unfolded_container : base, container_base<T>, virtual interface<T> { unfolded_container(size_t n = 0) noexcept(NO_EXCEPT) : unfolded_container(n, n) {} unfolded_container(const size_t h, const size_t w, const T &val = T{}) noexcept(NO_EXCEPT) : base(h*w, val), container_base<T>(h, w) {} unfolded_container(std::initializer_list<std::initializer_list<T>> init_list) noexcept(NO_EXCEPT) { const size_t rows = std::distance(init_list.begin(), init_list.end()); const size_t first_cols = init_list.begin()->size(); this->resize(rows, first_cols); for(auto index=0, itr=init_list.begin(), itr_end=init_list.end(); itr!=itr_end; ++itr) { assert((size_t)itr->size() == first_cols); for(auto v=itr->begin(), v_end=itr->end(); v!=v_end; ++v) (*this)[index++] = *v; } } inline void assign(const unfolded_container &source) noexcept(NO_EXCEPT) { this->resize(source.height(), source.width()); this->base::assign(ALL(source)); } inline void assign(const size_t h, const size_t w, const T &val = T{}) noexcept(NO_EXCEPT) /*override*/ { this->container_base<T>::resize(h, w); this->base::assign(h*w, val); } inline void resize(const size_t h, const size_t w) noexcept(NO_EXCEPT) /*override*/ { this->container_base<T>::resize(h, w); this->base::resize(h*w); } inline T& operator()(const size_t i, const size_t j) noexcept(NO_EXCEPT) /*override*/ { const size_t _i = this->_positivize_row_index(i); const size_t _j = this->_positivize_col_index(j); return this->operator[](this->id(_i, _j)); } inline T& operator()(const std::pair<size_t,size_t>& p) noexcept(NO_EXCEPT) /*override*/ { return this->operator()(this->id(p.first, p.second)); } inline const T& operator()(const std::pair<size_t,size_t>& p) const noexcept(NO_EXCEPT) /*override*/ { return this->operator()(this->id(p.first, p.second)); } }; } template<class T, class container> struct grid_core : container, virtual grid_impl::interface<T> { using container::container; using size_type = internal::size_t; enum class invert_direction { vertical, horizontal }; enum class rotate_direction { counter_clockwise, clockwise }; inline bool is_valid(const size_type i, const size_type j) const noexcept(NO_EXCEPT) { return 0 <= i and i < this->height() and 0 <= j and j < this->width(); } template<std::input_iterator I, std::sentinel_for<I> S> inline auto vicinities(const size_type i, const size_type j, I dirs_first, S dirs_last) const noexcept(NO_EXCEPT) { std::vector<std::pair<size_type,size_type>> res; REP(itr, dirs_first, dirs_last) { const size_type ii = i + itr->first, jj = j + itr->second; if(this->is_valid(ii, jj)) res.emplace_back(ii, jj); } return res; } template<class I, class C> inline auto vicinities(const std::pair<size_type,size_type>& p, const C dirs) const noexcept(NO_EXCEPT) { return this->vicinities(p.first, p.second, ALL(dirs)); } inline auto vicinities4(const size_type i, const size_type j) const noexcept(NO_EXCEPT) { return this->vicinities(i, j, ALL(DIRS4)); } inline auto vicinities4(const std::pair<size_type,size_type>& p) const noexcept(NO_EXCEPT) { return this->vicinities(p.first, p.second, ALL(DIRS4)); } inline auto vicinities8(const size_type i, const size_type j) const noexcept(NO_EXCEPT) { return this->vicinities(i, j, ALL(DIRS8)); } inline auto vicinities8(const std::pair<size_type,size_type>& p) const noexcept(NO_EXCEPT) { return this->vicinities(p.first, p.second, ALL(DIRS8)); } template<invert_direction DIRECTION = invert_direction::vertical> inline grid_core& invert() noexcept(NO_EXCEPT) { grid_core res(this->height(), this->width()); REP(i, this->height()) REP(j, this->width()) { if constexpr (DIRECTION == invert_direction::vertical) { res(i,j) = (*this)(this->height()-i-1,j); } else { res(i,j) = (*this)(i, this->width()-j-1); } } this->assign(res); return *this; } template<rotate_direction DIRECTION = rotate_direction::clockwise> inline grid_core& rotate(const size_t k) noexcept(NO_EXCEPT) { grid_core res = *this; REP(i, k) { res = res.rotate<DIRECTION>(); } this->assign(res); return *this; } template<rotate_direction DIRECTION = rotate_direction::clockwise> inline grid_core& rotate() noexcept(NO_EXCEPT) { grid_core res(this->width(), this->height()); REP(i, this->width()) REP(j, this->height()) { if constexpr (DIRECTION == rotate_direction::clockwise) { res(i,j) = (*this)(this->height()-j-1,i); } else { res(i,j) = (*this)(j,this->width()-i-1); } } this->assign(res); return *this; } inline grid_core& transpose() noexcept(NO_EXCEPT) { grid_core res(this->width(), this->height()); REP(i, this->width()) REP(j, this->height()) { res(i,j) = (*this)(j,i); } this->assign(res); return *this; } }; } template<class T, class Row = vector<T>, class base = vector<Row>> using grid = internal::grid_core<T,internal::grid_impl::container<T,Row,base>>; template<class T, class Row = valarray<T>, class base = valarray<Row>> using valgrid = internal::grid_core<T,internal::grid_impl::container<T,Row,base>>; template<class T, class base = vector<T>> using unfolded_grid = internal::grid_core<T,internal::grid_impl::unfolded_container<T,base>>; template<class T, class base = valarray<T>> using unfolded_valgrid = internal::grid_core<T,internal::grid_impl::unfolded_container<T,base>>; }
/* [end]: structure/grid.hpp*/
/* [begin]: data_structure/disjoint_set_union.hpp */
namespace lib { struct dsu { using size_type = internal::size_t; private: size_type _n, _group_count; mutable std::vector<size_type> _parent_or_size; public: dsu() noexcept(NO_EXCEPT) : _n(0) {} explicit dsu(const size_type n) noexcept(NO_EXCEPT) : _n(n), _group_count(n), _parent_or_size(n, -1) {} inline size_type size() const noexcept(NO_EXCEPT) { return this->_n; } inline size_type group_count() const noexcept(NO_EXCEPT) { return this->_group_count; } inline size_type merge(const size_type a, const size_type b) noexcept(NO_EXCEPT) { assert(0 <= a && a < _n); assert(0 <= b && b < _n); size_type x = this->leader(a), y = this->leader(b); if (x == y) return x; --this->_group_count; if (-this->_parent_or_size[x] < -this->_parent_or_size[y]) std::swap(x, y); this->_parent_or_size[x] += this->_parent_or_size[y]; this->_parent_or_size[y] = x; return x; } inline bool same(const size_type a, const size_type b) const noexcept(NO_EXCEPT) { assert(0 <= a && a < _n); assert(0 <= b && b < _n); return this->leader(a) == this->leader(b); } inline size_type leader(const size_type a) const noexcept(NO_EXCEPT) { assert(0 <= a && a < _n); if (_parent_or_size[a] < 0) return a; return _parent_or_size[a] = this->leader(_parent_or_size[a]); } inline size_type size(const size_type a) const noexcept(NO_EXCEPT) { assert(0 <= a && a < _n); return -_parent_or_size[this->leader(a)]; } inline vector<vector<size_type>> groups() const noexcept(NO_EXCEPT) { vector<size_type> leader_buf(_n), group_size(_n); for (size_type i = 0; i < _n; i++) { leader_buf[i] = this->leader(i); group_size[leader_buf[i]]++; } vector<vector<size_type>> result(_n); for (size_type i = 0; i < _n; i++) { result[i].reserve(group_size[i]); } for (size_type i = 0; i < _n; i++) { result[leader_buf[i]].push_back(i); } result.erase( remove_if(result.begin(), result.end(), [&](const auto& v) { return v.empty(); }), result.end() ); return result; } }; }
/* [end]: data_structure/disjoint_set_union.hpp*/
namespace lib { namespace internal { namespace graph_impl { template<class Node,class Cost> struct edge { private: inline static internal::size_t unique() noexcept(NO_EXCEPT) { static internal::size_t id = 0; return id++; } public: using cost_type = Cost; using node_type = Node; using size_type = internal::size_t; const size_type id = unique(); const node_type from, to; const Cost cost; const size_type index = 0; edge(const node_type u, const node_type v, const Cost w = 1, const size_type index = 0) noexcept(NO_EXCEPT) : from(u), to(v), cost(w), index(index) {} operator node_type() const noexcept(NO_EXCEPT) { return this->to; } inline node_type opposite(const node_type v) const noexcept(NO_EXCEPT) { if(this->from == v) return this->to; if(this->to == v) return this->from; assert(false); } auto _debug() const { return std::make_tuple(index, from, to, cost); }; friend bool operator==(const edge& lhs, const edge& rhs) noexcept(NO_EXCEPT) { return lhs.id == rhs.id; } friend bool operator!=(const edge& lhs, const edge& rhs) noexcept(NO_EXCEPT) { return lhs.id != rhs.id; } }; template<class NodeType, class CostType, class EdgeCollector> struct regular_base : EdgeCollector { using EdgeCollector::EdgeCollector; using size_type = size_t; using node_type = NodeType; using cost_type = CostType; inline size_type size() const noexcept(NO_EXCEPT) { return static_cast<size_type>(this->EdgeCollector::size()); } }; template<class NodeType, class CostType, class Map> struct virtual_base : Map { public: using size_type = internal::size_t; using node_type = NodeType; using cost_type = CostType; protected: size_type _n = 0; public: template<class F> explicit virtual_base(const size_type n, const F f) noexcept(NO_EXCEPT) : Map(f), _n(n) {} inline size_type size() const noexcept(NO_EXCEPT) { return this->_n; } }; template<class NodeType, class CostType, template<class...> class Container> struct regular_core : regular_base<NodeType,CostType,Container<vector<internal::graph_impl::edge<NodeType,CostType>>>> { using size_type = internal::size_t; using node_type = NodeType; using cost_type = CostType; using edge_type = typename internal::graph_impl::edge<node_type,cost_type>; enum class edge_kind { undirected, directed }; private: using base = regular_base<NodeType,CostType,Container<vector<edge_type>>>; size_type _directed_edge_count = 0, _undirected_edge_count = 0; Container<edge_type> _edges; Container<size_type> _out_degs, _in_degs; protected: inline void _add_edge(const size_type u, const size_type v, const cost_type w, const size_type k) noexcept(NO_EXCEPT) { this->operator[](u).emplace_back(u, v, w, k); ++_out_degs[u], ++_in_degs[v]; ++this->_directed_edge_count; } public: explicit regular_core() noexcept(NO_EXCEPT) : base() {} explicit regular_core(const size_type n = 0) noexcept(NO_EXCEPT) : base(n), _out_degs(n), _in_degs(n) {} inline auto& clear() noexcept(NO_EXCEPT) { this->base::clear(), this->_out_degs.clear(), this->_in_degs.clear(); return *this; } inline auto& resize(const size_type n) noexcept(NO_EXCEPT) { this->base::resize(n), this->_out_degs.resize(n), this->_in_degs.resize(n); return *this; } inline const auto& edges() const noexcept(NO_EXCEPT) { return this->_edges; } inline const auto& edge(const size_type k) const noexcept(NO_EXCEPT) { return this->_edges[k]; } inline const auto& degrees() const noexcept(NO_EXCEPT) { return this->_in_degs; } inline const auto& degree(const size_type k) const noexcept(NO_EXCEPT) { return this->_in_degs[k]; } inline const auto& in_degrees() const noexcept(NO_EXCEPT) { return this->_in_degs; } inline const auto& in_degree(const size_type k) const noexcept(NO_EXCEPT) { return this->_in_degs[k]; } inline const auto& out_degrees() const noexcept(NO_EXCEPT) { return this->_out_degs; } inline const auto& out_degree(const size_type k) const noexcept(NO_EXCEPT) { return this->_out_degs[k]; } inline size_type directed_edges_count() const noexcept(NO_EXCEPT) { return this->_directed_edge_count; } template<class R = valgrid<bool>> inline auto make_has_edges() const noexcept(NO_EXCEPT) { R res(this->size(), this->size(), false); REP(i, this->size()) ITR(j, this->operator[](i)) res[i][j] = true; return res; } template<const bool SELF_ZERO = true, class T = cost_type, class R = valgrid<T>> inline auto make_initial_distance_matrix() const noexcept(NO_EXCEPT) { R res(this->size(), this->size(), numeric_limits<T>::arithmetic_infinity()); if constexpr(SELF_ZERO) REP(i, this->size()) res[i][i] = 0; REP(i, this->size()) ITR(j, this->operator[](i)) res[i][j] = j.cost; return res; } template<const bool SELF_ZERO = true, class T = cost_type, class R = valgrid<T>> inline auto make_distance_matrix() const noexcept(NO_EXCEPT) { R res = this->make_initial_distance_matrix<SELF_ZERO,T,R>(); REP(k, this->size()) REP(i, this->size()) REP(j, this->size()) { chmin(res[i][j], res[i][k] + res[k][j]); } return res; } template<const edge_kind EDGE_TYPE = edge_kind::directed> inline void add_edge(const node_type u, const node_type v, const cost_type w = 1) noexcept(NO_EXCEPT) { assert(0 <= u and u < this->size()), assert(0 <= v and v < this->size()); const size_type k = this->edges().size(); this->_edges.emplace_back(u, v, w, k); this->_add_edge(u, v, w, k); if constexpr(EDGE_TYPE == edge_kind::undirected) this->_add_edge(v, u, w, k); } inline void add_edge_bidirectionally(const node_type u, const node_type v, const cost_type w = 1) noexcept(NO_EXCEPT) { this->add_edge<edge_kind::undirected>(u, v, w); } template<bool WEIGHTED = false, bool ONE_ORIGIN = true, const edge_kind EDGE_TYPE = edge_kind::directed, class Stream = input_adapter<>> void inline read(const size_type edges, Stream *const ist = &_input) noexcept(NO_EXCEPT) { REP(edges) { node_type u, v; cost_type w = 1; *ist >> u >> v; if(ONE_ORIGIN) --u, --v; if(WEIGHTED) *ist >> w; this->add_edge<EDGE_TYPE>(u, v, w); } } template<bool WEIGHTED = false, bool ONE_ORIGIN = true, class Stream = input_adapter<>> void inline read_bidirectionally(const size_type edges, Stream *const ist = &_input) noexcept(NO_EXCEPT) { REP(edges) { node_type u, v; cost_type w = 1; *ist >> u >> v; if(ONE_ORIGIN) --u, --v; if(WEIGHTED) *ist >> w; this->add_edge<edge_kind::undirected>(u, v, w); } } }; template<class Graph> struct mixin : Graph { using Graph::Graph; using size_type = typename Graph::size_type; using node_type = typename Graph::node_type; using cost_type = typename Graph::cost_type; inline size_type vertices() const noexcept(NO_EXCEPT) { return static_cast<size_type>(this->Graph::size()); } public: template<class Cost = cost_type, class Dist, class Prev = std::nullptr_t> inline void distances_without_cost(const node_type&, Dist *const, Prev *const = nullptr, const node_type& = {}, const node_type& = {}) const noexcept(NO_EXCEPT); template<class Cost = cost_type> inline auto_holder<node_type,Cost> distances_without_cost(const node_type) const noexcept(NO_EXCEPT); template<class Cost = cost_type, class Dist, class Prev = std::nullptr_t> inline void distances_with_01cost(const node_type&, Dist *const, Prev *const = nullptr, const node_type& = {}, const node_type& = {}) const noexcept(NO_EXCEPT); template<class Cost = cost_type> inline auto_holder<node_type,Cost> distances_with_01cost(const node_type) const noexcept(NO_EXCEPT); template<class Cost = cost_type, class Dist, class Prev = std::nullptr_t> inline void distances_with_cost(const node_type&, Dist *const, Prev *const = nullptr, const node_type& = {}, const node_type& = {}) const noexcept(NO_EXCEPT); template<class Cost = cost_type> inline auto_holder<node_type,Cost> distances_with_cost(const node_type) const noexcept(NO_EXCEPT); inline bool sort_topologically(vector<node_type> *const ) const noexcept(NO_EXCEPT); inline bool sort_topologically() const noexcept(NO_EXCEPT); template<class> inline bool sort_topologically_with_priority(vector<node_type> *const) const noexcept(NO_EXCEPT); template<class> inline bool sort_topologically_with_priority() const noexcept(NO_EXCEPT); inline size_type minimum_paph_cover_size_as_dag() const noexcept(NO_EXCEPT); template<class Cost = cost_type> inline Cost minimum_spanning_tree(mixin *const = nullptr) const noexcept(NO_EXCEPT); template<class Cost = cost_type> inline Cost maximum_spanning_tree(mixin *const = nullptr) const noexcept(NO_EXCEPT); inline dsu components() const noexcept(NO_EXCEPT); inline bool is_bipartite() const noexcept(NO_EXCEPT); template<bool = false, class G, class U = char> inline void parse_grid(const G&, U = '.') noexcept(NO_EXCEPT); template< std::input_iterator I0, std::input_iterator I1, std::sentinel_for<I0> S0, std::sentinel_for<I1> S1 > inline cost_type build_manhattan_mst(I0, S0, I1, S1) noexcept(NO_EXCEPT); }; } } template<class Cost = std::int64_t, class Node = internal::size_t, template<class...> class Container = vector> struct graph : internal::graph_impl::mixin<internal::graph_impl::regular_core<Node,Cost,Container>> { private: using base = internal::graph_impl::mixin<internal::graph_impl::regular_core<Node,Cost,Container>>; public: using size_type = typename base::size_type; using node_type = typename base::node_type; using edge = typename internal::graph_impl::edge<node_type,Cost>; explicit graph(const size_type n = 0) noexcept(NO_EXCEPT) : base(n) {} }; template<class Node = internal::size_t, class Cost = std::int64_t, class Edges = virtual_map<Node,vector<typename internal::graph_impl::edge<Node,Cost>>>> struct virtual_graph : internal::graph_impl::mixin<internal::graph_impl::virtual_base<Node,Cost,Edges>> { private: using base = internal::graph_impl::mixin<internal::graph_impl::virtual_base<Node,Cost,Edges>>; public: using size_type = typename base::size_type; using edge = typename internal::graph_impl::edge<Node,Cost>; private: size_type _n = 0; public: template<class F> explicit virtual_graph(const F f, const size_type n = 0) noexcept(NO_EXCEPT) : base(n, f), _n(n) {} }; }
/* [end]: structure/graph.hpp*/
template<class Graph> template<class Cost, class Dist, class Prev> void lib::internal::graph_impl::mixin<Graph>::distances_without_cost( const node_type& s, Dist *const dist, Prev *const prev, const node_type& unreachable, const node_type& root ) const noexcept(NO_EXCEPT) { dist->assign(this->size(), lib::numeric_limits<Cost>::arithmetic_infinity()); if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->assign(this->size(), unreachable); std::queue<node_type> que; que.push(s), dist->operator[](s) = 0; if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->operator[](s) = root; while(not que.empty()) { const node_type v = que.front(); que.pop(); ITR(nv, this->operator[](v)) { if(dist->operator[](nv.to) < lib::numeric_limits<Cost>::arithmetic_infinity()) { continue; } dist->operator[](nv.to) = dist->operator[](v) + 1; if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->operator[](nv.to) = v; que.push(nv.to); } } } template<class Graph> template<class Cost> lib::auto_holder<typename lib::internal::graph_impl::mixin<Graph>::node_type,Cost> lib::internal::graph_impl::mixin<Graph>::distances_without_cost(const node_type s) const noexcept(NO_EXCEPT) { lib::auto_holder<typename lib::internal::graph_impl::mixin<Graph>::node_type,Cost> dist; this->distances_without_cost<Cost>(s, &dist); return dist; }
/* [end]: graph/internal/bfs.hpp*/
/* [begin]: graph/internal/01bfs.hpp */
#include <deque>
template<class Graph> template<class Cost, class Dist, class Prev> void lib::internal::graph_impl::mixin<Graph>::distances_with_01cost( const node_type& s, Dist *const dist, Prev *const prev, const node_type& unreachable, const node_type& root ) const noexcept(NO_EXCEPT) { std::deque<node_type> que; dist->assign(this->size(), lib::numeric_limits<Cost>::arithmetic_infinity()); if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->assign(this->size(), unreachable); que.push_back(s), dist->operator[](s) = 0; if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->operator[](s) = root; while(not que.empty()) { const auto u = que.front(); que.pop_front(); const Cost d = dist->operator[](u); ITR(e, (*this)[u]) { const node_type v = e.to; const auto cost = e.cost; if(dist->operator[](v) <= d + cost) continue; dist->operator[](v) = d + cost; if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->operator[](v) = u; if(cost) que.push_back(v); else que.push_front(v); } } } template<class Graph> template<class Cost> lib::auto_holder<typename lib::internal::graph_impl::mixin<Graph>::node_type,Cost> lib::internal::graph_impl::mixin<Graph>::distances_with_01cost(const node_type s) const noexcept(NO_EXCEPT) { lib::auto_holder<typename lib::internal::graph_impl::mixin<Graph>::node_type,Cost> dist; this->distances_with_01cost<Cost>(s, &dist); return dist; }
/* [end]: graph/internal/01bfs.hpp*/
/* [begin]: graph/internal/dijkstra.hpp */
template<class Graph> template<class Cost, class Dist, class Prev> void lib::internal::graph_impl::mixin<Graph>::distances_with_cost( const node_type& s, Dist *const dist, Prev *const prev, const node_type& unreachable, const node_type& root ) const noexcept(NO_EXCEPT) { using state = std::pair<Cost,node_type>; std::priority_queue<state,std::vector<state>,std::greater<state>> que; dist->assign(this->size(), lib::numeric_limits<Cost>::arithmetic_infinity()); if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->assign(this->size(), unreachable); que.emplace(0, s), dist->operator[](s) = 0; if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->operator[](s) = root; while(not que.empty()) { const auto [d, u] = que.top(); que.pop(); if(dist->operator[](u) < d) continue; ITR(e, this->operator[](u)) { const node_type v = e.to; const auto cost = e.cost; if(dist->operator[](v) <= d + cost) continue; dist->operator[](v) = d + cost; if constexpr(not std::is_same_v<Prev,std::nullptr_t>) prev->operator[](v) = u; que.emplace(dist->operator[](v), v); } } } template<class Graph> template<class Cost> lib::auto_holder<typename lib::internal::graph_impl::mixin<Graph>::node_type,Cost> lib::internal::graph_impl::mixin<Graph>::distances_with_cost(const node_type s) const noexcept(NO_EXCEPT) { lib::auto_holder<typename lib::internal::graph_impl::mixin<Graph>::node_type,Cost> dist; this->distances_with_cost<Cost>(s, &dist); return dist; }
/* [end]: graph/internal/dijkstra.hpp*/
namespace lib { template<class Node, class Prev, class Res> void restore_shortest_path(Node v, const Prev& prev, Res *const res) { res->clear(); while(v >= 0) { res->emplace_back(v); v = prev[v]; } } template<class Node, class Prev, class Res = lib::vector<Node>> lib::vector<Node> restore_shortest_path(Node v, const Prev& prev) { lib::vector<Node> res; restore_shortest_path(v, prev, &res); return res; } }
/* [end]: graph/shortest_path.hpp*/
/* [begin]: graph/parse_grid.hpp */
template<class Graph> template<bool REV, class G, class U> void lib::internal::graph_impl::mixin<Graph>::parse_grid(const G &grid, U available) noexcept(NO_EXCEPT) { this->clear(); this->resize(grid.height() * grid.width()); REP(i, grid.height()) REP(j, grid.width()) { if(REV ^ (grid(i, j) != available)) continue; if(i+1 < grid.height() and (REV ^ (grid(i+1, j) == available))) { this->template add_edge_bidirectionally(grid.id(i, j), grid.id(i+1, j)); } if(j+1 < grid.width() and (REV ^ (grid(i, j+1) == available))) { this->template add_edge_bidirectionally(grid.id(i, j), grid.id(i, j+1)); } } }
/* [end]: graph/parse_grid.hpp*/
/* [begin]: graph/spanning_tree.hpp */
/* [begin]: ac-library/atcoder/dsu */
/* [begin]: ac-library/atcoder/dsu.hpp */
#ifndef ATCODER_DSU_HPP
#define ATCODER_DSU_HPP 1
namespace atcoder { struct dsu { public: dsu() : _n(0) {} explicit dsu(int n) : _n(n), parent_or_size(n, -1) {} int merge(int a, int b) { assert(0 <= a && a < _n); assert(0 <= b && b < _n); int x = leader(a), y = leader(b); if (x == y) return x; if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y); parent_or_size[x] += parent_or_size[y]; parent_or_size[y] = x; return x; } bool same(int a, int b) { assert(0 <= a && a < _n); assert(0 <= b && b < _n); return leader(a) == leader(b); } int leader(int a) { assert(0 <= a && a < _n); if (parent_or_size[a] < 0) return a; return parent_or_size[a] = leader(parent_or_size[a]); } int size(int a) { assert(0 <= a && a < _n); return -parent_or_size[leader(a)]; } std::vector<std::vector<int>> groups() { std::vector<int> leader_buf(_n), group_size(_n); for (int i = 0; i < _n; i++) { leader_buf[i] = leader(i); group_size[leader_buf[i]]++; } std::vector<std::vector<int>> result(_n); for (int i = 0; i < _n; i++) { result[i].reserve(group_size[i]); } for (int i = 0; i < _n; i++) { result[leader_buf[i]].push_back(i); } result.erase( std::remove_if(result.begin(), result.end(), [&](const std::vector<int>& v) { return v.empty(); }), result.end()); return result; } private: int _n; std::vector<int> parent_or_size; }; }
#endif
/* [end]: ac-library/atcoder/dsu.hpp*/
/* [end]: ac-library/atcoder/dsu*/
namespace lib { namespace internal { namespace graph_impl { template<class G, class cost_type, class Compare> cost_type kruskal(const G& graph, const Compare compare, G *const mst = nullptr) noexcept(NO_EXCEPT) { atcoder::dsu ds(graph.size()); std::vector<std::tuple<typename G::edge_type::cost_type,size_t,size_t>> edges; REP(u, graph.size()) ITR(e, graph[u]) { edges.emplace_back(e.cost, u, e.to); } std::sort(ALL(edges), compare); if(mst) mst->clear(), mst->resize(graph.size()); cost_type res = cost_type{}; ITR(w, u, v, edges) { if(not ds.same(u, v)) { ds.merge(u, v); if(mst) mst->add_edge_bidirectionally(u, v, w); res += w; } } return res; } } } template<class Graph> template<class cost_type> cost_type internal::graph_impl::mixin<Graph>::minimum_spanning_tree(internal::graph_impl::mixin<Graph> *const mst) const noexcept(NO_EXCEPT) { return internal::graph_impl::kruskal<internal::graph_impl::mixin<Graph>,cost_type,std::less<std::tuple<cost_type,size_t,size_t>>>(*this, {}, mst); } template<class Graph> template<class cost_type> inline cost_type internal::graph_impl::mixin<Graph>::maximum_spanning_tree(internal::graph_impl::mixin<Graph> *const mst) const noexcept(NO_EXCEPT) { return internal::graph_impl::kruskal<internal::graph_impl::mixin<Graph>,cost_type,std::greater<std::tuple<cost_type,size_t,size_t>>>(*this, {}, mst); } }
/* [end]: graph/spanning_tree.hpp*/
/* [begin]: graph/topological_sort.hpp */
template<class Graph> template<class comparer> bool lib::internal::graph_impl::mixin<Graph>::sort_topologically_with_priority(lib::vector<node_type> *const sorted) const noexcept(NO_EXCEPT) { sorted->clear(); std::vector<size_type> in_degs(this->size()); ITR(v, *this) ITR(e, v) ++in_degs[e.to]; std::priority_queue<node_type,std::vector<node_type>,comparer> que; REP(i, this->size()) if(in_degs[i] == 0) que.push(i); while(not que.empty()) { const node_type v = que.top(); que.pop(); ITR(u, (*this)[v]) if(!(--in_degs[u.to])) que.push(u.to); sorted->push_back(v); } return sorted->size() == this->size(); } template<class Graph> template<class comparer> bool lib::internal::graph_impl::mixin<Graph>::sort_topologically_with_priority() const noexcept(NO_EXCEPT) { lib::vector<node_type> vs; return this->sort_topologically_with_priority<comparer>(&vs); } template<class Graph> bool lib::internal::graph_impl::mixin<Graph>::sort_topologically(lib::vector<node_type> *const sorted) const noexcept(NO_EXCEPT) { sorted->clear(); std::vector<size_type> in_degs(this->size()); ITR(v, *this) ITR(e, v) ++in_degs[e.to]; std::queue<node_type> que; REP(i, this->size()) if(in_degs[i] == 0) que.push(i); while(not que.empty()) { const node_type v = que.front(); que.pop(); ITR(u, (*this)[v]) if(!(--in_degs[u.to])) que.push(u.to); sorted->push_back(v); } return sorted->size() == this->size(); } template<class Graph> bool lib::internal::graph_impl::mixin<Graph>::sort_topologically() const noexcept(NO_EXCEPT) { std::vector<node_type> vs; return this->sort_topologically(&vs); }
/* [end]: graph/topological_sort.hpp*/
/* [begin]: graph/connected_components.hpp */
template<class Graph> lib::dsu lib::internal::graph_impl::mixin<Graph>::components() const noexcept(NO_EXCEPT) { lib::dsu dsu(this->vertices()); ITR(edges, *this) ITR(_id, u, v, _w, _idx, edges) { dsu.merge(u, v); } return dsu; }
/* [end]: graph/connected_components.hpp*/
/* [begin]: graph/is_bipartite.hpp */
template<class Graph> bool lib::internal::graph_impl::mixin<Graph>::is_bipartite() const noexcept(NO_EXCEPT) { using color_type = int; std::valarray<color_type> color(0, this->vertices()); REP(s, this->vertices()) { if(color[s] != 0) continue; std::stack<size_type> stk; stk.push(s); color[s] = 1; while(not stk.empty()) { auto v = stk.top(); stk.pop(); auto c = color[v]; ITR(nv, this->operator[](v)) { if(color[nv] == c) return false; if(color[nv] == 0) { color[nv] = -c; stk.push(nv); } } } } return true; }
/* [end]: graph/is_bipartite.hpp*/
/* [begin]: graph/lowest_common_ancestor.hpp */
namespace lib { template<class Graph> struct lowest_common_ancestor { using size_type = internal::size_t; using graph_type = Graph; using edge_type = typename graph_type::edge_type; using cost_type = typename graph_type::cost_type; valarray<valarray<size_type>> parent; valarray<size_type> depth; valarray<cost_type> cost; private: void dfs(const graph_type &G, const edge_type& e) noexcept(NO_EXCEPT) { this->parent[0][e.to] = e.from; if(e.from >= 0) { this->depth[e.to] = this->depth[e.from] + 1; this->cost[e.to] = this->cost[e.from] + e.cost; } ITR(f, G[e.to]) { if(f.to != e.from) dfs(G, f); } } public: lowest_common_ancestor(const graph_type &G, const size_type root = 0) noexcept(NO_EXCEPT) { this->init(G, root); } void init(const graph_type &G, const size_type root = 0) noexcept(NO_EXCEPT) { const size_type n = static_cast<size_type>(G.size()); const size_type d = std::bit_width<std::make_unsigned_t<size_type>>(n); this->parent.assign(d, valarray<size_type>(n, -1)); this->depth.assign(n, 0), this->cost.assign(n, 0); this->dfs(G, edge_type(-1, root, 0)); REP(k, d-1) REP(v, n) { if(this->parent[k][v] < 0) this->parent[k+1][v] = -1; else this->parent[k+1][v] = this->parent[k][this->parent[k][v]]; } } size_type operator()(const size_type u, const size_type v) const noexcept(NO_EXCEPT) { return this->find(u, v); } size_type find(size_type u, size_type v) const noexcept(NO_EXCEPT) { if(this->depth[u] < this->depth[v]) std::swap(u, v); size_type d = static_cast<size_type>(this->parent.size()); REP(k, d) { if((this->depth[u] - this->depth[v]) >> k & 1) u = this->parent[k][u]; } if(u == v) return u; REPD(k, d) { if(this->parent[k][u] != this->parent[k][v]) { u = this->parent[k][u]; v = this->parent[k][v]; } } return this->parent[0][u]; } size_type distance_ignored_cost(const size_type u, const size_type v) const noexcept(NO_EXCEPT) { return this->depth[u] + this->depth[v] - 2 * this->depth[find(u, v)]; } size_type distance(const size_type u, const size_type v) const noexcept(NO_EXCEPT) { return this->cost[u] + this->cost[v] - 2 * this->cost[find(u, v)]; } }; }
/* [end]: graph/lowest_common_ancestor.hpp*/
/* [begin]: numeric/int128.hpp */
#ifndef INCLUDED_INT128
#define INCLUDED_INT128
#include <cctype>
namespace std { template<class C, class S> basic_istream<C,S>& operator>>(std::basic_istream<C,S>& in, lib::i128& v) noexcept(NO_EXCEPT) { std::string str; in >> str; v = 0; bool negative = (str[0] == '-'); REP(d, std::next(str.begin(), negative), str.end()) { assert(std::isdigit(*d)); v = v * 10 + *d - '0'; } if(negative) v *= -1; return in; } template<class C, class S> basic_istream<C,S>& operator>>(std::basic_istream<C,S>& in, lib::u128& v) noexcept(NO_EXCEPT) { std::string str; in >> str; v = 0U; assert(str[0] != '-'); REP(d, str.begin(), str.end()) { assert(std::isdigit(*d)); v = v * 10U + *d - '0'; } return in; } template<class C, class S> basic_ostream<C,S>& operator<<(std::basic_ostream<C,S>& out, lib::i128 v) noexcept(NO_EXCEPT) { if(v == 0) return out << 0; if(v < 0) out << '-', v *= -1; std::string str; while(v > 0) str += static_cast<char>(v%10) + '0', v /= 10; std::reverse(str.begin(), str.end()); return out << str; } template<class C, class S> basic_ostream<C,S>& operator<<(std::basic_ostream<C,S>& out, lib::u128 v) noexcept(NO_EXCEPT) { if(v == 0) return out << 0U; std::string str; while(v > 0) str += static_cast<char>(v%10U) + '0', v /= 10U; std::reverse(str.begin(), str.end()); return out << str; } }
#endif
/* [end]: numeric/int128.hpp*/
/* [begin]: numeric/matrix.hpp */
namespace lib { namespace internal { namespace matrix_impl { template<class T> struct interface : virtual grid_impl::interface<T> { }; } template<class T, class base> struct matrix_core : base, virtual matrix_impl::interface<T> { using base::base; static inline matrix_core identity(const size_t n, const T &&val = { 1 }) noexcept(NO_EXCEPT) { matrix_core res(n); REP(i, n) res(i, i) = val; return res; } inline size_t rows() const noexcept(NO_EXCEPT) /*override*/ { return this->height(); } inline size_t cols() const noexcept(NO_EXCEPT) /*override*/ { return this->width(); } inline size_t square() const noexcept(NO_EXCEPT) /*override*/ { return this->rows() == this->cols(); } template<class U> inline matrix_core& operator+=(const U rhs) noexcept(NO_EXCEPT) { REP(i, this->rows()) REP(j, this->cols()) (*this)(i, j) += rhs; return *this; } template<class ...U> inline matrix_core& operator+=(const matrix_core<U...> rhs) noexcept(NO_EXCEPT) { REP(i, this->rows()) REP(j, this->cols()) (*this)(i, j) += rhs(i, j); return *this; } template<class U> inline matrix_core operator+(const U rhs) const noexcept(NO_EXCEPT) { return matrix_core(*this) += rhs; } template<class U> inline matrix_core& operator-=(const U rhs) noexcept(NO_EXCEPT) { REP(i, this->rows()) REP(j, this->cols()) (*this)(i, j) -= rhs; return *this; } template<class ...U> inline matrix_core& operator-=(const matrix_core<U...> rhs) noexcept(NO_EXCEPT) { REP(i, this->rows()) REP(j, this->cols()) (*this)(i, j) -= rhs(i, j); return *this; } template<class U> inline matrix_core operator-(const U rhs) const noexcept(NO_EXCEPT) { return matrix_core(*this) -= rhs; } template<class ...U> inline matrix_core operator*(const matrix_core<U...> rhs) noexcept(NO_EXCEPT) { assert(this->cols() == rhs.rows()); matrix_core res(this->rows(), rhs.cols()); REP(i, this->rows()) REP(j, rhs.cols()) REP(k, this->cols()) { res(i, j) += (*this)(i, k) * rhs(k, j); } return res; } template<class U> inline matrix_core operator*(const U rhs) noexcept(NO_EXCEPT) { matrix_core res(*this); REP(i, res.rows()) REP(j, res.cols()) res(i, j) *= rhs; return res; } template<class U> inline matrix_core& operator*=(const U rhs) noexcept(NO_EXCEPT) { matrix_core res = *this * rhs; this->assign(res); return *this; } template<class U> inline matrix_core& operator/=(const U rhs) noexcept(NO_EXCEPT) { REP(i, this->rows()) REP(j, this->cols()) (*this)(i, j) /= rhs; return *this; } template<class U> inline matrix_core operator/(const U rhs) const noexcept(NO_EXCEPT) { return matrix_core(*this) /= rhs; } template<class U> inline matrix_core& operator%=(const U rhs) noexcept(NO_EXCEPT) { REP(i, this->rows()) REP(j, this->cols()) (*this)(i, j) %= rhs; return *this; } template<class U> inline matrix_core operator%(const U rhs) const noexcept(NO_EXCEPT) { return matrix_core(*this) %= rhs; } inline matrix_core pow(ll p) noexcept(NO_EXCEPT) { assert(this->square()); matrix_core x = *this, res = matrix_core::Identity(this->rows()); while(p > 0) { if(p & 1) res *= x; x *= x; p >>= 1; } return res; } T determinant() const noexcept(NO_EXCEPT) requires modint_family<T> { assert(this->rows() == this->cols()); auto a = *this; T det = T::one; REP(j, a.rows()) { REP(i, j, a.rows()) { if(a[i][j] == 0) continue; if(i != j) std::swap(a[i], a[j]), det = -det; break; } if(a[j][j] == 0) return 0; REP(i, j+1, a.rows()) { while(a[i][j] != 0) { const long long q = a[j][j].val() / a[i][j].val(); const T c = -q; REP(k, j, a.rows()) a[j][k] += a[i][k] * c; std::swap(a[i], a[j]), det = -det; } } } REP(i, a.rows()) det *= a[i][i]; return det; } }; } template<class T, class base = grid<T>> using matrix = internal::matrix_core<T,base>; template<class T> using valmatrix = internal::matrix_core<T,unfolded_grid<T,valarray<T>>>; template<class T> using unfolded_matrix = internal::matrix_core<T,unfolded_grid<T>>; }
/* [end]: numeric/matrix.hpp*/
/* [begin]: numeric/modular/modint.hpp */
namespace lib { namespace internal { template<class, bool> struct modint_base {}; template<class Mint> struct modint_base<Mint, false> { static constexpr Mint zero = Mint::_raw(0); static constexpr Mint one = Mint::_one(); }; template<class Mint> struct modint_base<Mint, true> { static constexpr Mint zero = Mint::_raw(0); static inline Mint one = Mint::_one(); }; } template<internal::modular_context Context> struct modint : internal::modint_base<modint<Context>, Context::dynamic> { using value_type = typename Context::value_type; using context = Context; private: using mint = modint; using base = internal::modint_base<modint, context::dynamic>; friend base; value_type _val = 0; static constexpr mint _raw(const value_type v) noexcept(NO_EXCEPT) { mint res; res._val = v; return res; } static constexpr mint _one() noexcept(NO_EXCEPT) requires internal::has_static_one<typename mint::context::reduction> { return mint::_raw(mint::context::get().one); } static constexpr mint _one() noexcept(NO_EXCEPT) requires (!internal::has_static_one<typename mint::context::reduction>) { return mint::_raw(1); } public: static constexpr int digits = mint::context::reduction::digits; static inline constexpr value_type max() noexcept { return mint::context::reduction::max(); } static constexpr void set_mod(const value_type mod) noexcept(NO_EXCEPT) requires requires(value_type mod) { mint::context::set_mod(mod); } { mint::context::set_mod(mod); mint::one = mint::_one(); } static inline constexpr value_type mod() noexcept(NO_EXCEPT) { return mint::context::get().mod(); } static inline constexpr mint raw(const value_type v) noexcept(NO_EXCEPT) { mint res; res._val = mint::context::get().convert_raw(v); return res; }; constexpr modint() noexcept = default; template<std::integral T> constexpr modint(const T v) noexcept(NO_EXCEPT) : _val(mint::context::get().convert(v)) {} inline constexpr value_type val() const noexcept(NO_EXCEPT) { return mint::context::get().revert(this->_val); } inline constexpr explicit operator value_type() const noexcept(NO_EXCEPT) { return this->val(); } inline constexpr mint& operator+=(const mint& rhs) noexcept(NO_EXCEPT) { this->_val = mint::context::get().add(this->_val, rhs._val); return *this; } inline constexpr mint& operator-=(const mint& rhs) noexcept(NO_EXCEPT) { this->_val = mint::context::get().subtract(this->_val, rhs._val); return *this; } inline constexpr mint& operator*=(const mint& rhs) noexcept(NO_EXCEPT) { this->_val = mint::context::get().multiply(this->_val, rhs._val); return *this; } inline constexpr auto& operator/=(const mint& rhs) noexcept(NO_EXCEPT) { return *this *= rhs.inv(); } constexpr mint pow(const i64 n) const noexcept(NO_EXCEPT) { return mint::_raw(mint::context::get().pow(this->_val, n)); } constexpr mint inv() const noexcept(NO_EXCEPT) { using signed_value_type = std::make_signed_t<value_type>; signed_value_type x = this->val(), y = mint::mod(), u = 1, v = 0; while(y > 0) { signed_value_type t = x / y; std::swap(x -= t * y, y); std::swap(u -= t * v, v); } assert(x == 1); if(u < 0) u += v / x; return mint::raw(u); } friend inline constexpr bool operator==(const mint& lhs, const mint& rhs) noexcept(NO_EXCEPT) { return mint::context::get().equal(lhs._val, rhs._val); } friend inline constexpr bool operator!=(const mint& lhs, const mint& rhs) noexcept(NO_EXCEPT) { return !(lhs == rhs); } inline constexpr mint& operator++() noexcept(NO_EXCEPT) { return *this += mint::one; } inline constexpr mint& operator--() noexcept(NO_EXCEPT) { return *this -= mint::one; } inline constexpr mint operator++(int) noexcept(NO_EXCEPT) { const mint res = *this; return ++*this, res; } inline constexpr mint operator--(int) noexcept(NO_EXCEPT) { const mint res = *this; return --*this, res; } inline constexpr auto operator+() const noexcept(NO_EXCEPT) { return *this; } inline constexpr auto operator-() const noexcept(NO_EXCEPT) { return mint::zero - *this; } friend inline constexpr mint operator+(mint lhs, const mint& rhs) noexcept(NO_EXCEPT) { return lhs += rhs; } friend inline constexpr mint operator-(mint lhs, const mint& rhs) noexcept(NO_EXCEPT) { return lhs -= rhs; } friend inline constexpr mint operator*(mint lhs, const mint& rhs) noexcept(NO_EXCEPT) { return lhs *= rhs; } friend inline constexpr mint operator/(mint lhs, const mint& rhs) noexcept(NO_EXCEPT) { return lhs /= rhs; } }; }
/* [end]: numeric/modular/modint.hpp*/
/* [begin]: numeric/fast_prime.hpp */
/* [begin]: numeric/internal/primality_test.hpp */
namespace lib { namespace internal { namespace fast_factorize_impl { namespace internal { template<modint_family Mint> constexpr bool primality_test(const u64 n, const std::vector<u64>& ws) noexcept(NO_EXCEPT) { if constexpr(dynamic_modint_family<Mint>) Mint::set_mod(n); const u64 d = (n - 1) >> std::countr_zero(n - 1); const Mint rev = n - 1; for(u64 w : ws) { Mint x = w; if(x == Mint::zero) continue; x = x.pow(d); if(x == Mint::one || x == rev) continue; u64 t = d; while(t != n-1 && x != Mint::one && x != rev) x *= x, t <<= 1; if(x != rev) return false; } return true; } template<modint_family Small, modint_family Large = Small> inline constexpr bool is_prime(const u64 n) noexcept(NO_EXCEPT) { if(n == 0 || n == 1) return false; if(~n & 1UL) return n == 2UL; auto bases = [&]() constexpr noexcept(NO_EXCEPT) -> vector<u64> { if(n < 341531UL) return { 9345883071009581737UL }; else if(n < 1050535501UL) return { 336781006125UL, 9639812373923155UL }; else if(n < 350269456337UL) return { 4230279247111683200UL, 14694767155120705706UL, 16641139526367750375UL }; else if(n < 55245642489451UL) return { 2UL, 141889084524735UL, 1199124725622454117UL, 11096072698276303650UL }; else if(n < 7999252175582851UL) return { 2UL, 4130806001517UL, 149795463772692060UL, 186635894390467037UL, 3967304179347715805UL }; else if(n < 585226005592931977UL) return { 2UL, 123635709730000UL, 9233062284813009UL, 43835965440333360UL, 761179012939631437UL, 1263739024124850375UL }; else return { 2UL, 325UL, 9375UL, 28178UL, 450775UL, 9780504UL, 1795265022UL }; }; if(n <= Small::max()) return primality_test<Small>(n, bases()); else return primality_test<Large>(n, bases()); } } } using fast_factorize_impl::internal::is_prime; } }
/* [end]: numeric/internal/primality_test.hpp*/
/* [begin]: numeric/internal/factorize.hpp */
#include <random>
/* [begin]: random/xorshift.hpp */
namespace lib { template<i64 Id = -1> struct xorshift { using result_type = std::uint32_t; static constexpr result_type MIN = std::numeric_limits<result_type>::min(); static constexpr result_type MAX = std::numeric_limits<result_type>::max(); static constexpr result_type min() noexcept(NO_EXCEPT) { return MIN; } static constexpr result_type max() noexcept(NO_EXCEPT) { return MAX; } inline constexpr void seed(unsigned int seed) noexcept(NO_EXCEPT) { this->w = seed; } constexpr xorshift() = default; constexpr xorshift(const std::uint32_t seed) noexcept(NO_EXCEPT) : w(seed) {}; inline constexpr result_type gen() noexcept(NO_EXCEPT) { result_type t; t = x ^ (x << 11); x = y; y = z; z = w; return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); } inline constexpr result_type operator()() noexcept(NO_EXCEPT) { return this->gen(); } private: result_type x = 123456789; result_type y = 362436069; result_type z = 521288629; result_type w = 88675123; }; template<i64 Id = -1> struct xorshift64 { using result_type = std::uint64_t; static constexpr result_type MIN = std::numeric_limits<result_type>::min(); static constexpr result_type MAX = std::numeric_limits<result_type>::max(); static constexpr result_type min() noexcept(NO_EXCEPT) { return MIN; } static constexpr result_type max() noexcept(NO_EXCEPT) { return MAX; } inline constexpr void seed(unsigned int seed) noexcept(NO_EXCEPT) { this->x = seed; } constexpr xorshift64() noexcept(NO_EXCEPT) {}; constexpr xorshift64(const std::uint64_t seed) noexcept(NO_EXCEPT) : x(seed) {}; inline constexpr result_type gen() noexcept(NO_EXCEPT) { x = x ^ (x << 13), x = x ^ (x >> 7), x = x ^ (x << 17); return x; } inline constexpr result_type operator()() noexcept(NO_EXCEPT) { return this->gen(); } private: std::uint64_t x = 3141592653589793238UL; }; xorshift rand; xorshift64 rand64; }
/* [end]: random/xorshift.hpp*/
namespace lib { namespace internal { namespace fast_factorize_impl { namespace internal { template<modint_family Mint, class T> T find_factor(const T n) noexcept(NO_EXCEPT) { if(~n & 1) return 2; if(is_prime<Mint>(n)) return n; assert(static_cast<u64>(Mint::mod()) == n); Mint rr; auto f = [&](const Mint& x) noexcept(NO_EXCEPT) { return x * x + rr; }; static xorshift64<-(1L << 62) + 2> rand(std::random_device{}()); auto rand_ = [&]() noexcept(NO_EXCEPT) { return rand() % (n - 2) + 2; }; while(true) { Mint x, y, ys, q = Mint::one; rr = rand_(), y = rand_(); T g = 1; constexpr int m = 128; for(int r = 1; g == 1; r <<= 1) { x = y; for(int i = 0; i < r; ++i) y = f(y); for(int k = 0; g == 1 && k < r; k += m) { ys = y; for(int i = 0; i < m && i < r - k; ++i) q *= x - (y = f(y)); g = lib::binary_gcd(q.val(), n); } } if(g == n) { do { g = lib::binary_gcd((x - (ys = f(ys))).val(), n); } while(g == 1); } if(g != n) return g; } assert(false); } template<modint_family Small, modint_family Large, std::ranges::range R> void factorize(const u64 n, R *const res) noexcept(NO_EXCEPT) { if(n <= 1) return; u64 p; if constexpr(std::same_as<Small, Large>) p = find_factor<Small, typename Small::value_type>(n); else { if(n <= Small::max()) p = find_factor<Small, typename Small::value_type>(n); else p = find_factor<Large, typename Large::value_type>(n); } if(p == static_cast<u64>(n)) { res->emplace_back(p); return; } factorize<Small, Large>(p, res); factorize<Small, Large>(n / p, res); } } } using fast_factorize_impl::internal::factorize; } }
/* [end]: numeric/internal/factorize.hpp*/
/* [begin]: numeric/internal/divisors.hpp */
namespace lib { namespace internal { template<modint_family Small, modint_family Large, std::ranges::range R> void divisors(const u64 n, R *const res) noexcept(NO_EXCEPT) { if(n == 0) return; std::vector<u64> facts; factorize<Small, Large>(n, &facts); std::ranges::sort(facts); std::vector<std::pair<u64, int>> v; for(auto &p : facts) { if(v.empty() || v.back().first != p) { v.emplace_back(p, 1); } else { v.back().second++; } } using value_type = std::ranges::range_value_t<R>; const auto size = std::ranges::ssize(v); auto f = [&](auto rc, int i, value_type x) noexcept(NO_EXCEPT) -> void { if(i == size) { res->push_back(x); return; } for(int j = v[i].second; ; --j) { rc(rc, i + 1, x); if(j == 0) break; x *= static_cast<value_type>(v[i].first); } }; f(f, 0, 1); } } }
/* [end]: numeric/internal/divisors.hpp*/
/* [begin]: numeric/internal/primitive_root.hpp */
namespace lib { namespace internal { template<modint_family Small, modint_family Large, modint_family Mint, std::unsigned_integral T> T primitive_root(const T p) noexcept(NO_EXCEPT) { std::vector<T> pows; factorize<Small, Large>(p - 1, &pows); { std::ranges::sort(pows); const auto rest = std::ranges::unique(pows); pows.erase(ALL(rest)); } ITRR(pow, pows) pow = (p - 1) / pow; if constexpr(dynamic_modint_family<Mint>) Mint::set_mod(p); assert(Mint::mod() == p); static xorshift64<-(1L << 62) + 3> rand; while(true) { const Mint x = rand(); if(x == Mint::zero) continue; bool ok = true; ITR(pow, pows) { if(x.pow(pow) == Mint::one) { ok = false; break; } } if(ok) return x.val(); } return 0; } template<static_modint_family Mint> constexpr u32 primitive_root_constexpr(u32 m) { assert(Mint::mod() == m); u32 divs[20] = {}; divs[0] = 2; u32 cnt = 1; u64 x = (m - 1) / 2; while(x % 2 == 0) x /= 2; for(u64 i = 3; i * i <= x; i += 2) { if(x % i == 0) { divs[cnt++] = i; while(x % i == 0) x /= i; } } if(x > 1) divs[cnt++] = x; for(u32 g = 2; ; g++) { bool ok = true; REP(i, cnt) { if(Mint{ g }.pow((m - 1) / divs[i]) == 1) { ok = false; break; } } if(ok) return g; } } template<modint_family Small, modint_family Large = Small, std::integral Res = u64> constexpr Res primitive_root(const u64 p) noexcept(NO_EXCEPT) { if(p == 2) return 1; if(p == 167772161) return 3; if(p == 469762049) return 3; if(p == 754974721) return 11; if(p == 998244353) return 3; if(std::is_constant_evaluated()) { if constexpr(static_modint_family<Small> && std::same_as<Small, Large> && Small::mod() < (1U << 31)) { assert(p <= std::numeric_limits<u32>::max()); return primitive_root_constexpr<Small>(p); } assert(false); } else { if(p <= Small::max()) return primitive_root<Small, Large, Small, typename Small::value_type>(p); else return primitive_root<Small, Large, Large, typename Large::value_type>(p); } } } }
/* [end]: numeric/internal/primitive_root.hpp*/
namespace lib { namespace internal { constexpr i64 INTERNAL_MODINT_ID = -(1L << 62); inline constexpr bool is_prime(const i64 n) noexcept(NO_EXCEPT) { assert(n >= 0); return is_prime<lib::dynamic_montgomery_modint_32bit<INTERNAL_MODINT_ID>, lib::dynamic_montgomery_modint_64bit<INTERNAL_MODINT_ID>>(n); } inline auto factorize(const i64 n) noexcept(NO_EXCEPT) { assert(n >= 0); vector<i64> res; factorize<lib::dynamic_montgomery_modint_32bit<INTERNAL_MODINT_ID>, lib::dynamic_montgomery_modint_64bit<INTERNAL_MODINT_ID>>(n, &res); return res; } inline auto divisors(const i64 n) noexcept(NO_EXCEPT) { assert(n >= 0); vector<i64> res; divisors<lib::dynamic_montgomery_modint_32bit<INTERNAL_MODINT_ID>, lib::dynamic_montgomery_modint_64bit<INTERNAL_MODINT_ID>>(n, &res); std::ranges::sort(res); return res; } inline auto primitive_root(const i64 n) noexcept(NO_EXCEPT) { assert(n >= 0); return primitive_root<lib::dynamic_montgomery_modint_32bit<INTERNAL_MODINT_ID>, lib::dynamic_montgomery_modint_64bit<INTERNAL_MODINT_ID>, i64>(n); } } using internal::is_prime; using internal::divisors; using internal::primitive_root; inline vector<i64> factorize(const i64 n) noexcept(NO_EXCEPT) { assert(n >= 0); auto res = internal::factorize(n); std::ranges::sort(res); return res; } inline set<i64> prime_factors(const i64 n) noexcept(NO_EXCEPT) { assert(n >= 0); const auto factors = factorize(n); set<i64> res(ALL(factors)); return res; } inline map<i64,i64> count_factors(const i64 n) noexcept(NO_EXCEPT) { assert(n >= 0); map<i64,i64> mp; for(auto &x : internal::factorize(n)) mp[x]++; return mp; } }
/* [end]: numeric/fast_prime.hpp*/
/* [begin]: numeric/prime_enumerator.hpp */
namespace lib { template<class T> struct prime_enumerator : std::ranges::view_interface<prime_enumerator<T>> { using value_type = T; using size_type = internal::size_t; protected: using impl_type = std::uint32_t; impl_type _n = 0; using small_bit_type = std::uint8_t; using large_bit_type = std::uint64_t; inline static constexpr impl_type SEGMENT_SIZE = 1'000'000; inline static constexpr impl_type MOD30[8] = { 1, 7, 11, 13, 17, 19, 23, 29 }; inline static constexpr small_bit_type MASK[8][8] = { { 0xfe, 0xfd, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x7f }, { 0xfd, 0xdf, 0xef, 0xfe, 0x7f, 0xf7, 0xfb, 0xbf }, { 0xfb, 0xef, 0xfe, 0xbf, 0xfd, 0x7f, 0xf7, 0xdf }, { 0xf7, 0xfe, 0xbf, 0xdf, 0xfb, 0xfd, 0x7f, 0xef }, { 0xef, 0x7f, 0xfd, 0xfb, 0xdf, 0xbf, 0xfe, 0xf7 }, { 0xdf, 0xf7, 0x7f, 0xfd, 0xbf, 0xfe, 0xef, 0xfb }, { 0xbf, 0xfb, 0xf7, 0x7f, 0xfe, 0xef, 0xdf, 0xfd }, { 0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe }, }; inline static constexpr impl_type C1[8] = { 6, 4, 2, 4, 2, 4, 6, 2 }; inline static constexpr impl_type C0[8][8] = { { 0, 0, 0, 0, 0, 0, 0, 1 }, { 1, 1, 1, 0, 1, 1, 1, 1 }, { 2, 2, 0, 2, 0, 2, 2, 1 }, { 3, 1, 1, 2, 1, 1, 3, 1 }, { 3, 3, 1, 2, 1, 3, 3, 1 }, { 4, 2, 2, 2, 2, 2, 4, 1 }, { 5, 3, 1, 4, 1, 3, 5, 1 }, { 6, 4, 2, 4, 2, 4, 6, 1 }, }; size_type _size; impl_type _sqrt_n = 0, _sqrt_ni = 0, _quart_n = 0; std::valarray<small_bit_type> _small; std::valarray<large_bit_type> _large; std::vector<impl_type> _indecies; small_bit_type* _flag = nullptr; inline void _init(const value_type n, const impl_type size) noexcept(NO_EXCEPT) { const size_type blocks = (size + 7) >> 3; this->_large.resize(blocks + 1, ~0UL); this->_flag = reinterpret_cast<small_bit_type*>(&(this->_large[0])); this->_flag[0] = 0xfe; value_type r = n % 30; if(r <= 1) this->_flag[size - 1] = 0x0; else if(r <= 7) this->_flag[size - 1] = 0x1; else if(r <= 11) this->_flag[size - 1] = 0x3; else if(r <= 13) this->_flag[size - 1] = 0x7; else if(r <= 17) this->_flag[size - 1] = 0xf; else if(r <= 19) this->_flag[size - 1] = 0x1f; else if(r <= 23) this->_flag[size - 1] = 0x3f; else if(r <= 29) this->_flag[size - 1] = 0x7f; if(n < 30) this->_flag[0] &= 0xfe; this->_large[blocks - 1] <<= 64 - ((size & 7) << 3); this->_large[blocks - 1] >>= 64 - ((size & 7) << 3); this->_large[blocks] = 0; } inline void _gen_small() noexcept(NO_EXCEPT) { const impl_type quart_ni = this->_quart_n / 30 + 1; this->_small.resize(this->_sqrt_ni, 0xff); this->_small[0] = 0xfe; REP(i, quart_ni) { for(small_bit_type flags = this->_small[i]; flags; flags &= flags - 1) { const int ibit = lowest_bit_pos(flags); const impl_type m = prime_enumerator::MOD30[ibit]; const impl_type pm = 30 * i + 2 * m; for( impl_type j = i * pm + (m * m) / 30, k = ibit; j < this->_sqrt_ni; j += i * prime_enumerator::C1[k] + prime_enumerator::C0[ibit][k], k = (k + 1) & 7 ) { this->_small[j] &= prime_enumerator::MASK[ibit][k]; } } } REP(i, this->_sqrt_ni) { for(small_bit_type flags = this->_small[i]; flags; flags &= flags - 1) { const int ibit = lowest_bit_pos(flags); const impl_type m = prime_enumerator::MOD30[ibit]; impl_type j = i * (30 * i + 2 * m) + (m * m) / 30; this->_indecies.emplace_back(((j + prime_enumerator::SEGMENT_SIZE) << 3) | ibit); } } } inline void _gen_core(small_bit_type *const flags, const impl_type size) noexcept(NO_EXCEPT) { auto p_index = this->_indecies.begin(); REP(i, this->_sqrt_ni) { for(small_bit_type primes = this->_small[i]; primes; primes &= primes - 1) { const int ibit = lowest_bit_pos(primes); impl_type j = (*p_index >> 3) - prime_enumerator::SEGMENT_SIZE; impl_type k = *p_index & 7; for(; j < size; j += i * prime_enumerator::C1[k] + prime_enumerator::C0[ibit][k], k = (k + 1) & 7) { flags[j] &= prime_enumerator::MASK[ibit][k]; } *p_index = ((j << 3) | k); ++p_index; } } } using iterator_interface = internal::bidirectional_iterator_interface<const value_type>; public: struct iterator; using const_iterator = iterator; prime_enumerator() noexcept {}; prime_enumerator(const value_type n) noexcept(NO_EXCEPT) : _n(n) { assert(n >= 0); assert(std::endian::native == std::endian::little); this->_sqrt_n = static_cast<impl_type>(sqrt_ceil(this->_n + 1)); this->_sqrt_ni = this->_sqrt_n / 30 + 1; this->_quart_n = static_cast<impl_type>(sqrt_ceil(this->_sqrt_n)); this->_gen_small(); impl_type size = (this->_n + 1) / 30 + 1; this->_init(this->_n + 1, size); for(small_bit_type* seg = this->_flag; ; seg += prime_enumerator::SEGMENT_SIZE) { if(size < prime_enumerator::SEGMENT_SIZE) { this->_gen_core(seg, size); break; }; this->_gen_core(seg, prime_enumerator::SEGMENT_SIZE); size -= prime_enumerator::SEGMENT_SIZE; } this->_size = (this->_n >= 2) + (this->_n >= 3) + (this->_n >= 5); for(const large_bit_type f : this->_large) this->_size += std::popcount(f); } inline size_type size() const noexcept(NO_EXCEPT) { return this->_size; } inline size_type count(const T x) const noexcept(NO_EXCEPT) { assert(0 <= x and x <= this->_n); size_type res = (x >= 2) + (x >= 3) + (x >= 5); T count = 0; constexpr int large_bit_width = std::numeric_limits<large_bit_type>::digits; constexpr int large_bit_size = (30 * large_bit_width) >> 3; for(const large_bit_type f : this->_large) { if(count + large_bit_size > x) { REP(i, large_bit_width) { if(count + prime_enumerator::MOD30[i & 7] > x) break; if((f >> i) & 1) res++; if(((i + 1) & 7) == 0) count += 30; } break; } res += std::popcount(f); count += large_bit_size; } return res; } inline size_type count(const T l, const T r) const noexcept(NO_EXCEPT) { assert(l <= r); return this->count(r) - this->count(l - 1); } inline bool is_prime(const T v) const noexcept(NO_EXCEPT) { assert(0 <= v and v <= this->_n); if(v == 0 or v == 1) return false; if(v == 2 or v == 3 or v == 5) return true; if((v & 1) == 0 or v % 3 == 0 or v % 5 == 0) return false; REP(i, 8) { if(prime_enumerator::MOD30[i] == v % 30) { return static_cast<bool>((this->_flag[v / 30] >> i) & 1); } } assert(false); } inline iterator begin() const noexcept(NO_EXCEPT) { return iterator(this, 0); } inline iterator end() const noexcept(NO_EXCEPT) { return iterator(this, -1); } inline auto rbegin() const noexcept(NO_EXCEPT) { return std::make_reverse_iterator(this->end()); } inline auto rend() const noexcept(NO_EXCEPT) { return std::make_reverse_iterator(this->begin()); } struct iterator : virtual iterator_interface { protected: value_type _n = 0; size_type _index = 0; const std::valarray<large_bit_type>* _flags = nullptr; size_type _block = -1, _flag_size; int _bit = 0; inline value_type _value() const noexcept(NO_EXCEPT) { if(this->_bit < 0) return numeric_limits<value_type>::arithmetic_infinity(); if(this->_block < 0) { if(this->_bit == 0) return 2; if(this->_bit == 1) return 3; if(this->_bit == 2) return 5; } return ( value_type{30} * ((this->_block << 3) + (this->_bit >> 3)) + prime_enumerator::MOD30[this->_bit & 7] ); } public: iterator() noexcept = default; iterator(const prime_enumerator *const super, const int bit) noexcept(NO_EXCEPT) : _n(super->_n), _flags(&super->_large), _flag_size(static_cast<size_type>(super->_large.size())), _bit(bit) { if(bit < 0) { this->_index = super->size(); this->_block = static_cast<size_type>(super->_large.size()) - 1; } } inline size_type index() const noexcept(NO_EXCEPT) { return this->_index; } inline value_type operator*() const noexcept(NO_EXCEPT) { const value_type res = this->_value(); return (res > this->_n ? -1 : res); } inline iterator& operator++() noexcept(NO_EXCEPT) { if(this->_value() > this->_n) return *this; ++this->_index; if(this->_block < 0) { ++this->_bit; if(this->_bit > 2) this->_block = 0, this->_bit = 1; return *this; } int next; while(true) { const large_bit_type mask = this->_bit >= 63 ? 0UL : ~((1UL << (this->_bit + 1)) - 1); next = lowest_bit_pos(this->_flags->operator[](this->_block) & mask); if(next >= 0) break; this->_block++; this->_bit = -1; if(this->_block >= this->_flag_size) break; } this->_bit = next; return *this; } inline iterator& operator--() noexcept(NO_EXCEPT) { if(this->_block < 0) { if(this->_bit > 0) --this->_bit, --this->_index; return *this; } --this->_index; int prev = -1; while(true) { if(0 < this->_bit) { const large_bit_type mask = this->_bit >= 64 ? ~0UL : ((1UL << this->_bit) - 1); prev = highest_bit_pos(this->_flags->operator[](this->_block) & mask); } if(prev >= 0) break; --this->_block; this->_bit = 64; if(this->_block < 0) { this->_bit = (this->_n >= 3) + (this->_n >= 5); return *this; } } this->_bit = prev; return *this; } inline iterator operator++(int) noexcept(NO_EXCEPT) { const auto res = *this; ++(*this); return res; } inline iterator operator--(int) noexcept(NO_EXCEPT) { const auto res = *this; --(*this); return res; } friend inline bool operator==(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) { return lhs._index == rhs._index; } friend inline bool operator!=(const iterator& lhs, const iterator& rhs) noexcept(NO_EXCEPT) { return lhs._index != rhs._index; } friend inline bool operator<(const iterator& lhs, const iterator& rhs) { return lhs._index < rhs._index; } friend inline bool operator>(const iterator& lhs, const iterator& rhs) { return lhs._index > rhs._index; } friend inline size_type operator-(const iterator& lhs, const iterator& rhs) { return lhs._index - rhs._index; } }; }; } namespace std::ranges { template<class T> inline constexpr bool enable_borrowed_range<lib::prime_enumerator<T>> = true; }
/* [end]: numeric/prime_enumerator.hpp*/
/* [begin]: numeric/prime_sieve.hpp */
namespace lib { template<class container = valarray<bool>> struct prime_flags : container { prime_flags(const internal::size_t max) noexcept(NO_EXCEPT) : container(max+1, true) { (*this)[0] = (*this)[1] = false; for(internal::size_t p=2; p*p<=max; p++) if((*this)[p]) { for(internal::size_t i=p*p; i<=max; i+=p) (*this)[i] = false; } } }; template<class T, class container = vector<T>> struct prime_sieve : container { protected: std::vector<bool> is_prime; public: prime_sieve() noexcept(NO_EXCEPT) {} prime_sieve(const T max) noexcept(NO_EXCEPT) : is_prime(max+1, true) { is_prime[0] = is_prime[1] = false; FOR(p, T{2}, max) { if(is_prime[p]) { for(T i = mul_overflow(p,p).value_or(max+1); i<=max; i+=p) is_prime[i] = false; this->emplace_back(p); } } } inline bool operator()(const T index) const noexcept(NO_EXCEPT) { return is_prime[index]; } }; }
/* [end]: numeric/prime_sieve.hpp*/
/* [begin]: numeric/factorial.hpp */
namespace lib { namespace internal { template<class T> struct factorial_base { using value_type = T; using size_type = internal::size_t; inline static constexpr value_type calc(const size_type& n) noexcept(NO_EXCEPT) { assert(n >= 0); value_type ans = 1; FOR(k, 1, n) ans *= k; return ans; } }; } template<class> struct factorial {}; template<std::integral T> struct factorial<T> : internal::factorial_base<T> { using value_type = T; using size_type = internal::size_t; private: size_type _n; std::valarray<value_type> _fact; public: factorial(const size_type n) noexcept(NO_EXCEPT) : _n(n), _fact(n + 1) { this->_fact[0] = this->_fact[1] = 1; FOR(i, 2, n) this->_fact[i] = this->_fact[i - 1] * i; } inline value_type fact(const size_type k) noexcept(NO_EXCEPT) { assert(0 <= k and k <= this->_n); return this->_fact[k]; } inline value_type operator()(const size_type k) noexcept(NO_EXCEPT) { return this->fact(k); } auto _debug() const { return this->_fact; } }; template<lib::internal::modint_family T> struct factorial<T> : internal::factorial_base<T> { using value_type = T; using size_type = internal::size_t; private: size_type _n; std::valarray<value_type> _fact, _ifact, _inv; public: factorial(const size_type n) noexcept(NO_EXCEPT) : _n(n), _fact(n + 1), _ifact(n + 1), _inv(n + 1) { constexpr auto P = T::mod(); this->_fact[0] = this->_fact[1] = 1; this->_ifact[0] = this->_ifact[1] = 1; this->_inv[1] = 1; FOR(i, 2, n) { this->_inv[i] = -this->_inv[P % i] * (P / i); this->_fact[i] = this->_fact[i - 1] * i; this->_ifact[i] = this->_ifact[i - 1] * this->_inv[i]; } } inline value_type fact(const size_type k) noexcept(NO_EXCEPT) { assert(0 <= k and k <= this->_n); return this->_fact[k]; } inline value_type operator()(const size_type k) noexcept(NO_EXCEPT) { return this->fact(k); } inline value_type ifact(const size_type k) noexcept(NO_EXCEPT) { assert(0 <= k and k <= this->_n); return this->_ifact[k]; } inline value_type inv(const size_type k) noexcept(NO_EXCEPT) { assert(0 <= k and k <= this->_n); return this->_inv[k]; } inline value_type bimom(const size_type n, const size_type r) noexcept(NO_EXCEPT) { assert(0 <= r and r <= n and n <= this->_n); return this->fact(n) * this->ifact(r) * this->ifact(n - r); } auto _debug() const { return this->_fact; } }; }
/* [end]: numeric/factorial.hpp*/
/* [begin]: utility/string.hpp */
namespace lib { template<std::input_iterator I, std::sentinel_for<I> S, class Res = std::string> Res to_lower(I first, S last) noexcept(NO_EXCEPT) { Res res; res.reserve(std::distance(first, last)); std::transform(first, last, std::back_inserter(res), ::tolower); return res; } template<std::input_iterator I, std::sentinel_for<I> S, class Res = std::string> Res to_uppwer(I first, S last) noexcept(NO_EXCEPT) { Res res; res.reserve(std::distance(first, last)); std::transform(first, last, std::back_inserter(res), ::toupper); return res; } template<class Res = std::string> Res to_lower(const std::string str) noexcept(NO_EXCEPT) { return to_lower<std::string::const_iterator,Res>(std::begin(str), std::end(str)); } template<class Res = std::string> Res to_uppwer(const std::string str) noexcept(NO_EXCEPT) { return to_uppwer<std::string::const_iterator,Res>(std::begin(str), std::end(str)); } }
/* [end]: utility/string.hpp*/
/* [begin]: utility/restrictor.hpp */
namespace lib { template<class T, T INF, T SUP> struct static_restrictor { using restrictor = static_restrictor; protected: T _v = INF; inline void _clamp() noexcept(NO_EXCEPT) { this->_v = std::clamp(this->_v, INF, SUP); } inline restrictor& _assign(const T& v) noexcept(NO_EXCEPT) { this->_v = std::clamp(v, INF, SUP); return *this; } inline restrictor& _assign_raw(const T& v) noexcept(NO_EXCEPT) { this->_v = v; return *this; } public: static_restrictor() noexcept(NO_EXCEPT) = default; static_restrictor(T v) noexcept(NO_EXCEPT) : _v(v) { this->_clamp(); } inline T val() const noexcept(NO_EXCEPT) { return this->_v; } static inline static_restrictor raw(const T& v) noexcept(NO_EXCEPT) { static_restrictor res; res._assign_raw(v); return res; } restrictor& operator++() noexcept(NO_EXCEPT) { return this->_assign(this->_v + 1); } restrictor& operator--() noexcept(NO_EXCEPT) { return this->_assign(this->_v - 1); } restrictor operator++(int) noexcept(NO_EXCEPT) { auto res = *this; return ++(*this), res; } restrictor operator--(int) noexcept(NO_EXCEPT) { auto res = *this; return --(*this), res; } restrictor& operator+=(const restrictor& rhs) noexcept(NO_EXCEPT) { return this->_assign_raw(add_clamp(this->_v, rhs._v, INF, SUP)); } restrictor& operator-=(const restrictor& rhs) noexcept(NO_EXCEPT) { return this->_assign_raw(sub_clamp(this->_v, rhs._v, INF, SUP)); } restrictor& operator*=(const restrictor& rhs) noexcept(NO_EXCEPT) { return this->_assign_raw(mul_clamp(this->_v, rhs._v, INF, SUP)); } restrictor& operator/=(const restrictor& rhs) noexcept(NO_EXCEPT) { return this->_assign(this->_v / rhs.val()); } restrictor operator+() const noexcept(NO_EXCEPT) { return *this; } restrictor operator-() const noexcept(NO_EXCEPT) { return restrictor(-this->_v); } friend restrictor operator+(restrictor lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs += rhs; } friend restrictor operator-(restrictor lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs -= rhs; } friend restrictor operator*(restrictor lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs *= rhs; } friend restrictor operator/(restrictor lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs /= rhs; } friend bool operator==(const restrictor& lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs._v == rhs._v; } friend bool operator!=(const restrictor& lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs._v != rhs._v; } friend bool operator<(const restrictor& lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs._v < rhs._v; } friend bool operator>(const restrictor& lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs._v > rhs._v; } friend bool operator<=(const restrictor& lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs._v <= rhs._v; } friend bool operator>=(const restrictor& lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs._v >= rhs._v; } friend bool operator<=>(const restrictor& lhs, const restrictor& rhs) noexcept(NO_EXCEPT) { return lhs._v <=> rhs._v; } }; } namespace std { template<class T, T INF, T SUP> T abs(const lib::static_restrictor<T,INF,SUP>& v) noexcept(NO_EXCEPT) { return std::abs(v.val()); } }
/* [end]: utility/restrictor.hpp*/
/* [end]: include/template.hpp*/
using std::cin; using std::cout; using std::pair; using std::tuple; using std::queue; using std::stack; using std::priority_queue; using std::bitset; using std::sort; using std::reverse; using std::min_element; using std::max_element; using lib::i32; using lib::u32; using lib::i64; using lib::u64;
#ifdef __GNUC__
using lib::i128; using lib::u128;
#endif
using lib::uint; using lib::ll; using lib::ull; using lib::ld; using lib::INF32; using lib::INF64; using lib::INF; using lib::MINT; using lib::INV; using lib::SINV; using lib::LN; using lib::SPC; using lib::DIRS4; using lib::DIRS8; using lib::DIRS4P; using lib::DIRS8P; using lib::input_adapter; using lib::output_adapter; using lib::pow_mod; using lib::inv_mod; using lib::spair; using lib::multi_container; using lib::modint998244353; using lib::modint1000000007; using lib::modint_32; using lib::modint_64; using lib::sorted; using lib::reversed; using lib::chmin; using lib::chmax; using lib::matrix; using lib::multiset; using lib::unordered_set; using lib::unordered_multiset; using lib::map; using lib::multimap; using lib::unordered_map; using lib::unordered_multimap; using lib::valarray; using lib::vector; using lib::string; using lib::array;
/* [end]: template/using.hpp*/
/* [end]: template/standard.hpp*/

void solve();

signed main() {
    debug(__cplusplus);
    int $ = 1;
    // std::cin >> $;
    for(int _ = 0; _ < $; ++_) {
        DEBUG("Case: #" + std::to_string(_));
        solve();
    }
    return 0;
}

void solve() {
    int n; input >> n;
    i64 l; input >> l;
    vector<i64> p(n); input >> p;
    p.sort();

    p.push_back(0);
    p.push_back(0);

    int q = 0; input >> q;
    REP(q) {
        i64 s, g, t; input >> s >> g >> t;

        p[n] = s;
        p[n+1] = g;

        lib::valgrid<i64> dp(1 << (n + 2), n + 2, INF32);
        dp[1 << n][n] = 0;

        REP(x, 1 << (n + 2)) {
            REP(i, n + 2) REP(j, n + 2) {
                chmin(dp[x | (1 << i)][i], dp[x][j] + std::abs(p[i] - p[j]) * std::popcount((unsigned)x));
            }
        }

        i64 x = dp[(1 << (n + 2)) - 1][n + 1];
        debug(x);
        print.yesno(x + n <= t);
    }
}
